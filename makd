// src/api/problems.js

export const DEFAULT_RECENT_DAYS = 1;

const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, "");
if (!BASE) throw new Error("Falta VITE_API_URL en .env (ej: https://xxxxx.brs.devtunnels.ms)");

const API = `${BASE}/api/Problems`;

function cleanNull(v) {
  if (v === undefined || v === null) return null;
  if (typeof v === "string") {
    const t = v.trim();
    if (!t) return null;
    const low = t.toLowerCase();
    if (low === "null" || low === "undefined") return null;
    return t;
  }
  return v;
}

// Date local -> "YYYY-MM-DDTHH:mm:ss" (SIN Z)
function toLocalIsoNoZ(d) {
  const pad = (n) => String(n).padStart(2, "0");
  return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(
    d.getMinutes()
  )}:${pad(d.getSeconds())}`;
}

function parseAmPmToken(tok) {
  if (!tok) return null;
  const t = tok.toLowerCase().replace(/\s+/g, "");
  // soporta: am, pm, a.m., p.m., a.m, p.m, a. m., p. m.
  if (t.includes("a.m") || t === "am") return "AM";
  if (t.includes("p.m") || t === "pm") return "PM";
  return null;
}

function parseDateToISO(v) {
  v = cleanNull(v);
  if (!v) return null;

  if (v instanceof Date) {
    const ms = v.getTime();
    return Number.isFinite(ms) ? v.toISOString() : null;
  }

  if (typeof v === "number") {
    const d = new Date(v);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  if (typeof v === "string") {
    let s = v.trim();

    // SQL "YYYY-MM-DD HH:mm:ss" -> ISO friendly
    if (/^\d{4}-\d{2}-\d{2}\s+\d/.test(s)) s = s.replace(" ", "T");

    // ✅ Formato latino: "dd/MM/yyyy" o "dd/MM/yyyy, h:mm:ss a.m./p.m."
    // Ej: "17/12/2025, 6:45:00 p.m."
    const mLat = s.match(
      /^(\d{2})\/(\d{2})\/(\d{4})(?:\s*,\s*(\d{1,2}):(\d{2})(?::(\d{2}))?\s*([ap]\.?\s*m\.?|am|pm)?)?$/i
    );
    if (mLat) {
      const dd = Number(mLat[1]);
      const mm = Number(mLat[2]);
      const yyyy = Number(mLat[3]);

      let hh = mLat[4] != null ? Number(mLat[4]) : 0;
      const mi = mLat[5] != null ? Number(mLat[5]) : 0;
      const ss = mLat[6] != null ? Number(mLat[6]) : 0;

      const ampm = parseAmPmToken(mLat[7]);

      // convierte a 24h si viene AM/PM
      if (ampm === "PM" && hh < 12) hh += 12;
      if (ampm === "AM" && hh === 12) hh = 0;

      const d = new Date(yyyy, mm - 1, dd, hh, mi, ss); // local
      return Number.isFinite(d.getTime()) ? d.toISOString() : null;
    }

    // ✅ Formato: "dd-MM-yyyy ..."
    const mLat2 = s.match(
      /^(\d{2})-(\d{2})-(\d{4})(?:\s*,\s*(\d{1,2}):(\d{2})(?::(\d{2}))?\s*([ap]\.?\s*m\.?|am|pm)?)?$/i
    );
    if (mLat2) {
      const dd = Number(mLat2[1]);
      const mm = Number(mLat2[2]);
      const yyyy = Number(mLat2[3]);

      let hh = mLat2[4] != null ? Number(mLat2[4]) : 0;
      const mi = mLat2[5] != null ? Number(mLat2[5]) : 0;
      const ss = mLat2[6] != null ? Number(mLat2[6]) : 0;

      const ampm = parseAmPmToken(mLat2[7]);

      if (ampm === "PM" && hh < 12) hh += 12;
      if (ampm === "AM" && hh === 12) hh = 0;

      const d = new Date(yyyy, mm - 1, dd, hh, mi, ss);
      return Number.isFinite(d.getTime()) ? d.toISOString() : null;
    }

    // fallback nativo
    const d = new Date(s);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  return null;
}

function normalizeStatus(rawStatus, endTimeISO) {
  const s = cleanNull(rawStatus);
  const up = typeof s === "string" ? s.trim().toUpperCase() : "";

  if (up.includes("OPEN")) return "OPEN";
  if (up.includes("CLOSED") || up.includes("RESOLVED")) return "CLOSED";

  return endTimeISO ? "CLOSED" : "OPEN";
}

function normalizeEnvironment(envRaw) {
  const s = (cleanNull(envRaw) || "").toString().trim();
  const up = s.toUpperCase().replace(/\s+/g, "");
  if (up.includes("NOPRODUCTIVO") || up.includes("NO-PRODUCTIVO") || up.includes("NO_PRODUCTIVO")) {
    return "No Productivo";
  }
  if (up.includes("PRODUCTIVO") || up === "PROD") return "Productivo";
  return s || "";
}

/**
 * IMPORTANTÍSIMO:
 * "NO TCS" contiene "TCS" -> primero detectamos NO TCS.
 * En BD el campo se llama Jurisdiction.
 */
function normalizeJurisdiction(jRaw) {
  const s = (cleanNull(jRaw) || "").toString().trim().toUpperCase().replace(/\s+/g, " ");
  if (s.includes("NO TCS") || s === "NOTCS" || s.includes("NO-TCS")) return "OTROS";
  if (s === "TCS" || s.includes(" TCS") || s.startsWith("TCS") || s.endsWith("TCS")) return "TCS";
  if (s.includes("TCS")) return "TCS";
  return "OTROS";
}

function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    const startRaw =
      p?.startTime ??
      p?.startTimeUtc ??
      p?.StartTime ??
      p?.StartTimeUtc ??
      p?.start_date ??
      p?.Start ??
      null;

    const endRaw =
      p?.endTime ??
      p?.endTimeUtc ??
      p?.EndTime ??
      p?.EndTimeUtc ??
      p?.end_date ??
      p?.End ??
      null;

    const startTime = parseDateToISO(startRaw);
    const endTime = parseDateToISO(endRaw);

    const problemId = p?.problemId ?? p?.displayId ?? p?.DisplayId ?? p?.id ?? p?.pid ?? "";
    const title = p?.title ?? p?.Title ?? p?.shortDescription ?? p?.ShortDescription ?? "(sin título)";

    const severityLevel = p?.severityLevel ?? p?.SeverityLevel ?? p?.severity ?? "";
    const impactLevel = p?.impactLevel ?? p?.ImpactLevel ?? p?.impact ?? "";

    const env = normalizeEnvironment(p?.environment ?? p?.Environment ?? p?.environmentName ?? "");
    const juris = normalizeJurisdiction(p?.jurisdiction ?? p?.Jurisdiction ?? p?.label ?? p?.Label ?? "");

    const affectedCI =
      p?.affectedCI ??
      p?.AffectedCI ??
      p?.affectedEntities ??
      p?.affectedEntitiesList ??
      [];

    const status = normalizeStatus(
      p?.status ?? p?.Status ?? p?.state ?? p?.problemStatus ?? p?.problemState,
      endTime
    );

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment: env,
      jurisdiction: juris,
      affectedCI,
      status,
      tenant: p?.tenant ?? p?.Tenant ?? p?.domain ?? "",
      startTime,
      endTime,
    };
  });
}

// ✅ Query: StartTime >= CONVERT(DATE,GETDATE()-1)  AND StartTime < GETDATE()
export function getYesterdayToNowRangeIso() {
  const now = new Date();
  const start = new Date(now);
  start.setDate(now.getDate() - 1);
  start.setHours(0, 0, 0, 0);
  return { startIso: toLocalIsoNoZ(start), endIso: toLocalIsoNoZ(now) };
}

/**
 * ✅ FIX: NO enviamos start/end al backend (para que no devuelva 0 por parsing del server)
 */
async function fetchPage({ pageNumber, pageSize, signal }) {
  const params = new URLSearchParams();
  params.set("pageNumber", String(pageNumber));
  params.set("pageSize", String(pageSize));

  const url = `${API}?${params.toString()}`;

  const res = await fetch(url, { headers: { accept: "application/json" }, signal });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} en ${url}\n${txt}`);
  }

  const json = await res.json();

  const items = Array.isArray(json)
    ? json
    : json?.results || json?.items || json?.data || json?.value || [];

  return normalize(items);
}

export async function fetchProblemsRange({
  startIso,
  endIso,
  jurisdiction = null, // "TCS" o "OTROS" (opcional)
  pageSize = 500,
  maxPages = 60,
  onBatch,
  signal,
} = {}) {
  let all = [];
  const seen = new Set();

  const startMs = startIso ? new Date(startIso).getTime() : null;
  const endMs = endIso ? new Date(endIso).getTime() : null;

  const target = (jurisdiction || "").toUpperCase().trim();

  let noNewStreak = 0;

  for (let page = 1; page <= maxPages; page++) {
    const batch = await fetchPage({ pageNumber: page, pageSize, signal });
    if (!batch.length) break;

    // ✅ filtro rango exacto: start <= t < end
    // ✅ si NO se puede parsear fecha, NO lo botan (para no quedar en 0)
    const inRange = batch.filter((x) => {
      const t = x.startTime ? new Date(x.startTime).getTime() : null;
      if (!t || !Number.isFinite(t)) return true; // <-- clave para que no muera la pantalla
      if (startMs && t < startMs) return false;
      if (endMs && t >= endMs) return false;
      return true;
    });

    let inScope = inRange;
    if (target) {
      inScope = inRange.filter((x) => String(x.jurisdiction || "").toUpperCase().trim() === target);
    }

    let newCount = 0;
    for (const x of inScope) {
      const key = `${x.problemId || ""}|${x.startTime || ""}|${x.status || ""}`;
      if (!seen.has(key)) {
        seen.add(key);
        all.push(x);
        newCount++;
      }
    }

    if (onBatch) onBatch(inScope, page);

    if (newCount === 0) noNewStreak++;
    else noNewStreak = 0;

    if (noNewStreak >= 3) break;
    if (batch.length < pageSize) break;
  }

  all.sort((a, b) => {
    const da = a.startTime ? new Date(a.startTime).getTime() : 0;
    const db = b.startTime ? new Date(b.startTime).getTime() : 0;
    return db - da;
  });

  return all;
}

export async function fetchLatestSignature({
  startIso,
  endIso,
  jurisdiction = "TCS",
  signal,
} = {}) {
  const batch = await fetchPage({ pageNumber: 1, pageSize: 200, signal });

  const startMs = startIso ? new Date(startIso).getTime() : null;
  const endMs = endIso ? new Date(endIso).getTime() : null;
  const target = (jurisdiction || "").toUpperCase().trim();

  const filtered = batch
    .filter((x) => {
      const t = x.startTime ? new Date(x.startTime).getTime() : null;
      if (!t || !Number.isFinite(t)) return true;
      if (startMs && t < startMs) return false;
      if (endMs && t >= endMs) return false;
      return true;
    })
    .filter((x) => String(x.jurisdiction || "").toUpperCase().trim() === target)
    .sort((a, b) => {
      const da = a.startTime ? new Date(a.startTime).getTime() : 0;
      const db = b.startTime ? new Date(b.startTime).getTime() : 0;
      return db - da;
    });

  const top = filtered[0];
  if (!top) return null;

  return `${top.problemId || ""}|${top.status || ""}|${top.startTime || ""}|${top.endTime || ""}`;
}

----


