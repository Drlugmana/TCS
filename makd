// src/api/problems.js
// ===========================
// Traer por defecto: desde AYER 00:00 (hora local) hasta AHORA
export const DEFAULT_RECENT_DAYS = 1;

// ===========================
// BASE DE LA API (desde .env)
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, "");
if (!BASE) throw new Error("Falta VITE_API_URL en .env (ej: https://xxxxx.brs.devtunnels.ms)");

const API = `${BASE}/api/Problems`;

// ===========================
// Helpers
function cleanNull(v) {
  if (v === undefined || v === null) return null;
  if (typeof v === "string") {
    const t = v.trim();
    if (!t) return null;
    const low = t.toLowerCase();
    if (low === "null" || low === "undefined") return null;
    return t;
  }
  return v;
}

// ---- IMPORTANTE: NO usar toISOString() para el rango,
// porque eso lo vuelve UTC y te corre horas (en Ecuador -05:00).
// En vez de eso mandamos "YYYY-MM-DDTHH:mm:ss" SIN Z => el backend lo interpreta local.
function pad2(n) {
  return String(n).padStart(2, "0");
}

function toLocalDateTimeString(d) {
  return (
    `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}` +
    `T${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`
  );
}

function parseDateToISO(v) {
  v = cleanNull(v);
  if (!v) return null;

  if (v instanceof Date) {
    const ms = v.getTime();
    return Number.isFinite(ms) ? v.toISOString() : null;
  }

  if (typeof v === "number") {
    const d = new Date(v);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  if (typeof v === "string") {
    let s = v.trim();

    // SQL "YYYY-MM-DD HH:mm:ss" -> ISO friendly
    if (/^\d{4}-\d{2}-\d{2}\s+\d/.test(s)) s = s.replace(" ", "T");

    const d = new Date(s);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  return null;
}

function normalizeStatus(rawStatus, endTimeISO) {
  const s = cleanNull(rawStatus);
  const up = typeof s === "string" ? s.trim().toUpperCase() : "";

  // Si viene OPEN => OPEN
  if (up === "OPEN" || up.includes(" OPEN")) return "OPEN";

  // Si viene CLOSED/RESOLVED => CLOSED
  if (up === "CLOSED" || up.includes("CLOSED") || up.includes("RESOLVED")) return "CLOSED";

  // Fallback solo si NO vino status
  return endTimeISO ? "CLOSED" : "OPEN";
}

function normalizeEnvironment(envRaw) {
  const s = (cleanNull(envRaw) || "").toString().trim();

  // Normaliza variaciones: "NoProductivo", "No Productivo", "NO_PRODUCTIVO"
  const up = s.toUpperCase().replace(/\s+/g, "");
  if (up.includes("NOPRODUCTIVO") || up.includes("NO-PRODUCTIVO") || up.includes("NO_PRODUCTIVO")) {
    return "No Productivo";
  }
  if (up.includes("PRODUCTIVO") || up === "PROD") return "Productivo";

  return s || "";
}

// ‚úÖ FIX CLAVE: "NO TCS" NO puede caer como TCS
function normalizeJurisdiction(jRaw) {
  const s = (cleanNull(jRaw) || "").toString().trim().toUpperCase();

  // casos t√≠picos de NO TCS
  if (s === "NO TCS" || s === "NOTCS" || s.includes("NO TCS")) return "OTROS";

  // solo TCS exacto (o empieza con TCS)
  if (s === "TCS" || s.startsWith("TCS ")) return "TCS";

  return "OTROS";
}

// ===========================
// Normalizador robusto
function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    const startRaw =
      p?.startTime ?? p?.startTimeUtc ?? p?.StartTime ?? p?.StartTimeUtc ?? p?.start_date ?? p?.Start ?? null;

    const endRaw =
      p?.endTime ?? p?.endTimeUtc ?? p?.EndTime ?? p?.EndTimeUtc ?? p?.end_date ?? p?.End ?? null;

    const startTime = parseDateToISO(startRaw);
    const endTime = parseDateToISO(endRaw);

    const problemId = p?.problemId ?? p?.displayId ?? p?.DisplayId ?? p?.id ?? p?.pid ?? "";
    const title = p?.title ?? p?.Title ?? p?.shortDescription ?? p?.ShortDescription ?? "(sin t√≠tulo)";

    const severityLevel = p?.severityLevel ?? p?.SeverityLevel ?? p?.severity ?? p?.Severity ?? "";
    const impactLevel = p?.impactLevel ?? p?.ImpactLevel ?? p?.impact ?? p?.Impact ?? "";

    const env = normalizeEnvironment(p?.environment ?? p?.Environment ?? p?.environmentName ?? "");
    const juris = normalizeJurisdiction(p?.jurisdiction ?? p?.Jurisdiction ?? p?.label ?? p?.Label ?? "");

    const affectedCI =
      p?.affectedCI ??
      p?.AffectedCI ??
      p?.affectedEntities ??
      p?.affectedEntitiesList ??
      [];

    const status = normalizeStatus(
      p?.status ?? p?.Status ?? p?.state ?? p?.problemStatus ?? p?.problemState,
      endTime
    );

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment: env,
      jurisdiction: juris,   // "TCS" | "OTROS"
      affectedCI,
      status,                 // "OPEN" | "CLOSED"
      tenant: p?.tenant ?? p?.Tenant ?? p?.domain ?? "",
      startTime,
      endTime,
    };
  });
}

// ===========================
// Rango: AYER 00:00 local -> AHORA (local)
// Igualito que tu SQL: StartTime >= CONVERT(DATE,GETDATE()-1) AND StartTime < GETDATE()
export function getYesterdayToNowRangeLocal() {
  const now = new Date();
  const start = new Date(now);
  start.setDate(now.getDate() - 1);
  start.setHours(0, 0, 0, 0);

  return {
    startLocal: toLocalDateTimeString(start),
    endLocal: toLocalDateTimeString(now),
  };
}

// ===========================
// Fetch de UNA p√°gina
async function fetchPage({ pageNumber, pageSize, startLocal, endLocal }) {
  const params = new URLSearchParams();
  params.set("pageNumber", String(pageNumber));
  params.set("pageSize", String(pageSize));

  // Mandamos en local SIN Z para que no se corra por UTC
  if (startLocal) params.set("start", startLocal);
  if (endLocal) params.set("end", endLocal);

  const url = `${API}?${params.toString()}`;
  const res = await fetch(url, { headers: { accept: "application/json" } });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} en ${url}\n${txt}`);
  }

  const json = await res.json();

  const items = Array.isArray(json)
    ? json
    : json?.results || json?.items || json?.data || json?.value || [];

  return normalize(items);
}

// ===========================
// Fetch con paginado (trae TODO lo del rango)
// ‚úÖ performance: subimos pageSize por defecto para que cargue m√°s r√°pido (menos requests)
export async function fetchProblemsRange({
  startLocal,
  endLocal,
  pageSize = 5000,   // antes 500 => demasiadas p√°ginas y lento
  maxPages = 30,     // ajusta si necesitas m√°s
  onBatch,
} = {}) {
  let all = [];

  for (let page = 1; page <= maxPages; page++) {
    const batch = await fetchPage({ pageNumber: page, pageSize, startLocal, endLocal });
    if (!batch.length) break;

    if (onBatch) onBatch(batch);
    all = all.concat(batch);

    // si el backend devuelve menos que pageSize => √∫ltima p√°gina
    if (batch.length < pageSize) break;
  }

  // orden: m√°s recientes primero
  all.sort((a, b) => {
    const da = a.startTime ? new Date(a.startTime).getTime() : 0;
    const db = b.startTime ? new Date(b.startTime).getTime() : 0;
    return db - da;
  });

  return all;
}

------

import React, { useEffect, useMemo, useRef, useState } from "react";
import { fetchProblemsRange, getYesterdayToNowRangeLocal } from "../api/problems";

const REFRESH_MS = 60_000; // 60s (c√°mbialo a 30_000 si quieres cada 30s)

export default function Tcs() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(false);

  // üëá si t√∫ ya tienes estos estados (tabs/filtros), NO los cambies
  // deja los tuyos tal cual. Solo aseg√∫rate de que setProblems se llame.
  // Ejemplo:
  const [activeEnv, setActiveEnv] = useState("Todos"); // Productivo / No Productivo / Todos
  const [activeStatus, setActiveStatus] = useState("Todos"); // Abiertas / Cerradas / Todos

  const isFetchingRef = useRef(false);
  const timerRef = useRef(null);

  async function loadProblems() {
    // Evita que se solapen llamadas si una demora
    if (isFetchingRef.current) return;
    isFetchingRef.current = true;

    setLoading(true);
    try {
      const { startLocal, endLocal } = getYesterdayToNowRangeLocal();
      const all = await fetchProblemsRange({
        startLocal,
        endLocal,
        pageSize: 5000,
        maxPages: 30,
      });

      // ‚úÖ aqu√≠ filtramos SOLO TCS (para que TCS y Otros no se mezclen)
      const onlyTcs = all.filter((p) => p.jurisdiction === "TCS");
      setProblems(onlyTcs);
    } catch (e) {
      console.error("Error cargando TCS:", e);
      setProblems([]); // opcional
    } finally {
      setLoading(false);
      isFetchingRef.current = false;
    }
  }

  useEffect(() => {
    // 1) carga inicial
    loadProblems();

    // 2) refresco autom√°tico
    timerRef.current = setInterval(() => {
      loadProblems();
    }, REFRESH_MS);

    // cleanup
    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, []);

  // ---- filtros de UI (si ya tienes los tuyos, deja los tuyos) ----
  const filtered = useMemo(() => {
    let list = problems;

    if (activeEnv !== "Todos") {
      list = list.filter((p) => (p.environment || "") === activeEnv);
    }

    if (activeStatus === "Abiertas") {
      list = list.filter((p) => p.status === "OPEN");
    } else if (activeStatus === "Cerradas") {
      list = list.filter((p) => p.status === "CLOSED");
    }

    return list;
  }, [problems, activeEnv, activeStatus]);

  // ---- aqu√≠ NO toco tu dise√±o: solo te dejo un ejemplo m√≠nimo ----
  // En tu c√≥digo real, deja tu render actual, solo cambia el data source a `filtered`.
  return (
    <div>
      {/* Tu UI tal cual */}
      {loading && <div style={{ textAlign: "center" }}>Cargando problemas...</div>}

      {/* Renderiza la lista filtrada */}
      {filtered.map((p) => (
        <div key={p.problemId}>
          {/* TU CARD ORIGINAL AQU√ç */}
          {p.title} - {p.status}
        </div>
      ))}
    </div>
  );
}

----

import React, { useEffect, useMemo, useRef, useState } from "react";
import { fetchProblemsRange, getYesterdayToNowRangeLocal } from "../api/problems";

const REFRESH_MS = 60_000;

export default function Otros() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(false);

  // Si t√∫ ya tienes estos estados, conserva los tuyos
  const [activeEnv, setActiveEnv] = useState("Todos");
  const [activeStatus, setActiveStatus] = useState("Todos");

  const isFetchingRef = useRef(false);
  const timerRef = useRef(null);

  async function loadProblems() {
    if (isFetchingRef.current) return;
    isFetchingRef.current = true;

    setLoading(true);
    try {
      const { startLocal, endLocal } = getYesterdayToNowRangeLocal();
      const all = await fetchProblemsRange({
        startLocal,
        endLocal,
        pageSize: 5000,
        maxPages: 30,
      });

      // ‚úÖ aqu√≠ filtramos SOLO OTROS (NO TCS)
      const onlyOthers = all.filter((p) => p.jurisdiction === "OTROS");
      setProblems(onlyOthers);
    } catch (e) {
      console.error("Error cargando OTROS:", e);
      setProblems([]);
    } finally {
      setLoading(false);
      isFetchingRef.current = false;
    }
  }

  useEffect(() => {
    loadProblems();

    timerRef.current = setInterval(() => {
      loadProblems();
    }, REFRESH_MS);

    return () => {
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, []);

  const filtered = useMemo(() => {
    let list = problems;

    if (activeEnv !== "Todos") {
      list = list.filter((p) => (p.environment || "") === activeEnv);
    }

    if (activeStatus === "Abiertas") {
      list = list.filter((p) => p.status === "OPEN");
    } else if (activeStatus === "Cerradas") {
      list = list.filter((p) => p.status === "CLOSED");
    }

    return list;
  }, [problems, activeEnv, activeStatus]);

  return (
    <div>
      {loading && <div style={{ textAlign: "center" }}>Cargando problemas...</div>}

      {filtered.map((p) => (
        <div key={p.problemId}>
          {/* TU CARD ORIGINAL AQU√ç */}
          {p.title} - {p.status}
        </div>
      ))}
    </div>
  );
}