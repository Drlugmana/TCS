// src/api/problems.js

// ✅ VITE: aquí NO existe process.env
const BASE_URL = (import.meta.env.VITE_API_BASE_URL || "").replace(/\/$/, "");

function buildUrl(path, params = {}) {
  const url = new URL(`${BASE_URL}${path.startsWith("/") ? "" : "/"}${path}`);
  Object.entries(params).forEach(([k, v]) => {
    if (v === null || v === undefined || v === "") return;
    url.searchParams.set(k, String(v));
  });
  return url.toString();
}

// ISO local SIN "Z" (para que se parezca a tu query de SQL Server)
function toLocalIsoNoZ(d) {
  const pad = (n) => String(n).padStart(2, "0");
  const yyyy = d.getFullYear();
  const mm = pad(d.getMonth() + 1);
  const dd = pad(d.getDate());
  const hh = pad(d.getHours());
  const mi = pad(d.getMinutes());
  const ss = pad(d.getSeconds());
  return `${yyyy}-${mm}-${dd}T${hh}:${mi}:${ss}`;
}

// ✅ Igual que tu SQL:
// StartTime >= CONVERT(DATE, GETDATE()-1)  (ayer 00:00)
// StartTime < GETDATE()                   (ahora)
export function getYesterdayToNowRangeIso() {
  const now = new Date();
  const start = new Date(now);
  start.setDate(start.getDate() - 1);
  start.setHours(0, 0, 0, 0);

  return {
    startIso: toLocalIsoNoZ(start),
    endIso: toLocalIsoNoZ(now),
  };
}

// Lee JSON de forma segura (para no reventar si el backend devuelve texto)
async function safeJson(res) {
  const text = await res.text();
  try {
    return JSON.parse(text);
  } catch {
    return text;
  }
}

/**
 * Trae problemas paginados y los va acumulando.
 * Espera backend tipo:
 *   GET /Problems?pageNumber=1&pageSize=200&start=...&end=...&jurisdiction=TCS
 */
export async function fetchProblemsRange({
  startIso,
  endIso,
  jurisdiction = null,
  pageSize = 200,
  maxPages = 60,
  signal,
  onBatch,
}) {
  if (!BASE_URL) throw new Error("VITE_API_BASE_URL no está configurado.");

  let pageNumber = 1;

  for (let i = 0; i < maxPages; i++) {
    const url = buildUrl("/Problems", {
      pageNumber,
      pageSize,
      start: startIso,
      end: endIso,
      jurisdiction: jurisdiction,
    });

    const res = await fetch(url, { signal });

    if (!res.ok) {
      const body = await safeJson(res);
      throw new Error(`HTTP ${res.status} en /Problems: ${typeof body === "string" ? body : JSON.stringify(body)}`);
    }

    const data = await res.json();

    // Soporta varios formatos: array directo o { items: [...] } o { data: [...] }
    const batch =
      Array.isArray(data) ? data :
      Array.isArray(data?.items) ? data.items :
      Array.isArray(data?.data) ? data.data :
      [];

    if (typeof onBatch === "function") onBatch(batch);

    if (!batch.length) break;
    if (batch.length < pageSize) break;

    pageNumber++;
  }
}

/**
 * Firma para polling (si tu backend la tiene).
 * Si NO existe el endpoint, devuelve null y NO rompe nada.
 */
export async function fetchLatestSignature({ startIso, endIso, jurisdiction = null }) {
  if (!BASE_URL) return null;

  // Intento 1: /Problems/latest-signature
  try {
    const url = buildUrl("/Problems/latest-signature", {
      start: startIso,
      end: endIso,
      jurisdiction,
    });
    const res = await fetch(url);
    if (res.ok) {
      const data = await res.json();
      return data?.signature || data?.sig || data?.value || null;
    }
  } catch {}

  // Intento 2: fallback: lee la primera página y arma una firma simple
  try {
    const url = buildUrl("/Problems", {
      pageNumber: 1,
      pageSize: 1,
      start: startIso,
      end: endIso,
      jurisdiction,
    });
    const res = await fetch(url);
    if (!res.ok) return null;

    const data = await res.json();
    const first =
      Array.isArray(data) ? data[0] :
      Array.isArray(data?.items) ? data.items[0] :
      Array.isArray(data?.data) ? data.data[0] :
      null;

    if (!first) return null;

    const pid = first.problemId || first.pid || first.displayId || "";
    const st = first.startTime || first.StartTime || "";
    const status = first.status || first.Status || "";
    return `${pid}|${st}|${status}`;
  } catch {
    return null;
  }
}

-----


// src/pages/TCSProblems.jsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import ProblemCard from "../components/ProblemCard";
import { fetchProblemsRange, fetchLatestSignature, getYesterdayToNowRangeIso } from "../api/problems";

function Chip({ active, onClick, children, color }) {
  return (
    <button
      onClick={onClick}
      style={{
        border: "1px solid rgba(0,0,0,.12)",
        background: active ? (color || "#e5e7eb") : "#f3f4f6",
        padding: "6px 12px",
        borderRadius: "999px",
        cursor: "pointer",
        fontWeight: 700,
      }}
    >
      {children}
    </button>
  );
}

export default function TCSProblems() {
  const [username, setUsername] = useState("");
  const [loading, setLoading] = useState(false);

  const [base, setBase] = useState([]);

  const [envFilter, setEnvFilter] = useState(null);
  const [statusFilter, setStatusFilter] = useState(null);

  const abortRef = useRef(null);
  const inFlightRef = useRef(false);
  const lastSigRef = useRef(null);

  const load = async () => {
    if (inFlightRef.current) return;
    inFlightRef.current = true;

    if (abortRef.current) abortRef.current.abort();
    const controller = new AbortController();
    abortRef.current = controller;

    setLoading(true);

    try {
      const { startIso, endIso } = getYesterdayToNowRangeIso();

      const allAccum = [];

      await fetchProblemsRange({
        startIso,
        endIso,
        jurisdiction: "TCS",
        pageSize: 200,
        maxPages: 60,
        signal: controller.signal,

        onBatch: (batch) => {
          for (const x of batch) allAccum.push(x);
          setBase([...allAccum]);
        },
      });
    } catch (e) {
      if (String(e?.name || "").toLowerCase() !== "aborterror") {
        console.error(e);
      }
    } finally {
      setLoading(false);
      inFlightRef.current = false;
    }
  };

  useEffect(() => {
    load();

    const poll = async () => {
      try {
        const { startIso, endIso } = getYesterdayToNowRangeIso();
        const sig = await fetchLatestSignature({ startIso, endIso, jurisdiction: "TCS" });

        if (lastSigRef.current === null) {
          lastSigRef.current = sig;
          return;
        }

        if (sig && sig !== lastSigRef.current) {
          lastSigRef.current = sig;
          load();
        }
      } catch (e) {}
    };

    const t = setInterval(poll, 20000);

    return () => {
      clearInterval(t);
      if (abortRef.current) abortRef.current.abort();
    };
  }, []);

  const counts = useMemo(() => {
    const prod = base.filter((x) => x.environment === "Productivo").length;
    const nprod = base.filter((x) => x.environment === "No Productivo").length;
    const open = base.filter((x) => (x.status || "").toUpperCase() === "OPEN").length;
    const closed = base.filter((x) => (x.status || "").toUpperCase() === "CLOSED").length;
    return { total: base.length, prod, nprod, open, closed };
  }, [base]);

  const visible = useMemo(() => {
    let list = base;
    if (envFilter) list = list.filter((x) => x.environment === envFilter);
    if (statusFilter) list = list.filter((x) => (x.status || "").toUpperCase() === statusFilter);
    return list;
  }, [base, envFilter, statusFilter]);

  return (
    <div style={{ maxWidth: 980, margin: "0 auto", padding: "2rem 1rem" }}>
      <h1 style={{ textAlign: "center", marginBottom: ".5rem" }}>
        Problemas TCS ({counts.total})
      </h1>

      <div style={{ display: "flex", justifyContent: "center", gap: "10px", marginBottom: "10px" }}>
        <div style={{ fontWeight: 700 }}>Usuario:</div>
        <input
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          style={{ padding: "4px 8px", border: "1px solid #ccc", borderRadius: 4, width: 180 }}
          placeholder="Tu usuario"
        />
      </div>

      <div style={{ display: "flex", justifyContent: "center", gap: "10px", flexWrap: "wrap", marginBottom: "18px" }}>
        <Chip
          active={envFilter === "Productivo"}
          color="#93c5fd"
          onClick={() => setEnvFilter(envFilter === "Productivo" ? null : "Productivo")}
        >
          Productivo ({counts.prod})
        </Chip>

        <Chip
          active={envFilter === "No Productivo"}
          color="#e5e7eb"
          onClick={() => setEnvFilter(envFilter === "No Productivo" ? null : "No Productivo")}
        >
          No Productivo ({counts.nprod})
        </Chip>

        <Chip
          active={statusFilter === "OPEN"}
          color="#fde68a"
          onClick={() => setStatusFilter(statusFilter === "OPEN" ? null : "OPEN")}
        >
          Abiertas ({counts.open})
        </Chip>

        <Chip
          active={statusFilter === "CLOSED"}
          color="#86efac"
          onClick={() => setStatusFilter(statusFilter === "CLOSED" ? null : "CLOSED")}
        >
          Cerradas ({counts.closed})
        </Chip>

        <Chip
          active={!envFilter && !statusFilter}
          onClick={() => {
            setEnvFilter(null);
            setStatusFilter(null);
          }}
        >
          Todos
        </Chip>
      </div>

      {loading && (
        <div style={{ textAlign: "center", marginBottom: "10px", fontWeight: 700 }}>
          Cargando problemas...
        </div>
      )}

      {visible.map((p) => (
        <ProblemCard key={`${p.problemId || p.displayId}-${p.startTime || p.StartTime}`} problem={p} username={username} />
      ))}
    </div>
  );
}

-----

// src/pages/Otherproblems.jsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import ProblemCard from "../components/ProblemCard";
import { fetchProblemsRange, fetchLatestSignature, getYesterdayToNowRangeIso } from "../api/problems";

function Chip({ active, onClick, children, color }) {
  return (
    <button
      onClick={onClick}
      style={{
        border: "1px solid rgba(0,0,0,.12)",
        background: active ? (color || "#e5e7eb") : "#f3f4f6",
        padding: "6px 12px",
        borderRadius: "999px",
        cursor: "pointer",
        fontWeight: 700,
      }}
    >
      {children}
    </button>
  );
}

export default function Otherproblems() {
  const [username, setUsername] = useState("");
  const [loading, setLoading] = useState(false);

  const [base, setBase] = useState([]);

  const [envFilter, setEnvFilter] = useState(null);
  const [statusFilter, setStatusFilter] = useState(null);

  const abortRef = useRef(null);
  const inFlightRef = useRef(false);
  const lastSigRef = useRef(null);

  const load = async () => {
    if (inFlightRef.current) return;
    inFlightRef.current = true;

    if (abortRef.current) abortRef.current.abort();
    const controller = new AbortController();
    abortRef.current = controller;

    setLoading(true);

    try {
      const { startIso, endIso } = getYesterdayToNowRangeIso();

      const allAccum = [];

      await fetchProblemsRange({
        startIso,
        endIso,
        jurisdiction: "OTROS",
        pageSize: 200,
        maxPages: 60,
        signal: controller.signal,

        onBatch: (batch) => {
          for (const x of batch) allAccum.push(x);
          setBase([...allAccum]);
        },
      });
    } catch (e) {
      if (String(e?.name || "").toLowerCase() !== "aborterror") {
        console.error(e);
      }
    } finally {
      setLoading(false);
      inFlightRef.current = false;
    }
  };

  useEffect(() => {
    load();

    const poll = async () => {
      try {
        const { startIso, endIso } = getYesterdayToNowRangeIso();
        const sig = await fetchLatestSignature({ startIso, endIso, jurisdiction: "OTROS" });

        if (lastSigRef.current === null) {
          lastSigRef.current = sig;
          return;
        }

        if (sig && sig !== lastSigRef.current) {
          lastSigRef.current = sig;
          load();
        }
      } catch (e) {}
    };

    const t = setInterval(poll, 20000);

    return () => {
      clearInterval(t);
      if (abortRef.current) abortRef.current.abort();
    };
  }, []);

  const counts = useMemo(() => {
    const prod = base.filter((x) => x.environment === "Productivo").length;
    const nprod = base.filter((x) => x.environment === "No Productivo").length;
    const open = base.filter((x) => (x.status || "").toUpperCase() === "OPEN").length;
    const closed = base.filter((x) => (x.status || "").toUpperCase() === "CLOSED").length;
    return { total: base.length, prod, nprod, open, closed };
  }, [base]);

  const visible = useMemo(() => {
    let list = base;
    if (envFilter) list = list.filter((x) => x.environment === envFilter);
    if (statusFilter) list = list.filter((x) => (x.status || "").toUpperCase() === statusFilter);
    return list;
  }, [base, envFilter, statusFilter]);

  return (
    <div style={{ maxWidth: 980, margin: "0 auto", padding: "2rem 1rem" }}>
      <h1 style={{ textAlign: "center", marginBottom: ".5rem" }}>
        Problemas Otros ({counts.total})
      </h1>

      <div style={{ display: "flex", justifyContent: "center", gap: "10px", marginBottom: "10px" }}>
        <div style={{ fontWeight: 700 }}>Usuario:</div>
        <input
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          style={{ padding: "4px 8px", border: "1px solid #ccc", borderRadius: 4, width: 180 }}
          placeholder="Tu usuario"
        />
      </div>

      <div style={{ display: "flex", justifyContent: "center", gap: "10px", flexWrap: "wrap", marginBottom: "18px" }}>
        <Chip
          active={envFilter === "Productivo"}
          color="#93c5fd"
          onClick={() => setEnvFilter(envFilter === "Productivo" ? null : "Productivo")}
        >
          Productivo ({counts.prod})
        </Chip>

        <Chip
          active={envFilter === "No Productivo"}
          color="#e5e7eb"
          onClick={() => setEnvFilter(envFilter === "No Productivo" ? null : "No Productivo")}
        >
          No Productivo ({counts.nprod})
        </Chip>

        <Chip
          active={statusFilter === "OPEN"}
          color="#fde68a"
          onClick={() => setStatusFilter(statusFilter === "OPEN" ? null : "OPEN")}
        >
          Abiertas ({counts.open})
        </Chip>

        <Chip
          active={statusFilter === "CLOSED"}
          color="#86efac"
          onClick={() => setStatusFilter(statusFilter === "CLOSED" ? null : "CLOSED")}
        >
          Cerradas ({counts.closed})
        </Chip>

        <Chip
          active={!envFilter && !statusFilter}
          onClick={() => {
            setEnvFilter(null);
            setStatusFilter(null);
          }}
        >
          Todos
        </Chip>
      </div>

      {loading && (
        <div style={{ textAlign: "center", marginBottom: "10px", fontWeight: 700 }}>
          Cargando problemas...
        </div>
      )}

      {visible.map((p) => (
        <ProblemCard key={`${p.problemId || p.displayId}-${p.startTime || p.StartTime}`} problem={p} username={username} />
      ))}
    </div>
  );
}

------


// src/components/ProblemCard.jsx
import React, { useEffect, useMemo, useState } from "react";
import { useBiaCatalog } from "../context/BiaCatalogContext";
import {
  getSlaMinutes,
  getColorByPercent,
  calcularCriticidadDetallada,
  getButtonColorByPercent,
} from "../utils/slaUtils";

// Normaliza estado OPEN/CLOSED (sin inventar OPEN si viene CLOSED)
function normalizeStatus(p) {
  const raw = p?.status ?? p?.Status ?? p?.problemStatus ?? p?.problemState ?? "";
  const s = String(raw || "").trim().toUpperCase();

  if (s.includes("OPEN")) return "OPEN";
  if (s.includes("CLOSED") || s.includes("RESOLVED")) return "CLOSED";

  // fallback solo si no vino status
  return p?.endTime ? "CLOSED" : "OPEN";
}

// Iconos por tower
function towerToIconPath(towerKey) {
  if (!towerKey) return null;
  const key = String(towerKey).toLowerCase();

  if (key.includes("wintel") || key.includes("windows")) return "/icons/towers/wiltel1.svg";
  if (key.includes("bdd") || key.includes("base de datos") || key.includes("database") || key.includes("bd"))
    return "/icons/towers/Base.svg";
  if (key.includes("unix") || key.includes("aix") || key.includes("linux")) return "/icons/towers/unix.svg";

  return null;
}

export default function ProblemCard({ problem, username }) {
  const { get: catalogGet } = useBiaCatalog();

  const status = useMemo(() => normalizeStatus(problem), [problem]);
  const start = useMemo(() => (problem?.startTime ? new Date(problem.startTime) : new Date()), [problem]);

  // Buscar coincidencia con catálogo
  const hitFromCatalog = useMemo(() => {
    const arr = Array.isArray(problem?.affectedCI) ? problem.affectedCI : [];
    for (const ci of arr) {
      const name = ci?.name || ci?.Nombre;
      const hit = name ? catalogGet(name) : null;
      if (hit) return hit;
    }
    return null;
  }, [problem, catalogGet]);

  const towerIcon = towerToIconPath(hitFromCatalog?.tower);

  const { criticidad } = calcularCriticidadDetallada(problem, {
    catalogLookup: (ciName) => catalogGet(ciName),
  });

  // SLA
  const slaMinutes = getSlaMinutes(criticidad);

  // Timer: SOLO si está OPEN
  const [now, setNow] = useState(new Date());

  useEffect(() => {
    if (status === "CLOSED") return; // NO corre en CLOSED
    const interval = setInterval(() => setNow(new Date()), 1000);
    return () => clearInterval(interval);
  }, [status]);

  const elapsedMinutes = useMemo(() => (status === "CLOSED" ? 0 : (now - start) / 60000), [now, start, status]);
  const remainingMinutes = useMemo(() => (status === "CLOSED" ? 0 : Math.max(slaMinutes - elapsedMinutes, 0)), [
    slaMinutes,
    elapsedMinutes,
    status,
  ]);

  const percentRemaining = useMemo(() => {
    if (status === "CLOSED") return 100;
    return Math.max((remainingMinutes / slaMinutes) * 100, 0);
  }, [remainingMinutes, slaMinutes, status]);

  const bgColor = getColorByPercent(percentRemaining);
  const buttonColor = getButtonColorByPercent(percentRemaining);

  const formatTime = (minutes) => {
    const totalSeconds = Math.floor(minutes * 60);
    const hrs = Math.floor(totalSeconds / 3600);
    const mins = Math.floor((totalSeconds % 3600) / 60);
    const secs = totalSeconds % 60;
    return `${String(hrs).padStart(2, "0")}:${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
  };

  const affected = Array.isArray(problem?.affectedCI) ? problem.affectedCI : [];
  const uniqueNames = [...new Set(affected.map((ci) => ci?.name).filter(Boolean))];
  const equipos = uniqueNames.join(", ");

  const isDisabled = !username;
  const tenant = problem?.tenant || "";

  // ✅ Dynatrace normalmente usa pid=problemId (si tu backend lo trae).
  // Fallback: displayId (P-xxxx) si no viene problemId.
  const pid = problem?.problemId || problem?.pid || problem?.displayId || "";

  const dynatraceUrl =
    tenant && pid ? `https://${tenant}.live.dynatrace.com/#problems/problemdetails;pid=${pid}` : "#";

  const environment = problem?.environment || "";

  return (
    <div
      style={{
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        borderRadius: "12px",
        padding: "1rem 1.5rem",
        marginBottom: "1rem",
        backgroundColor: bgColor,
        boxShadow: "0 4px 10px rgba(0,0,0,.1)",
      }}
    >
      {/* IZQUIERDA: INFO */}
      <div style={{ flex: 1, paddingRight: "1rem" }}>
        <h3 style={{ margin: 0, fontSize: "1.6rem", fontWeight: "bold" }}>{problem?.title || "(sin título)"}</h3>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Severidad Dynatrace:</strong> {problem?.severityLevel}
        </p>
        <p style={{ fontSize: "1.2rem" }}>
          <strong>Impacto:</strong> {problem?.impactLevel}
        </p>
        <p style={{ fontSize: "1.2rem" }}>
          <strong>Inicio:</strong> {start.toLocaleString()}
        </p>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Estado:</strong> {status}
        </p>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Criticidad (BIA):</strong> {criticidad}
        </p>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Equipos afectados:</strong> <small>{equipos}</small>
        </p>
      </div>

      {/* CENTRO: ICONOS */}
      <div
        style={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          gap: "1rem",
          flexShrink: 0,
          minWidth: "220px",
        }}
      >
        {(() => {
          const size = 110;
          return (
            <>
              <img
                src={`/severidad${criticidad}.svg`}
                width={size}
                height={size}
                title={`Criticidad ${criticidad}`}
                alt={`Criticidad ${criticidad}`}
              />
              <img
                src={environment === "Productivo" ? "/icon-productivo.svg" : "/icon-noproductivo.svg"}
                width={size}
                height={size}
                title={environment}
                alt={environment}
              />
              {towerIcon && (
                <img
                  src={towerIcon}
                  alt="tower"
                  width={size}
                  height={size}
                  title={hitFromCatalog?.towerRaw || hitFromCatalog?.tower}
                />
              )}
            </>
          );
        })()}
      </div>

      {/* DERECHA: TIMER + BOTÓN */}
      <div style={{ textAlign: "center", minWidth: "160px" }}>
        <div style={{ fontSize: "2rem", fontWeight: "bold" }}>{formatTime(remainingMinutes)}</div>

        <button
          disabled={isDisabled || dynatraceUrl === "#"}
          onClick={() => window.open(dynatraceUrl, "_blank")}
          style={{
            marginTop: ".5rem",
            padding: ".4rem 1rem",
            fontSize: ".9rem",
            fontWeight: "bold",
            color: "#fff",
            backgroundColor: isDisabled ? "#b0b0b0" : status === "CLOSED" ? "#6b7280" : buttonColor,
            border: "none",
            borderRadius: "8px",
            cursor: isDisabled ? "not-allowed" : "pointer",
          }}
        >
          Revisar problema
        </button>
      </div>
    </div>
  );
}