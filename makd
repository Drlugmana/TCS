import React, { useEffect, useMemo, useRef, useState } from "react";
// Si tú ya usas tus componentes, déjalos igual:
import ProblemCard from "../components/ProblemCard"; // ajusta si tu ruta es distinta

// Si tú ya tienes esto en otro lado, respétalo. Aquí lo dejo simple:
const API_BASE =
  (typeof import.meta !== "undefined" && import.meta.env && import.meta.env.VITE_API_BASE_URL) ||
  (typeof process !== "undefined" && process.env && process.env.REACT_APP_API_BASE_URL) ||
  "https://localhost:44334/api";

const PAGE_SIZE = 1000;
const REFRESH_MS = 60_000; // 1 minuto (puedes cambiar a 30_000, 120_000, etc.)

function getYesterdayStartISO() {
  const now = new Date();
  const start = new Date(now);
  start.setDate(now.getDate() - 1);
  start.setHours(0, 0, 0, 0);
  return start.toISOString(); // UTC ISO
}

export default function Tcs() {
  const [username, setUsername] = useState("");
  const [activeFilter, setActiveFilter] = useState("Todos"); // Productivo | No Productivo | Abiertas | Cerradas | Todos
  const [loading, setLoading] = useState(true);
  const [problems, setProblems] = useState([]);

  const abortRef = useRef(null);
  const loadSeqRef = useRef(0);

  const startISO = useMemo(() => getYesterdayStartISO(), []); // se calcula al cargar la página
  // Si quieres que al pasar medianoche cambie sin recargar, me dices y lo hacemos.

  async function fetchAllPages({ start, signal }) {
    let pageNumber = 1;
    let all = [];

    while (true) {
      const url = `${API_BASE}/Problems?pageNumber=${pageNumber}&pageSize=${PAGE_SIZE}&start=${encodeURIComponent(
        start
      )}`;

      const res = await fetch(url, { signal });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Error ${res.status} al consultar Problems. ${txt}`);
      }

      const data = await res.json();

      // Asumimos que la API devuelve un array
      const items = Array.isArray(data) ? data : (data?.items || []);
      all = all.concat(items);

      // fin de paginación
      if (!items || items.length < PAGE_SIZE) break;

      pageNumber += 1;
      // protección para evitar bucles raros
      if (pageNumber > 5000) break;
    }

    return all;
  }

  async function loadProblems() {
    const seq = ++loadSeqRef.current;

    // cancelar carga anterior si existe
    if (abortRef.current) abortRef.current.abort();
    abortRef.current = new AbortController();

    setLoading(true);

    try {
      const all = await fetchAllPages({
        start: startISO,
        signal: abortRef.current.signal,
      });

      // Evita que una respuesta vieja pise la nueva
      if (seq !== loadSeqRef.current) return;

      // FILTRO PRINCIPAL: SOLO TCS
      const tcs = all.filter((p) => String(p?.jurisdiction || "").toUpperCase() === "TCS");

      // Orden (opcional) por StartTime desc si existe
      tcs.sort((a, b) => {
        const da = new Date(a?.startTime || a?.StartTime || 0).getTime();
        const db = new Date(b?.startTime || b?.StartTime || 0).getTime();
        return db - da;
      });

      setProblems(tcs);
    } catch (err) {
      // Abort no es error real
      if (String(err?.name) !== "AbortError") {
        console.error("Error cargando problemas TCS:", err);
      }
      // no seteamos problems a [] para no “parpadear” si solo fue abort
    } finally {
      if (seq === loadSeqRef.current) setLoading(false);
    }
  }

  useEffect(() => {
    loadProblems();

    const id = setInterval(() => {
      loadProblems();
    }, REFRESH_MS);

    return () => {
      clearInterval(id);
      if (abortRef.current) abortRef.current.abort();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Contadores
  const counts = useMemo(() => {
    const total = problems.length;

    const abiertos = problems.filter((p) => String(p?.status || "").toUpperCase() === "OPEN").length;
    const cerrados = problems.filter((p) => String(p?.status || "").toUpperCase() === "CLOSED").length;

    const productivo = problems.filter((p) => String(p?.environment || "").toLowerCase() === "productivo").length;
    const noProductivo = problems.filter(
      (p) => String(p?.environment || "").toLowerCase() === "noproductivo"
    ).length;

    return { total, abiertos, cerrados, productivo, noProductivo };
  }, [problems]);

  // Lista filtrada por botón
  const filtered = useMemo(() => {
    if (activeFilter === "Productivo")
      return problems.filter((p) => String(p?.environment || "").toLowerCase() === "productivo");

    if (activeFilter === "No Productivo")
      return problems.filter((p) => String(p?.environment || "").toLowerCase() === "noproductivo");

    if (activeFilter === "Abiertas")
      return problems.filter((p) => String(p?.status || "").toUpperCase() === "OPEN");

    if (activeFilter === "Cerradas")
      return problems.filter((p) => String(p?.status || "").toUpperCase() === "CLOSED");

    return problems;
  }, [activeFilter, problems]);

  return (
    <div style={{ padding: "20px" }}>
      {/* Barra superior (si ya tienes navbar, déjalo como tú lo tienes) */}
      <div style={{ display: "flex", gap: "12px", marginBottom: "20px" }}>
        <a href="/tcs" style={{ fontWeight: "bold", textDecoration: "none" }}>TCS</a>
        <a href="/otros" style={{ textDecoration: "none" }}>Otros</a>
      </div>

      <h1 style={{ textAlign: "center" }}>Problemas TCS ({counts.total})</h1>

      <div style={{ textAlign: "center", marginBottom: "10px" }}>
        <span style={{ marginRight: "8px" }}>Usuario:</span>
        <input
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          placeholder="Tu usuario"
          style={{ padding: "6px 10px" }}
        />
      </div>

      {/* Botones / chips */}
      <div style={{ display: "flex", justifyContent: "center", gap: "10px", flexWrap: "wrap" }}>
        <button onClick={() => setActiveFilter("Productivo")}>Productivo ({counts.productivo})</button>
        <button onClick={() => setActiveFilter("No Productivo")}>No Productivo ({counts.noProductivo})</button>
        <button onClick={() => setActiveFilter("Abiertas")}>Abiertas ({counts.abiertos})</button>
        <button onClick={() => setActiveFilter("Cerradas")}>Cerradas ({counts.cerrados})</button>
        <button onClick={() => setActiveFilter("Todos")}>Todos</button>
      </div>

      <div style={{ textAlign: "center", marginTop: "10px", marginBottom: "10px" }}>
        {loading ? "Cargando problemas..." : ""}
      </div>

      {/* Tarjetas */}
      <div style={{ maxWidth: "980px", margin: "0 auto" }}>
        {!loading && filtered.length === 0 ? (
          <div style={{ textAlign: "center" }}>No hay problemas para mostrar.</div>
        ) : (
          filtered.map((p, idx) => (
            <ProblemCard
              key={p?.problemId || p?.ProblemId || idx}
              problem={p}
              username={username}
            />
          ))
        )}
      </div>
    </div>
  );
}

----

import React, { useEffect, useMemo, useRef, useState } from "react";
import ProblemCard from "../components/ProblemCard"; // ajusta si tu ruta es distinta

const API_BASE =
  (typeof import.meta !== "undefined" && import.meta.env && import.meta.env.VITE_API_BASE_URL) ||
  (typeof process !== "undefined" && process.env && process.env.REACT_APP_API_BASE_URL) ||
  "https://localhost:44334/api";

const PAGE_SIZE = 1000;
const REFRESH_MS = 60_000; // 1 minuto

function getYesterdayStartISO() {
  const now = new Date();
  const start = new Date(now);
  start.setDate(now.getDate() - 1);
  start.setHours(0, 0, 0, 0);
  return start.toISOString();
}

export default function Otros() {
  const [username, setUsername] = useState("");
  const [activeFilter, setActiveFilter] = useState("Todos");
  const [loading, setLoading] = useState(true);
  const [problems, setProblems] = useState([]);

  const abortRef = useRef(null);
  const loadSeqRef = useRef(0);

  const startISO = useMemo(() => getYesterdayStartISO(), []);

  async function fetchAllPages({ start, signal }) {
    let pageNumber = 1;
    let all = [];

    while (true) {
      const url = `${API_BASE}/Problems?pageNumber=${pageNumber}&pageSize=${PAGE_SIZE}&start=${encodeURIComponent(
        start
      )}`;

      const res = await fetch(url, { signal });
      if (!res.ok) {
        const txt = await res.text().catch(() => "");
        throw new Error(`Error ${res.status} al consultar Problems. ${txt}`);
      }

      const data = await res.json();
      const items = Array.isArray(data) ? data : (data?.items || []);
      all = all.concat(items);

      if (!items || items.length < PAGE_SIZE) break;

      pageNumber += 1;
      if (pageNumber > 5000) break;
    }

    return all;
  }

  async function loadProblems() {
    const seq = ++loadSeqRef.current;

    if (abortRef.current) abortRef.current.abort();
    abortRef.current = new AbortController();

    setLoading(true);

    try {
      const all = await fetchAllPages({
        start: startISO,
        signal: abortRef.current.signal,
      });

      if (seq !== loadSeqRef.current) return;

      // FILTRO PRINCIPAL: SOLO NO TCS
      const otros = all.filter((p) => String(p?.jurisdiction || "").toUpperCase() === "NO TCS");

      otros.sort((a, b) => {
        const da = new Date(a?.startTime || a?.StartTime || 0).getTime();
        const db = new Date(b?.startTime || b?.StartTime || 0).getTime();
        return db - da;
      });

      setProblems(otros);
    } catch (err) {
      if (String(err?.name) !== "AbortError") {
        console.error("Error cargando problemas OTROS:", err);
      }
    } finally {
      if (seq === loadSeqRef.current) setLoading(false);
    }
  }

  useEffect(() => {
    loadProblems();

    const id = setInterval(() => {
      loadProblems();
    }, REFRESH_MS);

    return () => {
      clearInterval(id);
      if (abortRef.current) abortRef.current.abort();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const counts = useMemo(() => {
    const total = problems.length;

    const abiertos = problems.filter((p) => String(p?.status || "").toUpperCase() === "OPEN").length;
    const cerrados = problems.filter((p) => String(p?.status || "").toUpperCase() === "CLOSED").length;

    const productivo = problems.filter((p) => String(p?.environment || "").toLowerCase() === "productivo").length;
    const noProductivo = problems.filter(
      (p) => String(p?.environment || "").toLowerCase() === "noproductivo"
    ).length;

    return { total, abiertos, cerrados, productivo, noProductivo };
  }, [problems]);

  const filtered = useMemo(() => {
    if (activeFilter === "Productivo")
      return problems.filter((p) => String(p?.environment || "").toLowerCase() === "productivo");

    if (activeFilter === "No Productivo")
      return problems.filter((p) => String(p?.environment || "").toLowerCase() === "noproductivo");

    if (activeFilter === "Abiertas")
      return problems.filter((p) => String(p?.status || "").toUpperCase() === "OPEN");

    if (activeFilter === "Cerradas")
      return problems.filter((p) => String(p?.status || "").toUpperCase() === "CLOSED");

    return problems;
  }, [activeFilter, problems]);

  return (
    <div style={{ padding: "20px" }}>
      <div style={{ display: "flex", gap: "12px", marginBottom: "20px" }}>
        <a href="/tcs" style={{ textDecoration: "none" }}>TCS</a>
        <a href="/otros" style={{ fontWeight: "bold", textDecoration: "none" }}>Otros</a>
      </div>

      <h1 style={{ textAlign: "center" }}>Problemas Otros ({counts.total})</h1>

      <div style={{ textAlign: "center", marginBottom: "10px" }}>
        <span style={{ marginRight: "8px" }}>Usuario:</span>
        <input
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          placeholder="Tu usuario"
          style={{ padding: "6px 10px" }}
        />
      </div>

      <div style={{ display: "flex", justifyContent: "center", gap: "10px", flexWrap: "wrap" }}>
        <button onClick={() => setActiveFilter("Productivo")}>Productivo ({counts.productivo})</button>
        <button onClick={() => setActiveFilter("No Productivo")}>No Productivo ({counts.noProductivo})</button>
        <button onClick={() => setActiveFilter("Abiertas")}>Abiertas ({counts.abiertos})</button>
        <button onClick={() => setActiveFilter("Cerradas")}>Cerradas ({counts.cerrados})</button>
        <button onClick={() => setActiveFilter("Todos")}>Todos</button>
      </div>

      <div style={{ textAlign: "center", marginTop: "10px", marginBottom: "10px" }}>
        {loading ? "Cargando problemas..." : ""}
      </div>

      <div style={{ maxWidth: "980px", margin: "0 auto" }}>
        {!loading && filtered.length === 0 ? (
          <div style={{ textAlign: "center" }}>No hay problemas para mostrar.</div>
        ) : (
          filtered.map((p, idx) => (
            <ProblemCard
              key={p?.problemId || p?.ProblemId || idx}
              problem={p}
              username={username}
            />
          ))
        )}
      </div>
    </div>
  );
}