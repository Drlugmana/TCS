// src/api/problems.js

// ✅ Vite: se usa import.meta.env (NO process.env)
const API_BASE_URL =
  (import.meta?.env && import.meta.env.VITE_API_BASE_URL) ||
  "https://localhost:44334"; // fallback por si no hay .env

function joinUrl(base, path) {
  const b = String(base || "").replace(/\/+$/, "");
  const p = String(path || "").replace(/^\/+/, "");
  return `${b}/${p}`;
}

function toIso(d) {
  try {
    return new Date(d).toISOString();
  } catch {
    return "";
  }
}

// Rango: desde ayer 00:00 hasta ahora (como tu query SQL)
export function getYesterdayToNowRangeIso() {
  const now = new Date();
  const start = new Date(now);
  start.setDate(start.getDate() - 1);
  start.setHours(0, 0, 0, 0);

  return {
    startIso: toIso(start),
    endIso: toIso(now),
  };
}

// Normaliza respuesta del API (por si a veces viene {data: []} o directo [])
function normalizeListResponse(json) {
  if (Array.isArray(json)) return json;
  if (Array.isArray(json?.data)) return json.data;
  if (Array.isArray(json?.items)) return json.items;
  if (Array.isArray(json?.results)) return json.results;
  return [];
}

// Mapea filas de backend/SQL a la forma que usa tu UI (ProblemCard)
function mapProblemRow(row) {
  const r = row || {};

  // soporta nombres que has mostrado en SQL: DisplayId, Title, ImpactLevel, SeverityLevel, Status, StartTime, Environment, Tenant
  const problemId = r.problemId || r.ProblemId || r.displayId || r.DisplayId || r.pid || r.Pid || "";
  const title = r.title || r.Title || "(sin título)";
  const impactLevel = r.impactLevel || r.ImpactLevel || r.impact || r.Impact || "";
  const severityLevel = r.severityLevel || r.SeverityLevel || r.severity || r.Severity || "";
  const status = r.status || r.Status || "";
  const startTime = r.startTime || r.StartTime || r.start || r.Start || null;
  const endTime = r.endTime || r.EndTime || r.end || r.End || null;
  const environment = r.environment || r.Environment || "";
  const tenant = r.tenant || r.Tenant || "";

  // Jurisdicción
  const jurisdiction = r.jurisdiction || r.Jurisdiction || r.Jurisdiccion || r.Jurisdicción || "";

  // Affected CI si existe en tu JSON (si no, queda vacío)
  const affectedCI = Array.isArray(r.affectedCI)
    ? r.affectedCI
    : Array.isArray(r.AffectedCI)
    ? r.AffectedCI
    : [];

  return {
    ...r,
    problemId,
    displayId: problemId,
    title,
    impactLevel,
    severityLevel,
    status,
    startTime,
    endTime,
    environment,
    tenant,
    jurisdiction,
    affectedCI,
  };
}

// GET lista paginada: /Problems?pageNumber=1&pageSize=200&startTime=...&endTime=...&jurisdiction=TCS
async function fetchProblemsPage({ startIso, endIso, jurisdiction, pageNumber, pageSize, signal }) {
  const url = new URL(joinUrl(API_BASE_URL, "Problems"));
  url.searchParams.set("pageNumber", String(pageNumber));
  url.searchParams.set("pageSize", String(pageSize));

  if (startIso) url.searchParams.set("startTime", startIso);
  if (endIso) url.searchParams.set("endTime", endIso);
  if (jurisdiction) url.searchParams.set("jurisdiction", jurisdiction);

  const res = await fetch(url.toString(), { signal });

  if (!res.ok) {
    const text = await res.text().catch(() => "");
    throw new Error(`Problems fetch failed: ${res.status} ${res.statusText} ${text}`);
  }

  const json = await res.json();
  const list = normalizeListResponse(json).map(mapProblemRow);
  return list;
}

// ✅ Paginación completa (trae “todas” dentro del rango)
export async function fetchProblemsRange({
  startIso,
  endIso,
  jurisdiction = null,
  pageSize = 200,
  maxPages = 60,
  signal,
  onBatch,
}) {
  let pageNumber = 1;
  let total = 0;

  for (let i = 0; i < maxPages; i++) {
    const batch = await fetchProblemsPage({
      startIso,
      endIso,
      jurisdiction,
      pageNumber,
      pageSize,
      signal,
    });

    if (!batch.length) break;

    total += batch.length;
    if (typeof onBatch === "function") onBatch(batch);

    // si vino menos que pageSize, ya no hay más
    if (batch.length < pageSize) break;

    pageNumber++;
  }

  return total;
}

// ✅ Firma “latest”: primero intenta latestSignature, si no existe intenta latest, si no existe => usa la primera fila del listado
export async function fetchLatestSignature({ startIso, endIso, jurisdiction = null, signal }) {
  // 1) /Problems/latestSignature
  {
    const url = new URL(joinUrl(API_BASE_URL, "Problems/latestSignature"));
    if (startIso) url.searchParams.set("startTime", startIso);
    if (endIso) url.searchParams.set("endTime", endIso);
    if (jurisdiction) url.searchParams.set("jurisdiction", jurisdiction);

    const res = await fetch(url.toString(), { signal }).catch(() => null);
    if (res && res.ok) {
      const json = await res.json().catch(() => null);
      if (typeof json === "string") return json;
      if (typeof json?.signature === "string") return json.signature;
      if (typeof json?.latestSignature === "string") return json.latestSignature;
    }
    // si 404, seguimos al fallback
  }

  // 2) /Problems/latest
  {
    const url = new URL(joinUrl(API_BASE_URL, "Problems/latest"));
    if (startIso) url.searchParams.set("startTime", startIso);
    if (endIso) url.searchParams.set("endTime", endIso);
    if (jurisdiction) url.searchParams.set("jurisdiction", jurisdiction);

    const res = await fetch(url.toString(), { signal }).catch(() => null);
    if (res && res.ok) {
      const json = await res.json().catch(() => null);
      // puede venir objeto o string
      if (typeof json === "string") return json;
      if (json?.problemId) return String(json.problemId);
      if (json?.displayId) return String(json.displayId);
      if (json?.StartTime || json?.startTime) return `${json?.displayId || json?.problemId || "latest"}-${json?.StartTime || json?.startTime}`;
    }
  }

  // 3) fallback final: trae 1 página y arma firma con primer registro
  try {
    const firstPage = await fetchProblemsPage({
      startIso,
      endIso,
      jurisdiction,
      pageNumber: 1,
      pageSize: 1,
      signal,
    });
    if (firstPage.length) {
      const p = firstPage[0];
      return `${p.problemId || ""}-${p.startTime || ""}-${p.status || ""}`;
    }
  } catch {}

  return null;
}

------


// src/pages/TCSProblems.jsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import ProblemCard from "../components/ProblemCard";
import { fetchProblemsRange, fetchLatestSignature, getYesterdayToNowRangeIso } from "../api/problems";

function Chip({ active, onClick, children, color }) {
  return (
    <button
      onClick={onClick}
      style={{
        border: "1px solid rgba(0,0,0,.12)",
        background: active ? (color || "#e5e7eb") : "#f3f4f6",
        padding: "6px 12px",
        borderRadius: "999px",
        cursor: "pointer",
        fontWeight: 700,
      }}
    >
      {children}
    </button>
  );
}

export default function TCSProblems() {
  const [username, setUsername] = useState("");
  const [loading, setLoading] = useState(false);
  const [base, setBase] = useState([]);

  const [envFilter, setEnvFilter] = useState(null);
  const [statusFilter, setStatusFilter] = useState(null);

  const abortRef = useRef(null);
  const inFlightRef = useRef(false);
  const lastSigRef = useRef(null);

  const load = async () => {
    if (inFlightRef.current) return;
    inFlightRef.current = true;

    if (abortRef.current) abortRef.current.abort();
    const controller = new AbortController();
    abortRef.current = controller;

    setLoading(true);

    try {
      const { startIso, endIso } = getYesterdayToNowRangeIso();
      const allAccum = [];

      await fetchProblemsRange({
        startIso,
        endIso,
        jurisdiction: "TCS",
        pageSize: 200,
        maxPages: 60,
        signal: controller.signal,
        onBatch: (batch) => {
          for (const x of batch) allAccum.push(x);
          setBase([...allAccum]);
        },
      });
    } catch (e) {
      if (String(e?.name || "").toLowerCase() !== "aborterror") console.error(e);
    } finally {
      setLoading(false);
      inFlightRef.current = false;
    }
  };

  useEffect(() => {
    load();

    const poll = async () => {
      try {
        const { startIso, endIso } = getYesterdayToNowRangeIso();
        const sig = await fetchLatestSignature({ startIso, endIso, jurisdiction: "TCS" });

        if (lastSigRef.current === null) {
          lastSigRef.current = sig;
          return;
        }

        if (sig && sig !== lastSigRef.current) {
          lastSigRef.current = sig;
          load();
        }
      } catch {}
    };

    const t = setInterval(poll, 20000);

    return () => {
      clearInterval(t);
      if (abortRef.current) abortRef.current.abort();
    };
  }, []);

  const counts = useMemo(() => {
    const prod = base.filter((x) => x.environment === "Productivo").length;
    const nprod = base.filter((x) => x.environment === "No Productivo").length;
    const open = base.filter((x) => (x.status || "").toUpperCase() === "OPEN").length;
    const closed = base.filter((x) => (x.status || "").toUpperCase() === "CLOSED").length;
    return { total: base.length, prod, nprod, open, closed };
  }, [base]);

  const visible = useMemo(() => {
    let list = base;
    if (envFilter) list = list.filter((x) => x.environment === envFilter);
    if (statusFilter) list = list.filter((x) => (x.status || "").toUpperCase() === statusFilter);
    return list;
  }, [base, envFilter, statusFilter]);

  return (
    <div style={{ maxWidth: 980, margin: "0 auto", padding: "2rem 1rem" }}>
      <h1 style={{ textAlign: "center", marginBottom: ".5rem" }}>
        Problemas TCS ({counts.total})
      </h1>

      <div style={{ display: "flex", justifyContent: "center", gap: "10px", marginBottom: "10px" }}>
        <div style={{ fontWeight: 700 }}>Usuario:</div>
        <input
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          style={{ padding: "4px 8px", border: "1px solid #ccc", borderRadius: 4, width: 180 }}
          placeholder="Tu usuario"
        />
      </div>

      <div style={{ display: "flex", justifyContent: "center", gap: "10px", flexWrap: "wrap", marginBottom: "18px" }}>
        <Chip
          active={envFilter === "Productivo"}
          color="#93c5fd"
          onClick={() => setEnvFilter(envFilter === "Productivo" ? null : "Productivo")}
        >
          Productivo ({counts.prod})
        </Chip>

        <Chip
          active={envFilter === "No Productivo"}
          color="#e5e7eb"
          onClick={() => setEnvFilter(envFilter === "No Productivo" ? null : "No Productivo")}
        >
          No Productivo ({counts.nprod})
        </Chip>

        <Chip
          active={statusFilter === "OPEN"}
          color="#fde68a"
          onClick={() => setStatusFilter(statusFilter === "OPEN" ? null : "OPEN")}
        >
          Abiertas ({counts.open})
        </Chip>

        <Chip
          active={statusFilter === "CLOSED"}
          color="#86efac"
          onClick={() => setStatusFilter(statusFilter === "CLOSED" ? null : "CLOSED")}
        >
          Cerradas ({counts.closed})
        </Chip>

        <Chip
          active={!envFilter && !statusFilter}
          onClick={() => {
            setEnvFilter(null);
            setStatusFilter(null);
          }}
        >
          Todos
        </Chip>
      </div>

      {loading && (
        <div style={{ textAlign: "center", marginBottom: "10px", fontWeight: 700 }}>
          Cargando problemas...
        </div>
      )}

      {visible.map((p) => (
        <ProblemCard key={`${p.problemId}-${p.startTime}`} problem={p} username={username} />
      ))}
    </div>
  );
}

-----


// src/pages/OtherProblems.jsx
import React, { useEffect, useMemo, useRef, useState } from "react";
import ProblemCard from "../components/ProblemCard";
import { fetchProblemsRange, fetchLatestSignature, getYesterdayToNowRangeIso } from "../api/problems";

function Chip({ active, onClick, children, color }) {
  return (
    <button
      onClick={onClick}
      style={{
        border: "1px solid rgba(0,0,0,.12)",
        background: active ? (color || "#e5e7eb") : "#f3f4f6",
        padding: "6px 12px",
        borderRadius: "999px",
        cursor: "pointer",
        fontWeight: 700,
      }}
    >
      {children}
    </button>
  );
}

export default function OtherProblems() {
  const [username, setUsername] = useState("");
  const [loading, setLoading] = useState(false);
  const [base, setBase] = useState([]);

  const [envFilter, setEnvFilter] = useState(null);
  const [statusFilter, setStatusFilter] = useState(null);

  const abortRef = useRef(null);
  const inFlightRef = useRef(false);
  const lastSigRef = useRef(null);

  const load = async () => {
    if (inFlightRef.current) return;
    inFlightRef.current = true;

    if (abortRef.current) abortRef.current.abort();
    const controller = new AbortController();
    abortRef.current = controller;

    setLoading(true);

    try {
      const { startIso, endIso } = getYesterdayToNowRangeIso();
      const allAccum = [];

      await fetchProblemsRange({
        startIso,
        endIso,
        jurisdiction: "OTROS",
        pageSize: 200,
        maxPages: 60,
        signal: controller.signal,
        onBatch: (batch) => {
          for (const x of batch) allAccum.push(x);
          setBase([...allAccum]);
        },
      });
    } catch (e) {
      if (String(e?.name || "").toLowerCase() !== "aborterror") console.error(e);
    } finally {
      setLoading(false);
      inFlightRef.current = false;
    }
  };

  useEffect(() => {
    load();

    const poll = async () => {
      try {
        const { startIso, endIso } = getYesterdayToNowRangeIso();
        const sig = await fetchLatestSignature({ startIso, endIso, jurisdiction: "OTROS" });

        if (lastSigRef.current === null) {
          lastSigRef.current = sig;
          return;
        }

        if (sig && sig !== lastSigRef.current) {
          lastSigRef.current = sig;
          load();
        }
      } catch {}
    };

    const t = setInterval(poll, 20000);

    return () => {
      clearInterval(t);
      if (abortRef.current) abortRef.current.abort();
    };
  }, []);

  const counts = useMemo(() => {
    const prod = base.filter((x) => x.environment === "Productivo").length;
    const nprod = base.filter((x) => x.environment === "No Productivo").length;
    const open = base.filter((x) => (x.status || "").toUpperCase() === "OPEN").length;
    const closed = base.filter((x) => (x.status || "").toUpperCase() === "CLOSED").length;
    return { total: base.length, prod, nprod, open, closed };
  }, [base]);

  const visible = useMemo(() => {
    let list = base;
    if (envFilter) list = list.filter((x) => x.environment === envFilter);
    if (statusFilter) list = list.filter((x) => (x.status || "").toUpperCase() === statusFilter);
    return list;
  }, [base, envFilter, statusFilter]);

  return (
    <div style={{ maxWidth: 980, margin: "0 auto", padding: "2rem 1rem" }}>
      <h1 style={{ textAlign: "center", marginBottom: ".5rem" }}>
        Problemas Otros ({counts.total})
      </h1>

      <div style={{ display: "flex", justifyContent: "center", gap: "10px", marginBottom: "10px" }}>
        <div style={{ fontWeight: 700 }}>Usuario:</div>
        <input
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          style={{ padding: "4px 8px", border: "1px solid #ccc", borderRadius: 4, width: 180 }}
          placeholder="Tu usuario"
        />
      </div>

      <div style={{ display: "flex", justifyContent: "center", gap: "10px", flexWrap: "wrap", marginBottom: "18px" }}>
        <Chip
          active={envFilter === "Productivo"}
          color="#93c5fd"
          onClick={() => setEnvFilter(envFilter === "Productivo" ? null : "Productivo")}
        >
          Productivo ({counts.prod})
        </Chip>

        <Chip
          active={envFilter === "No Productivo"}
          color="#e5e7eb"
          onClick={() => setEnvFilter(envFilter === "No Productivo" ? null : "No Productivo")}
        >
          No Productivo ({counts.nprod})
        </Chip>

        <Chip
          active={statusFilter === "OPEN"}
          color="#fde68a"
          onClick={() => setStatusFilter(statusFilter === "OPEN" ? null : "OPEN")}
        >
          Abiertas ({counts.open})
        </Chip>

        <Chip
          active={statusFilter === "CLOSED"}
          color="#86efac"
          onClick={() => setStatusFilter(statusFilter === "CLOSED" ? null : "CLOSED")}
        >
          Cerradas ({counts.closed})
        </Chip>

        <Chip
          active={!envFilter && !statusFilter}
          onClick={() => {
            setEnvFilter(null);
            setStatusFilter(null);
          }}
        >
          Todos
        </Chip>
      </div>

      {loading && (
        <div style={{ textAlign: "center", marginBottom: "10px", fontWeight: 700 }}>
          Cargando problemas...
        </div>
      )}

      {visible.map((p) => (
        <ProblemCard key={`${p.problemId}-${p.startTime}`} problem={p} username={username} />
      ))}
    </div>
  );
}

-------

// src/components/ProblemCard.jsx
import React, { useEffect, useMemo, useState } from "react";
import { useBiaCatalog } from "../context/BiaCatalogContext";
import {
  getSlaMinutes,
  getColorByPercent,
  calcularCriticidadDetallada,
  getButtonColorByPercent,
} from "../utils/slaUtils";

// Normaliza estado OPEN/CLOSED (sin inventar OPEN si viene CLOSED)
function normalizeStatus(p) {
  const raw = p?.status ?? p?.Status ?? p?.problemStatus ?? p?.problemState ?? "";
  const s = String(raw || "").trim().toUpperCase();

  if (s.includes("OPEN")) return "OPEN";
  if (s.includes("CLOSED") || s.includes("RESOLVED")) return "CLOSED";

  // fallback solo si no vino status
  return p?.endTime || p?.EndTime ? "CLOSED" : "OPEN";
}

// Iconos por tower
function towerToIconPath(towerKey) {
  if (!towerKey) return null;
  const key = String(towerKey).toLowerCase();

  if (key.includes("wintel") || key.includes("windows")) return "/icons/towers/wiltel1.svg";
  if (key.includes("bdd") || key.includes("base de datos") || key.includes("database") || key.includes("bd"))
    return "/icons/towers/Base.svg";
  if (key.includes("unix") || key.includes("aix") || key.includes("linux")) return "/icons/towers/unix.svg";

  return null;
}

export default function ProblemCard({ problem, username }) {
  const { get: catalogGet } = useBiaCatalog();

  const status = useMemo(() => normalizeStatus(problem), [problem]);

  const start = useMemo(() => {
    const raw = problem?.startTime ?? problem?.StartTime ?? problem?.start ?? problem?.Start;
    return raw ? new Date(raw) : new Date();
  }, [problem]);

  // Buscar coincidencia con catálogo
  const hitFromCatalog = useMemo(() => {
    const arr = Array.isArray(problem?.affectedCI)
      ? problem.affectedCI
      : Array.isArray(problem?.AffectedCI)
      ? problem.AffectedCI
      : [];
    for (const ci of arr) {
      const name = ci?.name || ci?.Nombre;
      const hit = name ? catalogGet(name) : null;
      if (hit) return hit;
    }
    return null;
  }, [problem, catalogGet]);

  const towerIcon = towerToIconPath(hitFromCatalog?.tower);

  const { criticidad } = calcularCriticidadDetallada(problem, {
    catalogLookup: (ciName) => catalogGet(ciName),
  });

  // SLA
  const slaMinutes = getSlaMinutes(criticidad);

  // Timer: SOLO si está OPEN
  const [now, setNow] = useState(new Date());

  useEffect(() => {
    if (status === "CLOSED") return; // NO corre en CLOSED
    const interval = setInterval(() => setNow(new Date()), 1000);
    return () => clearInterval(interval);
  }, [status]);

  const elapsedMinutes = useMemo(() => (status === "CLOSED" ? 0 : (now - start) / 60000), [now, start, status]);

  const remainingMinutes = useMemo(() => (status === "CLOSED" ? 0 : Math.max(slaMinutes - elapsedMinutes, 0)), [
    slaMinutes,
    elapsedMinutes,
    status,
  ]);

  const percentRemaining = useMemo(() => {
    if (status === "CLOSED") return 100;
    return Math.max((remainingMinutes / slaMinutes) * 100, 0);
  }, [remainingMinutes, slaMinutes, status]);

  const bgColor = getColorByPercent(percentRemaining);
  const buttonColor = getButtonColorByPercent(percentRemaining);

  const formatTime = (minutes) => {
    const totalSeconds = Math.floor(minutes * 60);
    const hrs = Math.floor(totalSeconds / 3600);
    const mins = Math.floor((totalSeconds % 3600) / 60);
    const secs = totalSeconds % 60;
    return `${String(hrs).padStart(2, "0")}:${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
  };

  const affected = Array.isArray(problem?.affectedCI)
    ? problem.affectedCI
    : Array.isArray(problem?.AffectedCI)
    ? problem.AffectedCI
    : [];
  const uniqueNames = [...new Set(affected.map((ci) => ci?.name).filter(Boolean))];
  const equipos = uniqueNames.join(", ");

  const isDisabled = !username;

  const tenant = problem?.tenant || problem?.Tenant || "";
  const problemId = problem?.problemId || problem?.ProblemId || problem?.displayId || problem?.DisplayId || "";

  const dynatraceUrl =
    tenant && problemId ? `https://${tenant}.live.dynatrace.com/#problems/problemdetails;pid=${problemId}` : "#";

  const environment = problem?.environment || problem?.Environment || "";

  return (
    <div
      style={{
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        borderRadius: "12px",
        padding: "1rem 1.5rem",
        marginBottom: "1rem",
        backgroundColor: bgColor,
        boxShadow: "0 4px 10px rgba(0,0,0,.1)",
      }}
    >
      {/* IZQUIERDA: INFO */}
      <div style={{ flex: 1, paddingRight: "1rem" }}>
        <h3 style={{ margin: 0, fontSize: "1.6rem", fontWeight: "bold" }}>
          {problem?.title || problem?.Title || "(sin título)"}
        </h3>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Severidad Dynatrace:</strong> {problem?.severityLevel || problem?.SeverityLevel || ""}
        </p>
        <p style={{ fontSize: "1.2rem" }}>
          <strong>Impacto:</strong> {problem?.impactLevel || problem?.ImpactLevel || ""}
        </p>
        <p style={{ fontSize: "1.2rem" }}>
          <strong>Inicio:</strong> {start.toLocaleString()}
        </p>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Estado:</strong> {status}
        </p>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Criticidad (BIA):</strong> {criticidad}
        </p>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Equipos afectados:</strong> <small>{equipos}</small>
        </p>
      </div>

      {/* CENTRO: ICONOS */}
      <div
        style={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          gap: "1rem",
          flexShrink: 0,
          minWidth: "220px",
        }}
      >
        {(() => {
          const size = 110;
          return (
            <>
              <img
                src={`/severidad${criticidad}.svg`}
                width={size}
                height={size}
                title={`Criticidad ${criticidad}`}
                alt={`Criticidad ${criticidad}`}
              />
              <img
                src={environment === "Productivo" ? "/icon-productivo.svg" : "/icon-noproductivo.svg"}
                width={size}
                height={size}
                title={environment}
                alt={environment}
              />
              {towerIcon && (
                <img
                  src={towerIcon}
                  alt="tower"
                  width={size}
                  height={size}
                  title={hitFromCatalog?.towerRaw || hitFromCatalog?.tower}
                />
              )}
            </>
          );
        })()}
      </div>

      {/* DERECHA: TIMER + BOTÓN */}
      <div style={{ textAlign: "center", minWidth: "160px" }}>
        <div style={{ fontSize: "2rem", fontWeight: "bold" }}>{formatTime(remainingMinutes)}</div>

        <button
          disabled={isDisabled || dynatraceUrl === "#"}
          onClick={() => window.open(dynatraceUrl, "_blank")}
          style={{
            marginTop: ".5rem",
            padding: ".4rem 1rem",
            fontSize: ".9rem",
            fontWeight: "bold",
            color: "#fff",
            backgroundColor: isDisabled ? "#b0b0b0" : status === "CLOSED" ? "#6b7280" : buttonColor,
            border: "none",
            borderRadius: "8px",
            cursor: isDisabled ? "not-allowed" : "pointer",
          }}
        >
          Revisar problema
        </button>
      </div>
    </div>
  );
}
