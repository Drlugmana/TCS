// src/api/problems.js
// ===========================
// CONFIG FECHA (opcional)
// Si pones "YYYY-MM-DD" fuerza modo día puntual.
// Si lo dejas en null => sin límite por fecha (histórico completo).
export const ONLY_DATE = null;

// ===========================
// BASE DE LA API (desde .env)
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, "");
if (!BASE) throw new Error("Falta VITE_API_URL en .env (ej: https://xxxxx.brs.devtunnels.ms)");

const API = `${BASE}/api/Problems`;

// ===========================
// Helpers robustos
function cleanNull(v) {
  if (v === undefined || v === null) return null;
  if (typeof v === "string") {
    const t = v.trim();
    if (!t) return null;
    const low = t.toLowerCase();
    if (low === "null" || low === "undefined") return null;
    return t;
  }
  return v;
}

function parseDateToISO(v) {
  v = cleanNull(v);
  if (!v) return null;

  // Date
  if (v instanceof Date) {
    const ms = v.getTime();
    return Number.isFinite(ms) ? v.toISOString() : null;
  }

  // epoch
  if (typeof v === "number") {
    const d = new Date(v);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  // string
  if (typeof v === "string") {
    let s = v.trim();

    // "YYYY-MM-DD HH:mm:ss.fffffff" => "YYYY-MM-DDT..."
    if (/^\d{4}-\d{2}-\d{2}\s+\d/.test(s)) s = s.replace(" ", "T");

    const d = new Date(s);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  return null;
}

function normalizeStatusValue(rawStatus, endTimeISO) {
  const s = cleanNull(rawStatus);
  const up = typeof s === "string" ? s.trim().toUpperCase() : "";

  // casos típicos
  if (up.includes("CLOSED") || up.includes("RESOLVED")) return "CLOSED";
  if (up.includes("OPEN")) return "OPEN";

  // si no vino status, deduce por endTime
  // (si endTime no es null => cerrado)
  return endTimeISO ? "CLOSED" : "OPEN";
}

// ===========================
// Normalizador robusto
function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    // start / end (acepta nombres diversos)
    const startRaw =
      p?.startTime ??
      p?.startTimeUtc ??
      p?.StartTime ??
      p?.StartTimeUtc ??
      p?.start_date ??
      p?.Start ??
      null;

    const endRaw =
      p?.endTime ??
      p?.endTimeUtc ??
      p?.EndTime ??
      p?.EndTimeUtc ??
      p?.end_date ??
      p?.End ??
      null;

    const startTime = parseDateToISO(startRaw);
    const endTime = parseDateToISO(endRaw);

    // jurisdicción (TCS/NO TCS)
    const jurisRaw =
      p?.jurisdiction?.label ??
      p?.jurisdiction?.name ??
      p?.jurisdiction?.Jurisdiction ??
      p?.Jurisdiction ??
      p?.jurisdiction ??
      p?.label ??
      "";

    const juris = typeof jurisRaw === "string" ? jurisRaw.trim().toUpperCase() : "";
    const isTcs =
      p?.jurisdiction?.isTcs ??
      (juris === "TCS" ? true : false);

    // ids/títulos
    const problemId = p?.problemId ?? p?.displayId ?? p?.id ?? p?.pid ?? "";
    const title = p?.title ?? p?.shortDescription ?? "(sin título)";

    // otros campos usados por la UI
    const severityLevel = p?.severityLevel ?? p?.SeverityLevel ?? p?.severity ?? "";
    const impactLevel = p?.impactLevel ?? p?.ImpactLevel ?? p?.impact ?? "";
    const environment = p?.environment ?? p?.environmentName ?? p?.Environment ?? "";

    const affectedCI =
      p?.affectedCI ??
      p?.AffectedCI ??
      p?.affectedEntities ??
      p?.affectedEntitiesList ??
      [];

    // status final SIEMPRE "OPEN" / "CLOSED"
    const status = normalizeStatusValue(
      p?.status ?? p?.state ?? p?.Status ?? p?.problemStatus,
      endTime
    );

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment,
      affectedCI,
      status, // "OPEN" | "CLOSED" ✅
      tenant: p?.tenant ?? p?.domain ?? "",
      label: isTcs ? "TCS" : "NO TCS",
      isTcs,
      startTime,
      endTime,
    };
  });
}

// ===========================
// Fetch de UNA página con query-params
async function fetchPage({ pageNumber, pageSize, startIso, endIso }) {
  const params = new URLSearchParams();
  params.set("pageNumber", String(pageNumber));
  params.set("pageSize", String(pageSize));

  // Si tu backend los soporta, se mandan. Si no, los ignora.
  if (startIso) params.set("start", startIso);
  if (endIso) params.set("end", endIso);

  const url = `${API}?${params.toString()}`;
  const res = await fetch(url, { headers: { accept: "application/json" } });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} en ${url}\n${txt}`);
  }

  const json = await res.json();

  // Puede venir array directo o envuelto
  const items = Array.isArray(json)
    ? json
    : json?.results || json?.items || json?.data || json?.value || [];

  return normalize(items);
}

// ===========================
// Utilidad: rango para un solo día local (YYYY-MM-DD)
function getDayRange(dateStr /* YYYY-MM-DD */) {
  const start = new Date(`${dateStr}T00:00:00`);
  const end = new Date(`${dateStr}T23:59:59.999`);
  return { startIso: start.toISOString(), endIso: end.toISOString() };
}

export function toLocalDayIsoRange(dateStr) {
  return getDayRange(dateStr);
}

// ===========================
// Fetch histórico con paginado + filtros opcionales
export async function fetchAllProblems({
  onlyDate = ONLY_DATE, // si string => fuerza ese día; si null => sin límite
  pageSize = 500,
  maxPages = 40,
  onBatch,

  tcsFilter, // true | false | undefined
  statusFilter, // "OPEN" | "CLOSED" | undefined
  environmentFilter, // "Productivo" | "NoProductivo" | undefined (o parte del texto)
  startIso,
  endIso,
  recentDays = 1, // ✅ por defecto 1 día (24h) para que cargue rápido
} = {}) {
  // 1) Definir rango
  let range = { startIso, endIso };

  // ✅ reciente (últimas 24h por defecto)
  if (typeof recentDays === "number" && recentDays > 0) {
    const end = new Date();
    const start = new Date(end);
    start.setDate(end.getDate() - recentDays);
    range = { startIso: start.toISOString(), endIso: end.toISOString() };
  }

  // si fuerza día puntual
  if ((!range.startIso || !range.endIso) && typeof onlyDate === "string") {
    range = getDayRange(onlyDate);
  }

  // 2) paginar
  let all = [];

  for (let page = 1; page <= maxPages; page++) {
    const batch = await fetchPage({
      pageNumber: page,
      pageSize,
      startIso: range.startIso,
      endIso: range.endIso,
    });

    if (!batch.length) break;

    // 3) Filtros en cliente (robustos)
    let filtered = batch;

    if (typeof tcsFilter === "boolean") {
      filtered = filtered.filter((x) => x.isTcs === tcsFilter);
    }

    if (statusFilter) {
      const want = String(statusFilter).toUpperCase();
      // ✅ OPEN = status OPEN (y por normalizador, OPEN se mantiene aunque venga raro)
      filtered = filtered.filter((x) => String(x.status || "").toUpperCase() === want);
    }

    if (environmentFilter) {
      const want = String(environmentFilter).toUpperCase();
      filtered = filtered.filter((x) => String(x.environment || "").toUpperCase().includes(want));
    }

    if (onBatch) onBatch(filtered);
    all = all.concat(filtered);

    // si el backend devuelve menos que pageSize, asumimos última página
    if (batch.length < pageSize) break;
  }

  // 4) Orden: más recientes primero (por startTime)
  all.sort((a, b) => {
    const da = a.startTime ? new Date(a.startTime).getTime() : 0;
    const db = b.startTime ? new Date(b.startTime).getTime() : 0;
    return db - da;
  });

  return all;
}

// ===========================
// Conveniencias (TCS / NO TCS)
export const fetchTcsOpenRecent = (opts = {}) =>
  fetchAllProblems({ tcsFilter: true, statusFilter: "OPEN", recentDays: 1, ...opts });

export const fetchNotTcsOpenRecent = (opts = {}) =>
  fetchAllProblems({ tcsFilter: false, statusFilter: "OPEN", recentDays: 1, ...opts });

export const fetchTcsClosedRecent = (opts = {}) =>
  fetchAllProblems({ tcsFilter: true, statusFilter: "CLOSED", recentDays: 1, ...opts });

export const fetchNotTcsClosedRecent = (opts = {}) =>
  fetchAllProblems({ tcsFilter: false, statusFilter: "CLOSED", recentDays: 1, ...opts });