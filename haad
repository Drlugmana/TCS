// src/api/problems.js
// ===========================
// Traer por defecto: desde AYER 00:00 (hora local) hasta AHORA
export const DEFAULT_RECENT_DAYS = 1;

// ===========================
// BASE DE LA API (desde .env)
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, "");
if (!BASE) throw new Error("Falta VITE_API_URL en .env (ej: https://xxxxx.brs.devtunnels.ms)");

const API = `${BASE}/api/Problems`;

// ===========================
// Helpers
function cleanNull(v) {
  if (v === undefined || v === null) return null;
  if (typeof v === "string") {
    const t = v.trim();
    if (!t) return null;
    const low = t.toLowerCase();
    if (low === "null" || low === "undefined") return null;
    return t;
  }
  return v;
}

function parseDateToISO(v) {
  v = cleanNull(v);
  if (!v) return null;

  if (v instanceof Date) {
    const ms = v.getTime();
    return Number.isFinite(ms) ? v.toISOString() : null;
  }

  if (typeof v === "number") {
    const d = new Date(v);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  if (typeof v === "string") {
    let s = v.trim();

    // SQL "YYYY-MM-DD HH:mm:ss" -> ISO friendly
    if (/^\d{4}-\d{2}-\d{2}\s+\d/.test(s)) s = s.replace(" ", "T");

    const d = new Date(s);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  return null;
}

function normalizeStatus(rawStatus, endTimeISO) {
  const s = cleanNull(rawStatus);
  const up = typeof s === "string" ? s.trim().toUpperCase() : "";

  if (up.includes("OPEN")) return "OPEN";
  if (up.includes("CLOSED") || up.includes("RESOLVED")) return "CLOSED";

  // fallback solo si NO vino status
  return endTimeISO ? "CLOSED" : "OPEN";
}

function normalizeEnvironment(envRaw) {
  const s = (cleanNull(envRaw) || "").toString().trim();
  const up = s.toUpperCase().replace(/\s+/g, "");

  // Normaliza variaciones: "NoProductivo", "No Productivo", "NO_PRODUCTIVO"
  if (up.includes("NOPRODUCTIVO") || up.includes("NO-PRODUCTIVO") || up.includes("NO_PRODUCTIVO")) {
    return "No Productivo";
  }
  if (up.includes("PRODUCTIVO") || up === "PROD") return "Productivo";

  return s || "";
}

/**
 * ✅ IMPORTANTE:
 * "NO TCS" contiene el texto "TCS", por eso NO se puede usar includes("TCS") a secas.
 * Reglas:
 * - Si empieza con "NO" y contiene "TCS" => "OTROS"
 * - Si es exactamente "TCS" => "TCS"
 * - Si contiene "TCS" pero NO está negado => "TCS"
 * - caso contrario => "OTROS"
 */
function normalizeJurisdiction(jRaw) {
  const raw = (cleanNull(jRaw) || "").toString().trim();
  const up = raw.toUpperCase();

  if (!up) return "OTROS";

  // Casos "NO TCS", "NO_TCS", "NO-TCS"
  const compact = up.replace(/\s+/g, "");
  if (compact.startsWith("NO") && compact.includes("TCS")) return "OTROS";

  if (up === "TCS") return "TCS";

  // Si el texto tiene TCS pero no está negado
  if (up.includes("TCS")) return "TCS";

  return "OTROS";
}

// ===========================
// Normalizador robusto
function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    const startRaw =
      p?.startTime ?? p?.startTimeUtc ?? p?.StartTime ?? p?.StartTimeUtc ?? p?.start_date ?? p?.Start ?? null;

    const endRaw =
      p?.endTime ?? p?.endTimeUtc ?? p?.EndTime ?? p?.EndTimeUtc ?? p?.end_date ?? p?.End ?? null;

    const startTime = parseDateToISO(startRaw);
    const endTime = parseDateToISO(endRaw);

    const problemId = p?.problemId ?? p?.displayId ?? p?.DisplayId ?? p?.id ?? p?.pid ?? "";
    const title = p?.title ?? p?.Title ?? p?.shortDescription ?? p?.ShortDescription ?? "(sin título)";

    const severityLevel = p?.severityLevel ?? p?.SeverityLevel ?? p?.severity ?? "";
    const impactLevel = p?.impactLevel ?? p?.ImpactLevel ?? p?.impact ?? "";

    const env = normalizeEnvironment(p?.environment ?? p?.Environment ?? p?.environmentName ?? "");
    const juris = normalizeJurisdiction(p?.jurisdiction ?? p?.Jurisdiction ?? p?.label ?? p?.Label ?? "");

    const affectedCI =
      p?.affectedCI ??
      p?.AffectedCI ??
      p?.affectedEntities ??
      p?.affectedEntitiesList ??
      [];

    const status = normalizeStatus(
      p?.status ?? p?.Status ?? p?.state ?? p?.problemStatus ?? p?.problemState,
      endTime
    );

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment: env,
      jurisdiction: juris, // "TCS" | "OTROS"
      affectedCI,
      status, // "OPEN" | "CLOSED"
      tenant: p?.tenant ?? p?.Tenant ?? p?.domain ?? "",
      startTime,
      endTime,
    };
  });
}

// ===========================
// Rango: AYER 00:00 local -> AHORA
export function getYesterdayToNowRangeIso() {
  const now = new Date();
  const start = new Date(now);
  start.setDate(now.getDate() - 1);
  start.setHours(0, 0, 0, 0);
  return { startIso: start.toISOString(), endIso: now.toISOString() };
}

// ===========================
// ✅ Fetch de UNA página (soporta signal)
// NOTA: NO enviamos start/end al backend por defecto (para no romper si no lo soporta).
async function fetchPage({ pageNumber, pageSize, signal }) {
  const params = new URLSearchParams();
  params.set("pageNumber", String(pageNumber));
  params.set("pageSize", String(pageSize));

  const url = `${API}?${params.toString()}`;

  const res = await fetch(url, {
    headers: { accept: "application/json" },
    signal,
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} en ${url}\n${txt}`);
  }

  const json = await res.json();

  const items = Array.isArray(json)
    ? json
    : json?.results || json?.items || json?.data || json?.value || [];

  return normalize(items);
}

// ===========================
// ✅ Fetch con paginado (trae TODO y filtra por rango en el FRONT)
// - onBatch: para pintar rápido
// - signal: para abortar requests viejos
export async function fetchProblemsRange({
  startIso,
  endIso,
  pageSize = 500,
  maxPages = 50,
  onBatch,
  signal,
} = {}) {
  const startMs = startIso ? new Date(startIso).getTime() : null;
  const endMs = endIso ? new Date(endIso).getTime() : null;

  let all = [];

  for (let page = 1; page <= maxPages; page++) {
    const batchRaw = await fetchPage({ pageNumber: page, pageSize, signal });
    if (!batchRaw.length) break;

    // ✅ FILTRO REAL (ayer 00:00 -> ahora) EN EL FRONT
    const batch = batchRaw.filter((p) => {
      const t = p?.startTime ? new Date(p.startTime).getTime() : null;
      if (!Number.isFinite(t)) return false;

      if (startMs !== null && t < startMs) return false;
      if (endMs !== null && t > endMs) return false;

      return true;
    });

    if (batch.length) {
      if (onBatch) onBatch(batch);
      all = all.concat(batch);
    }

    // Si vino menos que pageSize => última página
    if (batchRaw.length < pageSize) break;
  }

  // orden: más recientes primero
  all.sort((a, b) => {
    const da = a.startTime ? new Date(a.startTime).getTime() : 0;
    const db = b.startTime ? new Date(b.startTime).getTime() : 0;
    return db - da;
  });

  return all;
}