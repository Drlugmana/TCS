// src/api/problems.js
// ===========================
// Traer SOLO desde ayer (últimas 24h) por defecto:
export const DEFAULT_RECENT_DAYS = 1;

// ===========================
// BASE DE LA API (desde .env)
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, "");
if (!BASE) throw new Error("Falta VITE_API_URL en .env (ej: https://xxxxx.brs.devtunnels.ms)");

const API = `${BASE}/api/Problems`;

// ===========================
// Helpers robustos
function cleanNull(v) {
  if (v === undefined || v === null) return null;
  if (typeof v === "string") {
    const t = v.trim();
    if (!t) return null;
    if (t.toLowerCase() === "null") return null;
    if (t.toLowerCase() === "undefined") return null;
    return t;
  }
  return v;
}

function parseDateToISO(v) {
  v = cleanNull(v);
  if (!v) return null;

  if (v instanceof Date) {
    const ms = v.getTime();
    return Number.isFinite(ms) ? v.toISOString() : null;
  }

  if (typeof v === "number") {
    const d = new Date(v);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  if (typeof v === "string") {
    let s = v.trim();
    // "YYYY-MM-DD HH:mm:ss" -> "YYYY-MM-DDTHH:mm:ss"
    if (/^\d{4}-\d{2}-\d{2}\s+\d/.test(s)) s = s.replace(" ", "T");
    const d = new Date(s);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  return null;
}

// Normaliza estado SIEMPRE "OPEN" / "CLOSED"
function normalizeStatusValue(rawStatus, endTimeISO) {
  const s = cleanNull(rawStatus);
  const up = typeof s === "string" ? s.trim().toUpperCase() : "";

  if (up.includes("CLOSED") || up.includes("RESOLVED")) return "CLOSED";
  if (up.includes("OPEN")) return "OPEN";

  // fallback: si endTime existe -> CLOSED
  return endTimeISO ? "CLOSED" : "OPEN";
}

// ===========================
// Normalizador robusto (devuelve objetos consistentes)
function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    const startRaw =
      p?.startTime ??
      p?.startTimeUtc ??
      p?.StartTime ??
      p?.StartTimeUtc ??
      p?.start_date ??
      p?.Start ??
      null;

    const endRaw =
      p?.endTime ??
      p?.endTimeUtc ??
      p?.EndTime ??
      p?.EndTimeUtc ??
      p?.end_date ??
      p?.End ??
      null;

    const startTime = parseDateToISO(startRaw);
    const endTime = parseDateToISO(endRaw);

    const jurisRaw =
      p?.jurisdiction?.label ??
      p?.jurisdiction?.name ??
      p?.jurisdiction?.Jurisdiction ??
      p?.Jurisdiction ??
      p?.jurisdiction ??
      p?.label ??
      "";

    const juris = typeof jurisRaw === "string" ? jurisRaw.trim().toUpperCase() : "";
    const isTcs =
      p?.jurisdiction?.isTcs ??
      (juris === "TCS" ? true : false) ??
      false;

    const problemId = p?.problemId ?? p?.displayId ?? p?.id ?? p?.pid ?? "";
    const title = p?.title ?? p?.shortDescription ?? "(sin título)";

    const severityLevel = p?.severityLevel ?? p?.SeverityLevel ?? p?.severity ?? "";
    const impactLevel = p?.impactLevel ?? p?.ImpactLevel ?? p?.impact ?? "";
    const environment = p?.environment ?? p?.environmentName ?? p?.Environment ?? "";

    const affectedCI =
      p?.affectedCI ??
      p?.AffectedCI ??
      p?.affectedEntities ??
      p?.affectedEntitiesList ??
      [];

    const status = normalizeStatusValue(
      p?.status ?? p?.state ?? p?.Status ?? p?.problemStatus,
      endTime
    );

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment,
      affectedCI,
      status, // "OPEN" | "CLOSED"
      tenant: p?.tenant ?? p?.domain ?? "",
      label: isTcs ? "TCS" : "OTROS",
      isTcs,
      startTime,
      endTime,
    };
  });
}

// ===========================
// Fetch de UNA página
async function fetchPage({ pageNumber, pageSize, startIso, endIso }) {
  const params = new URLSearchParams();
  params.set("pageNumber", String(pageNumber));
  params.set("pageSize", String(pageSize));
  if (startIso) params.set("start", startIso);
  if (endIso) params.set("end", endIso);

  const url = `${API}?${params.toString()}`;
  const res = await fetch(url, { headers: { accept: "application/json" } });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} en ${url}\n${txt}`);
  }

  const json = await res.json();

  const items = Array.isArray(json)
    ? json
    : json?.results || json?.items || json?.data || json?.value || [];

  return normalize(items);
}

// ===========================
// Rango: últimas N días
function getRecentRange(recentDays = 1) {
  const end = new Date();
  const start = new Date(end);
  start.setDate(end.getDate() - recentDays);
  return { startIso: start.toISOString(), endIso: end.toISOString() };
}

// ===========================
// Fetch rápido con paginado
export async function fetchAllProblems({
  recentDays = DEFAULT_RECENT_DAYS,
  pageSize = 2000, // ✅ para que entren 14+ OPEN en la primera página
  maxPages = 3,    // ✅ no te demoras trayendo 40 páginas
  onBatch,

  tcsFilter, // true | false
  statusFilter, // "OPEN" | "CLOSED" | undefined
  environmentFilter, // "Productivo" | "NoProductivo" | undefined
} = {}) {
  const range = getRecentRange(recentDays);

  let all = [];

  for (let page = 1; page <= maxPages; page++) {
    const batch = await fetchPage({
      pageNumber: page,
      pageSize,
      startIso: range.startIso,
      endIso: range.endIso,
    });

    if (!batch.length) break;

    let filtered = batch;

    if (typeof tcsFilter === "boolean") {
      filtered = filtered.filter((x) => x.isTcs === tcsFilter);
    }

    if (statusFilter) {
      const want = String(statusFilter).toUpperCase();
      filtered = filtered.filter((x) => String(x.status || "").toUpperCase() === want);
    }

    if (environmentFilter) {
      const want = String(environmentFilter).toUpperCase();
      filtered = filtered.filter((x) => String(x.environment || "").toUpperCase().includes(want));
    }

    if (onBatch) onBatch(filtered);
    all = all.concat(filtered);

    if (batch.length < pageSize) break;
  }

  // más recientes primero
  all.sort((a, b) => {
    const da = a.startTime ? new Date(a.startTime).getTime() : 0;
    const db = b.startTime ? new Date(b.startTime).getTime() : 0;
    return db - da;
  });

  return all;
}

---

// src/components/ProblemCard.jsx
import React, { useEffect, useMemo, useState } from "react";
import { useBiaCatalog } from "../context/BiaCatalogContext";
import {
  getSlaMinutes,
  getColorByPercent,
  calcularCriticidadDetallada,
  getButtonColorByPercent,
} from "../utils/slaUtils";

// === Traduce towerKey a icono correspondiente ===
function towerToIconPath(towerKey) {
  if (!towerKey) return null;
  const key = String(towerKey).toLowerCase();

  if (key.includes("wintel") || key.includes("windows")) return "/icons/towers/wiltel1.svg";
  if (key.includes("bdd") || key.includes("base de datos") || key.includes("database") || key.includes("bd"))
    return "/icons/towers/Base.svg";
  if (key.includes("unix") || key.includes("aix") || key.includes("linux")) return "/icons/towers/unix.svg";

  return null;
}

export default function ProblemCard({ problem, username }) {
  const {
    title,
    severityLevel,
    impactLevel,
    startTime,
    endTime,
    environment,
    affectedCI = [],
    tenant,
    problemId,
    status, // ✅ ya viene normalizado "OPEN"/"CLOSED" desde api
  } = problem;

  const { get: catalogGet } = useBiaCatalog();

  const hitFromCatalog = useMemo(() => {
    for (const ci of affectedCI || []) {
      const name = ci?.name || ci?.Nombre;
      const hit = name ? catalogGet(name) : null;
      if (hit) return hit;
    }
    return null;
  }, [affectedCI, catalogGet]);

  const towerIcon = towerToIconPath(hitFromCatalog?.tower);

  const { criticidad } = calcularCriticidadDetallada(problem, {
    catalogLookup: (ciName) => catalogGet(ciName),
  });

  const slaMinutes = getSlaMinutes(criticidad);

  const start = new Date(startTime);
  const [now, setNow] = useState(new Date());

  // ✅ FIX: si CLOSED no corras el reloj
  useEffect(() => {
    if (status === "CLOSED") return;
    const interval = setInterval(() => setNow(new Date()), 1000);
    return () => clearInterval(interval);
  }, [status]);

  // tiempo
  const elapsedMinutes = (now - start) / 60000;
  const remainingMinutes = Math.max(slaMinutes - elapsedMinutes, 0);
  const percentRemaining = Math.max((remainingMinutes / slaMinutes) * 100, 0);

  const bgColor = getColorByPercent(percentRemaining);
  const buttonColor = getButtonColorByPercent(percentRemaining);

  const formatTime = (minutes) => {
    const totalSeconds = Math.floor(minutes * 60);
    const hrs = Math.floor(totalSeconds / 3600);
    const mins = Math.floor((totalSeconds % 3600) / 60);
    const secs = totalSeconds % 60;
    return `${String(hrs).padStart(2, "0")}:${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
  };

  const uniqueNames = [...new Set(affectedCI.map((ci) => ci?.name).filter(Boolean))];
  const equipos = uniqueNames.join(", ");

  const isDisabled = !username;
  const dynatraceUrl = `https://${tenant}.live.dynatrace.com/#problems/problemdetails;pid=${problemId}`;

  return (
    <div
      style={{
        display: "flex",
        justifyContent: "space-between",
        alignItems: "center",
        borderRadius: "12px",
        padding: "1rem 1.5rem",
        marginBottom: "1rem",
        backgroundColor: bgColor,
        boxShadow: "0 4px 10px rgba(0,0,0,.1)",
        opacity: status === "CLOSED" ? 0.9 : 1,
      }}
    >
      {/* IZQUIERDA: TEXTO */}
      <div style={{ flex: 1, paddingRight: "1rem" }}>
        <h3 style={{ margin: 0, fontSize: "1.6rem", fontWeight: "bold" }}>{title}</h3>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Severidad Dynatrace:</strong> {severityLevel}
        </p>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Impacto:</strong> {impactLevel}
        </p>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Inicio:</strong> {start.toLocaleString()}
        </p>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Estado:</strong> {status}
        </p>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Criticidad (BIA):</strong> {criticidad}
        </p>

        <p style={{ fontSize: "1.2rem" }}>
          <strong>Equipos afectados:</strong> <small>{equipos}</small>
        </p>
      </div>

      {/* CENTRO: ICONOS */}
      <div
        style={{
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          gap: "1rem",
          flexShrink: 0,
          minWidth: "200px",
        }}
      >
        {(() => {
          const size = 110;
          return (
            <>
              <img
                src={`/severidad${criticidad}.svg`}
                width={size}
                height={size}
                title={`Criticidad ${criticidad}`}
              />
              <img
                src={environment === "Productivo" ? "/icon-productivo.svg" : "/icon-noproductivo.svg"}
                width={size}
                height={size}
                title={environment}
              />
              {towerIcon && (
                <img
                  src={towerIcon}
                  alt="tower"
                  width={size}
                  height={size}
                  title={hitFromCatalog?.towerRaw || hitFromCatalog?.tower}
                />
              )}
            </>
          );
        })()}
      </div>

      {/* DERECHA: TIEMPO + BOTÓN */}
      <div style={{ textAlign: "center", minWidth: 140 }}>
        <div style={{ fontSize: "2rem", fontWeight: "bold" }}>
          {status === "CLOSED" ? "00:00:00" : formatTime(remainingMinutes)}
        </div>

        <button
          disabled={isDisabled}
          onClick={() => window.open(dynatraceUrl, "_blank")}
          style={{
            marginTop: ".5rem",
            padding: ".4rem 1rem",
            fontSize: ".9rem",
            fontWeight: "bold",
            color: "#fff",
            backgroundColor: isDisabled ? "#b0b0b0" : status === "CLOSED" ? "#6b7280" : buttonColor,
            border: "none",
            borderRadius: "8px",
            cursor: isDisabled ? "not-allowed" : "pointer",
          }}
        >
          Revisar problema
        </button>
      </div>
    </div>
  );
}

----

// src/pages/TcsPage.jsx
import React, { useEffect, useMemo, useState } from "react";
import ProblemCard from "../components/ProblemCard";
import { fetchAllProblems } from "../api/problems";

export default function TcsPage() {
  const [username, setUsername] = useState("");
  const [loading, setLoading] = useState(false);
  const [problems, setProblems] = useState([]);

  // filtros (mismo comportamiento de antes)
  const [envFilter, setEnvFilter] = useState("ALL");     // ALL | Productivo | NoProductivo
  const [statusFilter, setStatusFilter] = useState("ALL"); // ALL | OPEN | CLOSED

  async function load() {
    setLoading(true);
    try {
      const data = await fetchAllProblems({
        tcsFilter: true,
        recentDays: 1,     // ✅ ayer -> hoy
        pageSize: 2000,    // ✅ para que entren tus 14 OPEN
        maxPages: 3,       // ✅ rápido
      });
      setProblems(data);
    } catch (e) {
      console.error("Error cargando TCS:", e);
      setProblems([]);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    load();
    const t = setInterval(load, 30000); // ✅ “tiempo real”
    return () => clearInterval(t);
  }, []);

  // conteos SIEMPRE en base a status normalizado
  const counts = useMemo(() => {
    const prod = problems.filter((p) => (p.environment || "").toUpperCase().includes("PRODUCTIVO")).length;
    const noprod = problems.filter((p) => (p.environment || "").toUpperCase().includes("NO")).length;
    const abiertas = problems.filter((p) => (p.status || "").toUpperCase() === "OPEN").length;
    const cerradas = problems.filter((p) => (p.status || "").toUpperCase() === "CLOSED").length;
    return { prod, noprod, abiertas, cerradas, total: problems.length };
  }, [problems]);

  // lista mostrada con filtros
  const visible = useMemo(() => {
    let list = problems;

    if (envFilter === "Productivo") {
      list = list.filter((p) => String(p.environment || "").toUpperCase().includes("PRODUCTIVO"));
    } else if (envFilter === "NoProductivo") {
      list = list.filter((p) => !String(p.environment || "").toUpperCase().includes("PRODUCTIVO"));
    }

    if (statusFilter === "OPEN") list = list.filter((p) => p.status === "OPEN");
    if (statusFilter === "CLOSED") list = list.filter((p) => p.status === "CLOSED");

    return list;
  }, [problems, envFilter, statusFilter]);

  // estilos chips (como antes)
  const chip = (active, bg) => ({
    padding: ".35rem .8rem",
    borderRadius: "999px",
    border: "1px solid #cfcfcf",
    background: active ? bg : "#f3f3f3",
    cursor: "pointer",
    fontWeight: 600,
    marginRight: ".5rem",
  });

  return (
    <div style={{ maxWidth: 980, margin: "0 auto", padding: "2rem 1rem" }}>
      <h1 style={{ textAlign: "center", marginBottom: "1rem" }}>
        Problemas TCS ({counts.total})
      </h1>

      {/* Usuario */}
      <div style={{ textAlign: "center", marginBottom: "1rem" }}>
        <span style={{ marginRight: ".5rem" }}>Usuario:</span>
        <input
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          style={{ padding: ".35rem .5rem", border: "1px solid #bdbdbd" }}
          placeholder="Tu usuario"
        />
      </div>

      {/* Chips filtros */}
      <div style={{ textAlign: "center", marginBottom: "1rem" }}>
        <button
          style={chip(envFilter === "Productivo", "#cfe3ff")}
          onClick={() => setEnvFilter("Productivo")}
        >
          Productivo ({counts.prod})
        </button>

        <button
          style={chip(envFilter === "NoProductivo", "#e9e9e9")}
          onClick={() => setEnvFilter("NoProductivo")}
        >
          No Productivo ({counts.noprod})
        </button>

        <br />
        <br />

        <button
          style={chip(statusFilter === "OPEN", "#ffe89a")}
          onClick={() => setStatusFilter("OPEN")}
        >
          Abiertas ({counts.abiertas})
        </button>

        <button
          style={chip(statusFilter === "CLOSED", "#c8f7d2")}
          onClick={() => setStatusFilter("CLOSED")}
        >
          Cerradas ({counts.cerradas})
        </button>

        <button
          style={chip(statusFilter === "ALL" && envFilter === "ALL", "#ffffff")}
          onClick={() => {
            setEnvFilter("ALL");
            setStatusFilter("ALL");
          }}
        >
          Todos
        </button>
      </div>

      {loading && (
        <div style={{ textAlign: "center", margin: "1rem 0", opacity: 0.8 }}>
          Cargando problemas...
        </div>
      )}

      {/* Cards */}
      <div>
        {visible.map((p) => (
          <ProblemCard key={p.problemId || p.displayId || Math.random()} problem={p} username={username} />
        ))}
      </div>
    </div>
  );
}

----


// src/pages/OtrosPage.jsx
import React, { useEffect, useMemo, useState } from "react";
import ProblemCard from "../components/ProblemCard";
import { fetchAllProblems } from "../api/problems";

export default function OtrosPage() {
  const [username, setUsername] = useState("");
  const [loading, setLoading] = useState(false);
  const [problems, setProblems] = useState([]);

  const [envFilter, setEnvFilter] = useState("ALL");
  const [statusFilter, setStatusFilter] = useState("ALL");

  async function load() {
    setLoading(true);
    try {
      const data = await fetchAllProblems({
        tcsFilter: false,
        recentDays: 1,
        pageSize: 2000,
        maxPages: 3,
      });
      setProblems(data);
    } catch (e) {
      console.error("Error cargando OTROS:", e);
      setProblems([]);
    } finally {
      setLoading(false);
    }
  }

  useEffect(() => {
    load();
    const t = setInterval(load, 30000);
    return () => clearInterval(t);
  }, []);

  const counts = useMemo(() => {
    const prod = problems.filter((p) => (p.environment || "").toUpperCase().includes("PRODUCTIVO")).length;
    const noprod = problems.filter((p) => (p.environment || "").toUpperCase().includes("NO")).length;
    const abiertas = problems.filter((p) => (p.status || "").toUpperCase() === "OPEN").length;
    const cerradas = problems.filter((p) => (p.status || "").toUpperCase() === "CLOSED").length;
    return { prod, noprod, abiertas, cerradas, total: problems.length };
  }, [problems]);

  const visible = useMemo(() => {
    let list = problems;

    if (envFilter === "Productivo") {
      list = list.filter((p) => String(p.environment || "").toUpperCase().includes("PRODUCTIVO"));
    } else if (envFilter === "NoProductivo") {
      list = list.filter((p) => !String(p.environment || "").toUpperCase().includes("PRODUCTIVO"));
    }

    if (statusFilter === "OPEN") list = list.filter((p) => p.status === "OPEN");
    if (statusFilter === "CLOSED") list = list.filter((p) => p.status === "CLOSED");

    return list;
  }, [problems, envFilter, statusFilter]);

  const chip = (active, bg) => ({
    padding: ".35rem .8rem",
    borderRadius: "999px",
    border: "1px solid #cfcfcf",
    background: active ? bg : "#f3f3f3",
    cursor: "pointer",
    fontWeight: 600,
    marginRight: ".5rem",
  });

  return (
    <div style={{ maxWidth: 980, margin: "0 auto", padding: "2rem 1rem" }}>
      <h1 style={{ textAlign: "center", marginBottom: "1rem" }}>
        Problemas Otros ({counts.total})
      </h1>

      <div style={{ textAlign: "center", marginBottom: "1rem" }}>
        <span style={{ marginRight: ".5rem" }}>Usuario:</span>
        <input
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          style={{ padding: ".35rem .5rem", border: "1px solid #bdbdbd" }}
          placeholder="Tu usuario"
        />
      </div>

      <div style={{ textAlign: "center", marginBottom: "1rem" }}>
        <button style={chip(envFilter === "Productivo", "#cfe3ff")} onClick={() => setEnvFilter("Productivo")}>
          Productivo ({counts.prod})
        </button>

        <button style={chip(envFilter === "NoProductivo", "#e9e9e9")} onClick={() => setEnvFilter("NoProductivo")}>
          No Productivo ({counts.noprod})
        </button>

        <br />
        <br />

        <button style={chip(statusFilter === "OPEN", "#ffe89a")} onClick={() => setStatusFilter("OPEN")}>
          Abiertas ({counts.abiertas})
        </button>

        <button style={chip(statusFilter === "CLOSED", "#c8f7d2")} onClick={() => setStatusFilter("CLOSED")}>
          Cerradas ({counts.cerradas})
        </button>

        <button
          style={chip(statusFilter === "ALL" && envFilter === "ALL", "#ffffff")}
          onClick={() => {
            setEnvFilter("ALL");
            setStatusFilter("ALL");
          }}
        >
          Todos
        </button>
      </div>

      {loading && (
        <div style={{ textAlign: "center", margin: "1rem 0", opacity: 0.8 }}>
          Cargando problemas...
        </div>
      )}

      <div>
        {visible.map((p) => (
          <ProblemCard key={p.problemId || p.displayId || Math.random()} problem={p} username={username} />
        ))}
      </div>
    </div>
  );
}