using System.ComponentModel;
using System.Text.Json;
using DynatraceProblemUpdater.Data.Repositories;
using DynatraceProblemUpdater.Data.Sources.CmdbServers;
using DynatraceProblemUpdater.Data.Sources.ML;
using DynatraceProblemUpdater.Models.Config;
using DynatraceProblemUpdater.Models.Dynatrace;
using DynatraceProblemUpdater.Models.ProblemsDB;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Options;
using JsonSerializer = System.Text.Json.JsonSerializer;

namespace DynatraceProblemUpdater.Services
{
    public class Worker : BackgroundService
    {
        private readonly DynatraceProblemRepository _problemRepository;
        private readonly ILogger<Worker> _logger;
        private readonly WorkerSettings _settings;
        private readonly List<APIToken> _apiTokens;
        private readonly HttpClient _httpClient;
        private readonly MLPredictor _predictor;
        private readonly ServerMatcher _serverMatcher;
        private readonly bool _isHistorical;
        private readonly int _timeWaitLoop;

        public Worker(
            ILogger<Worker> logger,
            IOptions<WorkerSettings> settings,
            IOptions<List<APIToken>> apiTokens,
            DynatraceProblemRepository problemRepository,
            ServerMatcher serverMatcher
        )
        {
            _logger = logger;
            _settings = settings.Value;
            _apiTokens = apiTokens.Value;
            _isHistorical = _settings.IsHistorical;

            _timeWaitLoop = _settings.UpdateIntervalSeconds * 1000 * 60 * 24 * 10;

            if (!_isHistorical)
            {
                _apiTokens.RemoveAll(token => token.EndDate != null);
                _timeWaitLoop = _settings.UpdateIntervalSeconds * 1000;
            }

            _problemRepository = problemRepository;
            _httpClient = new HttpClient();
            _httpClient.DefaultRequestHeaders.Clear();
            _httpClient.DefaultRequestHeaders.Add("Accept", "application/json");

            _predictor = new MLPredictor();
            _serverMatcher = serverMatcher;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                var tasks = new List<Task>();

                foreach (var token in _apiTokens)
                {
                    tasks.Add(ProcessDynatraceData(token, stoppingToken));
                }

                await Task.WhenAll(tasks);

                _logger.LogInformation(
                    $"‚úÖ Proceso finalizado. Siguiente actualizaci√≥n en {TimeSpan.FromMilliseconds(_timeWaitLoop).TotalSeconds} segundos");

                await Task.Delay(_timeWaitLoop, stoppingToken);
            }
        }

        private async Task ProcessDynatraceData(APIToken token, CancellationToken stoppingToken)
        {
            if (_isHistorical)
                await LoadHistoricalDatabase(token, stoppingToken);
            else
                await UpdateDatabaseInRealTime(token, stoppingToken);
        }

        private async Task LoadHistoricalDatabase(APIToken token, CancellationToken stoppingToken)
        {
            DateTime startDate = token.StartDate;
            DateTime endDate = token.EndDate ?? DateTime.Now;
            int daysToAdd = 2;

            for (var startTime = startDate; startTime <= endDate; startTime = startTime.AddDays(daysToAdd))
            {
                DateTime endTime = startTime.AddDays(daysToAdd) > endDate ? endDate : startTime.AddDays(daysToAdd);

                var startTimeFilter = startTime.ToString("yyyy-MM-ddTHH:mm:ss");
                var endTimeFilter = endTime.ToString("yyyy-MM-ddTHH:mm:ss");

                var problemsIds = await FetchProblemIdsAsync(token, startTimeFilter, endTimeFilter, stoppingToken);
                List<DBProblem> problems = await FetchProblemByIdsAsync(problemsIds, token, stoppingToken);

                try
                {
                    if (problems.Count > 0)
                    {
                        _logger.LogInformation(
                            "üü¢ Insertando {Count} nuevos problemas del tenant {Tenant} en la BD...",
                            problems.Count, token.Tenant);

                        await _problemRepository.InsertProblemsBatchAsync(problems);

                        _logger.LogInformation(
                            "‚úÖ {Count} problemas del tenant {Tenant} insertados correctamente.",
                            problems.Count, token.Tenant);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(
                        ex,
                        $"‚ùå Error al procesar problemas hist√≥ricos Dynatrace {token.Tenant}");
                }
            }
        }

        // ============================================================
        // üî¥ CAMBIO CLAVE AQU√ç
        // ============================================================
        private async Task UpdateDatabaseInRealTime(APIToken token, CancellationToken stoppingToken)
        {
            // üîπ OPEN actuales en Dynatrace
            var openDynatraceProblems =
                await FetchOpenProblemIdsAsync(token, stoppingToken);

            // üîπ OPEN actualmente guardados en BD
            var openProblemIds =
                await _problemRepository.GetOpenProblemIdsAsync(token.Environment);

            // üîπ Nuevos problemas OPEN
            var newProblemsIds =
                openDynatraceProblems.Except(openProblemIds).ToList();

            // üî¥ CAMBIO: problemas OPEN existentes ‚Üí se refrescan SIEMPRE
            var refreshOpenProblemsIds =
                openDynatraceProblems.Intersect(openProblemIds).ToList();

            // üîπ Problemas que pasaron a CLOSED
            var closedProblemsIds =
                openProblemIds.Except(openDynatraceProblems).ToList();

            // üîπ Volver a pedir TODO a Dynatrace (fuente real)
            var newProblems =
                await FetchProblemByIdsAsync(newProblemsIds, token, stoppingToken);

            var refreshedOpenProblems =
                await FetchProblemByIdsAsync(refreshOpenProblemsIds, token, stoppingToken);

            var closedProblems =
                await FetchProblemByIdsAsync(closedProblemsIds, token, stoppingToken);

            // üîπ Persistencia
            if (newProblems.Count > 0)
            {
                _logger.LogInformation("üü¢ Insertando {Count} nuevos problemas OPEN", newProblems.Count);
                await _problemRepository.InsertProblemsBatchAsync(newProblems);
            }

            // üî¥ CAMBIO: aqu√≠ se actualizan comentarios / evidence / recentComments
            if (refreshedOpenProblems.Count > 0)
            {
                _logger.LogInformation(
                    "üîÑ Refrescando {Count} problemas OPEN (comentarios, evidencia, etc.)",
                    refreshedOpenProblems.Count);

                await _problemRepository.UpdateProblemsBatchAsync(refreshedOpenProblems);
            }

            if (closedProblems.Count > 0)
            {
                _logger.LogInformation("üü° Actualizando {Count} problemas CLOSED", closedProblems.Count);
                await _problemRepository.UpdateProblemsBatchAsync(closedProblems);
            }
        }

        // ============================================================
        // ‚¨áÔ∏è TODO LO DEM√ÅS QUEDA IGUAL
        // ============================================================

        private async Task<List<string>> FetchOpenProblemIdsAsync(APIToken token, CancellationToken stoppingToken)
        {
            var problemIds = new List<string>();
            string? nextPageKey = string.Empty;
            var baseUrl = $"https://{token.Tenant}.live.dynatrace.com/api/v2/problems";
            var pageSize = 500;

            do
            {
                var queryParams = string.IsNullOrEmpty(nextPageKey)
                    ? new Dictionary<string, string?>
                    {
                        { "pageSize", pageSize.ToString() },
                        { "from", "now-3h" },
                        { "problemSelector", "status(\"open\")" }
                    }
                    : new Dictionary<string, string?> { { "nextPageKey", nextPageKey } };

                string url = QueryHelpers.AddQueryString(baseUrl, queryParams);

                var request = new HttpRequestMessage(HttpMethod.Get, url);
                request.Headers.Add("Authorization", $"Api-Token {token.Token}");

                try
                {
                    var response = await _httpClient.SendAsync(request, stoppingToken);
                    if (response.IsSuccessStatusCode)
                    {
                        var jsonResponse = await response.Content.ReadAsStringAsync(stoppingToken);
                        var problemsResponse = JsonSerializer.Deserialize<DynatraceProblemResponse>(jsonResponse);

                        if (problemsResponse?.Problems != null)
                        {
                            problemIds.AddRange(
                                problemsResponse.Problems
                                    .Where(p => p != null)
                                    .Select(p => p.ProblemId));
                        }

                        nextPageKey = problemsResponse?.NextPageKey;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex,
                        $"‚ùå Error obteniendo problemas OPEN Dynatrace {token.Tenant}");
                }

            } while (!string.IsNullOrEmpty(nextPageKey));

            return problemIds;
        }

        private async Task<List<string>> FetchProblemIdsAsync(
            APIToken token, string startTime, string endTime, CancellationToken stoppingToken)
        {
            var problemIds = new List<string>();
            string? nextPageKey = string.Empty;
            var baseUrl = $"https://{token.Tenant}.live.dynatrace.com/api/v2/problems";
            var pageSize = 500;

            do
            {
                var queryParams = string.IsNullOrEmpty(nextPageKey)
                    ? new Dictionary<string, string?>
                    {
                        { "pageSize", pageSize.ToString() },
                        { "from", startTime },
                        { "to", endTime }
                    }
                    : new Dictionary<string, string?> { { "nextPageKey", nextPageKey } };

                string url = QueryHelpers.AddQueryString(baseUrl, queryParams);

                var request = new HttpRequestMessage(HttpMethod.Get, url);
                request.Headers.Add("Authorization", $"Api-Token {token.Token}");

                try
                {
                    var response = await _httpClient.SendAsync(request, stoppingToken);
                    if (response.IsSuccessStatusCode)
                    {
                        var jsonResponse = await response.Content.ReadAsStringAsync(stoppingToken);
                        var problemsResponse = JsonSerializer.Deserialize<DynatraceProblemResponse>(jsonResponse);

                        if (problemsResponse?.Problems != null)
                        {
                            problemIds.AddRange(
                                problemsResponse.Problems
                                    .Where(p => p != null)
                                    .Select(p => p.ProblemId));
                        }

                        nextPageKey = problemsResponse?.NextPageKey;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex,
                        $"‚ùå Error obteniendo problemas Dynatrace {token.Tenant}");
                }

            } while (!string.IsNullOrEmpty(nextPageKey));

            return problemIds;
        }

        private async Task<List<DBProblem>> FetchProblemByIdsAsync(
            List<string> ids, APIToken token, CancellationToken stoppingToken)
        {
            var problems = new List<DynatraceProblem>();
            var baseUrl = $"https://{token.Tenant}.live.dynatrace.com/api/v2/problems";

            foreach (var id in ids)
            {
                string url = $"{baseUrl}/{id}";

                var request = new HttpRequestMessage(HttpMethod.Get, url);
                request.Headers.Add("Authorization", $"Api-Token {token.Token}");

                try
                {
                    using var response = await _httpClient.SendAsync(request, stoppingToken);
                    if (response.IsSuccessStatusCode)
                    {
                        var jsonResponse = await response.Content.ReadAsStringAsync(stoppingToken);
                        var problem = JsonSerializer.Deserialize<DynatraceProblem>(jsonResponse);
                        if (problem != null)
                            problems.Add(problem);
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex,
                        $"‚ùå Error obteniendo problema {id} Dynatrace");
                }
            }

            return await MapToDBProblems(problems, token);
        }

        private async Task<List<DBProblem>> MapToDBProblems(
            List<DynatraceProblem> problems, APIToken token)
        {
            var uniqueDescriptions = problems
                .Select(p => p?.Title)
                .Where(s => !string.IsNullOrWhiteSpace(s))
                .Distinct(StringComparer.OrdinalIgnoreCase)
                .ToList();

            await PredictionCache.UpdateOrStorePredictionsAsync(uniqueDescriptions, _predictor);

            var dbProblems = new List<DBProblem>();

            foreach (var problem in problems)
            {
                if (problem is null) continue;

                var impacted = problem.ImpactedEntities ?? new List<ProblemEntity>();
                var evidence = problem.EvidenceDetails ?? new EvidenceDetails();

                var affectedCI = await _serverMatcher.FindAffectedServersAsync(impacted, evidence);

                var shortDescription = problem.Title ?? string.Empty;

                string jurisdiction = "Unknown";
                float probability = 0f;

                if (!string.IsNullOrWhiteSpace(shortDescription) &&
                    PredictionCache.TryGetPrediction(shortDescription, out bool isTcs, out probability))
                {
                    jurisdiction = isTcs ? "TCS" : "NO TCS";
                }

                dbProblems.Add(new DBProblem(
                    problem,
                    token.Environment,
                    token.Tenant,
                    shortDescription,
                    affectedCI,
                    jurisdiction
                ));
            }

            return dbProblems;
        }
    }
}