using System.ComponentModel;
using System.Text.Json;
using DynatraceProblemUpdater.Data.Repositories;
using DynatraceProblemUpdater.Data.Sources.CmdbServers;
using DynatraceProblemUpdater.Data.Sources.ML;
using DynatraceProblemUpdater.Models.Config;
using DynatraceProblemUpdater.Models.Dynatrace;
using DynatraceProblemUpdater.Models.ProblemsDB;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Options;
using JsonSerializer = System.Text.Json.JsonSerializer;

namespace DynatraceProblemUpdater.Services
{
    public class Worker : BackgroundService
    {
        private readonly DynatraceProblemRepository _problemRepository;
        private readonly ILogger<Worker> _logger;
        private readonly WorkerSettings _settings;
        private readonly List<APIToken> _apiTokens;
        private readonly HttpClient _httpClient;
        private readonly MLPredictor _predictor;
        private readonly ServerMatcher _serverMatcher;
        private readonly bool _isHistorical;
        private readonly int _timeWaitLoop;

        public Worker(
            ILogger<Worker> logger,
            IOptions<WorkerSettings> settings,
            IOptions<List<APIToken>> apiTokens,
            DynatraceProblemRepository problemRepository,
            ServerMatcher serverMatcher
        )
        {
            _logger = logger;
            _settings = settings.Value;
            _apiTokens = apiTokens.Value;
            _problemRepository = problemRepository;
            _serverMatcher = serverMatcher;

            _isHistorical = _settings.IsHistorical;
            _timeWaitLoop = _settings.UpdateIntervalSeconds * 1000;

            if (!_isHistorical)
                _apiTokens.RemoveAll(t => t.EndDate != null);

            _httpClient = new HttpClient();
            _httpClient.DefaultRequestHeaders.Add("Accept", "application/json");

            _predictor = new MLPredictor();
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                var tasks = _apiTokens
                    .Select(token => ProcessDynatraceData(token, stoppingToken))
                    .ToList();

                await Task.WhenAll(tasks);

                _logger.LogInformation("‚úÖ Actualizaci√≥n completada. Pr√≥xima en {Seconds}s",
                    TimeSpan.FromMilliseconds(_timeWaitLoop).TotalSeconds);

                await Task.Delay(_timeWaitLoop, stoppingToken);
            }
        }

        private async Task ProcessDynatraceData(APIToken token, CancellationToken stoppingToken)
        {
            if (_isHistorical)
                await LoadHistoricalDatabase(token, stoppingToken);
            else
                await UpdateDatabaseInRealTime(token, stoppingToken);
        }

        // ==========================================================
        // üî¥ CAMBIO CLAVE EST√Å AQU√ç
        // ==========================================================
        private async Task UpdateDatabaseInRealTime(APIToken token, CancellationToken stoppingToken)
        {
            // üîπ 1) OPEN en Dynatrace
            var openDynatraceIds = await FetchOpenProblemIdsAsync(token, stoppingToken);

            // üîπ 2) OPEN en Base de Datos
            var openDbIds = await _problemRepository.GetOpenProblemIdsAsync(token.Environment);

            // üîπ 3) Clasificaci√≥n correcta
            var newOpenIds = openDynatraceIds.Except(openDbIds).ToList();          // nuevos
            var existingOpenIds = openDynatraceIds.Intersect(openDbIds).ToList(); // üî¥ refrescar
            var closedIds = openDbIds.Except(openDynatraceIds).ToList();           // cerrados

            // üîπ 4) Volver a pedir a Dynatrace (SIEMPRE)
            var newOpenProblems = await FetchProblemByIdsAsync(newOpenIds, token, stoppingToken);
            var refreshedOpenProblems = await FetchProblemByIdsAsync(existingOpenIds, token, stoppingToken);
            var closedProblems = await FetchProblemByIdsAsync(closedIds, token, stoppingToken);

            // üîπ 5) Persistencia
            if (newOpenProblems.Any())
                await _problemRepository.InsertProblemsBatchAsync(newOpenProblems);

            if (refreshedOpenProblems.Any())
                await _problemRepository.UpdateProblemsBatchAsync(refreshedOpenProblems);

            if (closedProblems.Any())
                await _problemRepository.UpdateProblemsBatchAsync(closedProblems);
        }

        // ==========================================================
        // üîΩ TODO LO DEM√ÅS SE MANTIENE IGUAL
        // ==========================================================

        private async Task<List<string>> FetchOpenProblemIdsAsync(APIToken token, CancellationToken stoppingToken)
        {
            var ids = new List<string>();
            string? nextPageKey = null;
            var baseUrl = $"https://{token.Tenant}.live.dynatrace.com/api/v2/problems";

            do
            {
                var query = nextPageKey == null
                    ? new Dictionary<string, string?>
                    {
                        { "pageSize", "500" },
                        { "from", "now-3h" },
                        { "problemSelector", "status(\"open\")" }
                    }
                    : new Dictionary<string, string?> { { "nextPageKey", nextPageKey } };

                var url = QueryHelpers.AddQueryString(baseUrl, query);
                var req = new HttpRequestMessage(HttpMethod.Get, url);
                req.Headers.Add("Authorization", $"Api-Token {token.Token}");

                var res = await _httpClient.SendAsync(req, stoppingToken);
                if (!res.IsSuccessStatusCode) break;

                var json = await res.Content.ReadAsStringAsync(stoppingToken);
                var data = JsonSerializer.Deserialize<DynatraceProblemResponse>(json);

                if (data?.Problems != null)
                    ids.AddRange(data.Problems.Select(p => p.ProblemId));

                nextPageKey = data?.NextPageKey;

            } while (!string.IsNullOrEmpty(nextPageKey));

            return ids;
        }

        private async Task<List<DBProblem>> FetchProblemByIdsAsync(
            List<string> ids,
            APIToken token,
            CancellationToken stoppingToken)
        {
            var problems = new List<DynatraceProblem>();
            var baseUrl = $"https://{token.Tenant}.live.dynatrace.com/api/v2/problems";

            foreach (var id in ids)
            {
                var req = new HttpRequestMessage(HttpMethod.Get, $"{baseUrl}/{id}");
                req.Headers.Add("Authorization", $"Api-Token {token.Token}");

                var res = await _httpClient.SendAsync(req, stoppingToken);
                if (!res.IsSuccessStatusCode) continue;

                var json = await res.Content.ReadAsStringAsync(stoppingToken);
                var problem = JsonSerializer.Deserialize<DynatraceProblem>(json);

                if (problem != null)
                    problems.Add(problem);
            }

            return await MapToDBProblems(problems, token);
        }

        private async Task<List<DBProblem>> MapToDBProblems(List<DynatraceProblem> problems, APIToken token)
        {
            var dbProblems = new List<DBProblem>();

            foreach (var p in problems)
            {
                var affectedCI = await _serverMatcher.FindAffectedServersAsync(
                    p.ImpactedEntities ?? new(),
                    p.EvidenceDetails ?? new()
                );

                string jurisdiction = "Unknown";
                if (PredictionCache.TryGetPrediction(p.Title, out bool isTcs, out _))
                    jurisdiction = isTcs ? "TCS" : "NO TCS";

                dbProblems.Add(new DBProblem(
                    p,
                    token.Environment,
                    token.Tenant,
                    p.Title ?? "",
                    affectedCI,
                    jurisdiction
                ));
            }

            return dbProblems;
        }
    }
}