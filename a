using System.ComponentModel;
using System.Text.Json;
using DynatraceProblemUpdater.Data.Repositories;
using DynatraceProblemUpdater.Data.Sources.CmdbServers;
using DynatraceProblemUpdater.Data.Sources.ML;
using DynatraceProblemUpdater.Models.Config;
using DynatraceProblemUpdater.Models.Dynatrace;
using DynatraceProblemUpdater.Models.ProblemsDB;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Options;
using JsonSerializer = System.Text.Json.JsonSerializer;

namespace DynatraceProblemUpdater.Services
{
    public class Worker : BackgroundService
    {
        private readonly DynatraceProblemRepository _problemRepository;
        private readonly ILogger<Worker> _logger;
        private readonly WorkerSettings _settings;
        private readonly List<APIToken> _apiTokens;
        private readonly HttpClient _httpClient;
        private readonly MLPredictor _predictor;
        private readonly ServerMatcher _serverMatcher;
        private readonly bool _isHistorical;
        private readonly int _timeWaitLoop;

        public Worker(
            ILogger<Worker> logger,
            IOptions<WorkerSettings> settings,
            IOptions<List<APIToken>> apiTokens,
            DynatraceProblemRepository problemRepository,
            ServerMatcher serverMatcher
        )
        {
            _logger = logger;
            _settings = settings.Value;
            _apiTokens = apiTokens.Value;
            _isHistorical = _settings.IsHistorical;

            _timeWaitLoop = _settings.UpdateIntervalSeconds * 1000 * 60 * 24 * 10;
            if (!_isHistorical)
            {
                _apiTokens.RemoveAll(token => token.EndDate != null);
                _timeWaitLoop = _settings.UpdateIntervalSeconds * 1000;
            }

            _problemRepository = problemRepository;
            _httpClient = new HttpClient();
            _httpClient.DefaultRequestHeaders.Add("Accept", "application/json");
            _predictor = new MLPredictor();
            _serverMatcher = serverMatcher;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("üöÄ Worker Dynatrace iniciado correctamente");

            while (!stoppingToken.IsCancellationRequested)
            {
                var tasks = new List<Task>();

                foreach (var token in _apiTokens)
                {
                    _logger.LogInformation(
                        "üîë Procesando Tenant: {Tenant} | Ambiente: {Env}",
                        token.Tenant,
                        token.Environment
                    );

                    tasks.Add(ProcessDynatraceData(token, stoppingToken));
                }

                await Task.WhenAll(tasks);

                _logger.LogInformation(
                    "‚è≥ Ciclo finalizado. Pr√≥xima ejecuci√≥n en {Seconds} segundos",
                    TimeSpan.FromMilliseconds(_timeWaitLoop).TotalSeconds
                );

                await Task.Delay(_timeWaitLoop, stoppingToken);
            }
        }

        private async Task ProcessDynatraceData(APIToken token, CancellationToken stoppingToken)
        {
            if (_isHistorical)
            {
                _logger.LogInformation("üìö Modo hist√≥rico activo");
                await LoadHistoricalDatabase(token, stoppingToken);
            }
            else
            {
                _logger.LogInformation("‚ö° Modo tiempo real activo");
                await UpdateDatabaseInRealTime(token, stoppingToken);
            }
        }

        private async Task UpdateDatabaseInRealTime(APIToken token, CancellationToken stoppingToken)
        {
            _logger.LogInformation("üîç Consultando problemas OPEN en Dynatrace...");

            var openDynatraceIds = await FetchOpenProblemIdsAsync(token, stoppingToken);
            var openDbIds = await _problemRepository.GetOpenProblemIdsAsync(token.Environment);

            var newIds = openDynatraceIds.Except(openDbIds).ToList();
            var closedIds = openDbIds.Except(openDynatraceIds).ToList();

            // üî¥ NUEVO: refrescar OPEN existentes
            var refreshOpenIds = openDynatraceIds.Intersect(openDbIds).ToList();

            _logger.LogInformation(
                "üìä Resumen: Nuevos={New} | Cerrados={Closed} | Abiertos a refrescar={Refresh}",
                newIds.Count,
                closedIds.Count,
                refreshOpenIds.Count
            );

            var newProblems = await FetchProblemByIdsAsync(newIds, token, stoppingToken);
            var closedProblems = await FetchProblemByIdsAsync(closedIds, token, stoppingToken);
            var refreshedOpenProblems = await FetchProblemByIdsAsync(refreshOpenIds, token, stoppingToken);

            await UpdateProblemDatabase(newProblems, closedProblems, refreshedOpenProblems);
        }

        private async Task<List<string>> FetchOpenProblemIdsAsync(APIToken token, CancellationToken stoppingToken)
        {
            var problemIds = new List<string>();
            string? nextPageKey = null;
            var baseUrl = $"https://{token.Tenant}.live.dynatrace.com/api/v2/problems";

            do
            {
                var queryParams = string.IsNullOrEmpty(nextPageKey)
                    ? new Dictionary<string, string?>
                    {
                        { "pageSize", "500" },
                        { "from", "now-3h" },
                        { "problemSelector", "status(\"open\")" }
                    }
                    : new Dictionary<string, string?>
                    {
                        { "nextPageKey", nextPageKey }
                    };

                var url = QueryHelpers.AddQueryString(baseUrl, queryParams);
                var request = new HttpRequestMessage(HttpMethod.Get, url);
                request.Headers.Add("Authorization", $"Api-Token {token.Token}");

                var response = await _httpClient.SendAsync(request, stoppingToken);
                if (!response.IsSuccessStatusCode) break;

                var json = await response.Content.ReadAsStringAsync(stoppingToken);
                var result = JsonSerializer.Deserialize<DynatraceProblemResponse>(json);

                if (result?.Problems != null)
                    problemIds.AddRange(result.Problems.Select(p => p.ProblemId));

                nextPageKey = result?.NextPageKey;

            } while (!string.IsNullOrEmpty(nextPageKey));

            _logger.LogInformation("üì• Dynatrace retorn√≥ {Count} problemas OPEN", problemIds.Count);
            return problemIds;
        }

        private async Task<List<DBProblem>> FetchProblemByIdsAsync(
            List<string> ids,
            APIToken token,
            CancellationToken stoppingToken
        )
        {
            var problems = new List<DynatraceProblem>();
            var baseUrl = $"https://{token.Tenant}.live.dynatrace.com/api/v2/problems";

            foreach (var id in ids)
            {
                var request = new HttpRequestMessage(HttpMethod.Get, $"{baseUrl}/{id}");
                request.Headers.Add("Authorization", $"Api-Token {token.Token}");

                var response = await _httpClient.SendAsync(request, stoppingToken);
                if (!response.IsSuccessStatusCode) continue;

                var json = await response.Content.ReadAsStringAsync(stoppingToken);
                var problem = JsonSerializer.Deserialize<DynatraceProblem>(json);

                if (problem != null)
                    problems.Add(problem);
            }

            return await MapToDBProblems(problems, token);
        }

        private async Task<List<DBProblem>> MapToDBProblems(List<DynatraceProblem> problems, APIToken token)
        {
            var dbProblems = new List<DBProblem>();

            foreach (var problem in problems)
            {
                var affectedCI = await _serverMatcher.FindAffectedServersAsync(
                    problem.ImpactedEntities ?? new(),
                    problem.EvidenceDetails ?? new()
                );

                var shortDescription = problem.Title ?? "";
                string jurisdiction = "Unknown";

                if (PredictionCache.TryGetPrediction(shortDescription, out bool isTcs, out _))
                    jurisdiction = isTcs ? "TCS" : "NO TCS";

                dbProblems.Add(new DBProblem(
                    problem,
                    token.Environment,
                    token.Tenant,
                    shortDescription,
                    affectedCI,
                    jurisdiction
                ));
            }

            return dbProblems;
        }

        private async Task UpdateProblemDatabase(
            List<DBProblem> newProblems,
            List<DBProblem> closedProblems,
            List<DBProblem> refreshedOpenProblems
        )
        {
            try
            {
                if (newProblems.Count > 0)
                {
                    _logger.LogInformation("üü¢ INSERTANDO {Count} nuevas alertas", newProblems.Count);
                    await _problemRepository.InsertProblemsBatchAsync(newProblems);
                }

                if (closedProblems.Count > 0)
                {
                    _logger.LogInformation("üü° CERRANDO {Count} alertas", closedProblems.Count);
                    await _problemRepository.UpdateProblemsBatchAsync(closedProblems);
                }

                if (refreshedOpenProblems.Count > 0)
                {
                    _logger.LogInformation(
                        "üîÑ ACTUALIZANDO {Count} alertas abiertas (comentarios/evidencia)",
                        refreshedOpenProblems.Count
                    );
                    await _problemRepository.UpdateProblemsBatchAsync(refreshedOpenProblems);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Error procesando datos Dynatrace");
            }
        }
    }
}