using System.ComponentModel;
using System.Text.Json;
using DynatraceProblemUpdater.Data.Repositories;
using DynatraceProblemUpdater.Data.Sources.CmdbServers;
using DynatraceProblemUpdater.Data.Sources.ML;
using DynatraceProblemUpdater.Models.Config;
using DynatraceProblemUpdater.Models.Dynatrace;
using DynatraceProblemUpdater.Models.ProblemsDB;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Options;
using JsonSerializer = System.Text.Json.JsonSerializer;

namespace DynatraceProblemUpdater.Services
{
    public class Worker : BackgroundService
    {
        private readonly DynatraceProblemRepository _problemRepository;
        private readonly ILogger<Worker> _logger;
        private readonly WorkerSettings _settings;
        private readonly List<APIToken> _apiTokens;
        private readonly HttpClient _httpClient;
        private readonly MLPredictor _predictor;
        private readonly ServerMatcher _serverMatcher;
        private readonly bool _isHistorical;
        private readonly int _timeWaitLoop;

        public Worker(
            ILogger<Worker> logger, 
            IOptions<WorkerSettings> settings,
            IOptions<List<APIToken>> apiTokens,
            DynatraceProblemRepository problemRepository,
            ServerMatcher serverMatcher
        )
        {
            _logger = logger;
            _settings = settings.Value;
            _apiTokens = apiTokens.Value;
            _isHistorical = _settings.IsHistorical;
            _timeWaitLoop = _settings.UpdateIntervalSeconds * 1000 * 60 * 24 * 10;

            if (!_isHistorical)
            {
                _apiTokens.RemoveAll(token => token.EndDate != null);
                _timeWaitLoop = _settings.UpdateIntervalSeconds * 1000;
            }

            _problemRepository = problemRepository;
            _httpClient = new HttpClient();
            _httpClient.DefaultRequestHeaders.Clear();
            _httpClient.DefaultRequestHeaders.Add("Accept", "application/json");
            _predictor = new MLPredictor(); 
            _serverMatcher = serverMatcher;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                var tasks = new List<Task>();

                foreach (var token in _apiTokens)
                {
                    tasks.Add(ProcessDynatraceData(token, stoppingToken));
                }

                await Task.WhenAll(tasks);

                _logger.LogInformation(
                    $"‚úÖ Proceso finalizado. Siguiente actualizaci√≥n en {TimeSpan.FromMilliseconds(_timeWaitLoop).TotalSeconds} segundos");

                await Task.Delay(_timeWaitLoop, stoppingToken);
            }
        }

        private async Task ProcessDynatraceData(APIToken token, CancellationToken stoppingToken)
        {
            if (_isHistorical)
                await LoadHistoricalDatabase(token, stoppingToken);
            else
                await UpdateDatabaseInRealTime(token, stoppingToken);
        }

        // ============================================================
        // üî¥ CAMBIO CLAVE: refrescar PROBLEMAS OPEN existentes
        // ============================================================
        private async Task UpdateDatabaseInRealTime(APIToken token, CancellationToken stoppingToken)
        {
            // 1Ô∏è‚É£ OPEN actuales en Dynatrace
            var openDynatraceProblems = await FetchOpenProblemIdsAsync(token, stoppingToken);

            // 2Ô∏è‚É£ OPEN actuales en BD
            var openProblemIds = await _problemRepository.GetOpenProblemIdsAsync(token.Environment);

            // 3Ô∏è‚É£ Nuevos OPEN (no existen en BD)
            var newProblemsIds = openDynatraceProblems
                .Except(openProblemIds)
                .ToList();

            // 4Ô∏è‚É£ OPEN existentes ‚Üí üî¥ SE REFRESCAN SIEMPRE (comentarios, evidencia, etc.)
            var refreshProblemsIds = openDynatraceProblems
                .Intersect(openProblemIds)
                .ToList();

            // 5Ô∏è‚É£ CLOSED (ya no est√°n en Dynatrace)
            var closedProblemsIds = openProblemIds
                .Except(openDynatraceProblems)
                .ToList();

            // 6Ô∏è‚É£ Volver a pedir a Dynatrace (FUENTE DE VERDAD)
            List<DBProblem> newProblems =
                await FetchProblemByIdsAsync(newProblemsIds, token, stoppingToken);

            List<DBProblem> refreshedOpenProblems =
                await FetchProblemByIdsAsync(refreshProblemsIds, token, stoppingToken);

            List<DBProblem> closedProblems =
                await FetchProblemByIdsAsync(closedProblemsIds, token, stoppingToken);

            // 7Ô∏è‚É£ Persistencia
            if (newProblems.Count > 0)
            {
                _logger.LogInformation("üü¢ Insertando {Count} nuevos problemas OPEN", newProblems.Count);
                await _problemRepository.InsertProblemsBatchAsync(newProblems);
            }

            if (refreshedOpenProblems.Count > 0)
            {
                _logger.LogInformation("üîÑ Refrescando {Count} problemas OPEN (comentarios, evidencia, etc.)",
                    refreshedOpenProblems.Count);

                await _problemRepository.UpdateProblemsBatchAsync(refreshedOpenProblems);
            }

            if (closedProblems.Count > 0)
            {
                _logger.LogInformation("üü° Actualizando {Count} problemas CLOSED", closedProblems.Count);
                await _problemRepository.UpdateProblemsBatchAsync(closedProblems);
            }
        }

        // ============================================================
        // ‚¨áÔ∏è TODO LO DEM√ÅS QUEDA EXACTAMENTE IGUAL
        // ============================================================

        // FetchOpenProblemIdsAsync(...)
        // FetchProblemIdsAsync(...)
        // FetchProblemByIdsAsync(...)
        // MapToDBProblems(...)
        // UpdateProblemDatabase(...)
        // (sin cambios)
    }
}