using System.ComponentModel;
using System.Text.Json;
using DynatraceProblemUpdater.Data.Repositories;
using DynatraceProblemUpdater.Data.Sources.CmdbServers;
using DynatraceProblemUpdater.Data.Sources.ML;
using DynatraceProblemUpdater.Models.Config;
using DynatraceProblemUpdater.Models.Dynatrace;
using DynatraceProblemUpdater.Models.ProblemsDB;
using Microsoft.AspNetCore.WebUtilities;
using Microsoft.Extensions.Options;
using JsonSerializer = System.Text.Json.JsonSerializer;

namespace DynatraceProblemUpdater.Services
{
    public class Worker : BackgroundService
    {
        private readonly DynatraceProblemRepository _problemRepository;
        private readonly ILogger<Worker> _logger;
        private readonly WorkerSettings _settings;
        private readonly List<APIToken> _apiTokens;
        private readonly HttpClient _httpClient;
        private readonly MLPredictor _predictor;
        private readonly ServerMatcher _serverMatcher;
        private readonly bool _isHistorical;
        private readonly int _timeWaitLoop;

        public Worker(
            ILogger<Worker> logger,
            IOptions<WorkerSettings> settings,
            IOptions<List<APIToken>> apiTokens,
            DynatraceProblemRepository problemRepository,
            ServerMatcher serverMatcher
        )
        {
            _logger = logger;
            _settings = settings.Value;
            _apiTokens = apiTokens.Value;
            _isHistorical = _settings.IsHistorical;

            _timeWaitLoop = _settings.UpdateIntervalSeconds * 1000 * 60 * 24 * 10;
            if (!_isHistorical)
            {
                _apiTokens.RemoveAll(token => token.EndDate != null);
                _timeWaitLoop = _settings.UpdateIntervalSeconds * 1000;
            }

            _problemRepository = problemRepository;
            _httpClient = new HttpClient();
            _httpClient.DefaultRequestHeaders.Clear();
            _httpClient.DefaultRequestHeaders.Add("Accept", "application/json");
            _predictor = new MLPredictor();
            _serverMatcher = serverMatcher;
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            while (!stoppingToken.IsCancellationRequested)
            {
                var tasks = new List<Task>();

                foreach (var token in _apiTokens)
                {
                    tasks.Add(ProcessDynatraceData(token, stoppingToken));
                }

                await Task.WhenAll(tasks);

                _logger.LogInformation(
                    "‚úÖ Proceso finalizado. Siguiente actualizaci√≥n en {Seconds} segundos",
                    TimeSpan.FromMilliseconds(_timeWaitLoop).TotalSeconds
                );

                await Task.Delay(_timeWaitLoop, stoppingToken);
            }
        }

        private async Task ProcessDynatraceData(APIToken token, CancellationToken stoppingToken)
        {
            if (_isHistorical)
            {
                await LoadHistoricalDatabase(token, stoppingToken);
            }
            else
            {
                await UpdateDatabaseInRealTime(token, stoppingToken);
            }
        }

        private async Task LoadHistoricalDatabase(APIToken token, CancellationToken stoppingToken)
        {
            DateTime startDate = token.StartDate;
            DateTime endDate = token.EndDate ?? DateTime.Now;
            int daysToAdd = 2;

            for (var startTime = startDate; startTime <= endDate; startTime = startTime.AddDays(daysToAdd))
            {
                DateTime endTime = startTime.AddDays(daysToAdd) > endDate
                    ? endDate
                    : startTime.AddDays(daysToAdd);

                var startTimeFilter = startTime.ToString("yyyy-MM-ddTHH:mm:ss");
                var endTimeFilter = endTime.ToString("yyyy-MM-ddTHH:mm:ss");

                var problemsIds = await FetchProblemIdsAsync(token, startTimeFilter, endTimeFilter, stoppingToken);
                List<DBProblem> problems = await FetchProblemByIdsAsync(problemsIds, token, stoppingToken);

                if (problems.Count > 0)
                {
                    _logger.LogInformation(
                        "üü¢ Insertando {Count} problemas hist√≥ricos del tenant {Tenant}",
                        problems.Count,
                        token.Tenant
                    );

                    await _problemRepository.InsertProblemsBatchAsync(problems);
                }
            }
        }

        private async Task UpdateDatabaseInRealTime(APIToken token, CancellationToken stoppingToken)
        {
            _logger.LogInformation("üîç Consultando problemas OPEN en Dynatrace...");

            var openDynatraceIds = await FetchOpenProblemIdsAsync(token, stoppingToken);
            var openDbIds = await _problemRepository.GetOpenProblemIdsAsync(token.Environment);

            var newProblemsIds = openDynatraceIds.Except(openDbIds).ToList();
            var closedProblemsIds = openDbIds.Except(openDynatraceIds).ToList();

            // üîÑ NUEVO: OPEN que siguen abiertos pero pueden tener comentarios nuevos
            var openToRefreshIds = openDynatraceIds.Intersect(openDbIds).ToList();

            _logger.LogInformation(
                "üìä Resumen Dynatrace ‚Üí Nuevos={New}, Cerrados={Closed}, Abiertos a refrescar={Refresh}",
                newProblemsIds.Count,
                closedProblemsIds.Count,
                openToRefreshIds.Count
            );

            var newProblems = await FetchProblemByIdsAsync(newProblemsIds, token, stoppingToken);
            var closedProblems = await FetchProblemByIdsAsync(closedProblemsIds, token, stoppingToken);
            var refreshedOpenProblems = await FetchProblemByIdsAsync(openToRefreshIds, token, stoppingToken);

            await UpdateProblemDatabase(newProblems, closedProblems, refreshedOpenProblems);
        }

        private async Task<List<string>> FetchOpenProblemIdsAsync(APIToken token, CancellationToken stoppingToken)
        {
            var problemIds = new List<string>();
            string? nextPageKey = null;
            var baseUrl = $"https://{token.Tenant}.live.dynatrace.com/api/v2/problems";

            do
            {
                var queryParams = string.IsNullOrEmpty(nextPageKey)
                    ? new Dictionary<string, string?>
                    {
                        { "pageSize", "500" },
                        { "from", "now-3h" },
                        { "problemSelector", "status(\"open\")" }
                    }
                    : new Dictionary<string, string?>
                    {
                        { "nextPageKey", nextPageKey }
                    };

                var url = QueryHelpers.AddQueryString(baseUrl, queryParams);
                var request = new HttpRequestMessage(HttpMethod.Get, url);
                request.Headers.Add("Authorization", $"Api-Token {token.Token}");

                var response = await _httpClient.SendAsync(request, stoppingToken);
                if (!response.IsSuccessStatusCode) break;

                var json = await response.Content.ReadAsStringAsync(stoppingToken);
                var result = JsonSerializer.Deserialize<DynatraceProblemResponse>(json);

                if (result?.Problems != null)
                {
                    problemIds.AddRange(result.Problems.Select(p => p.ProblemId));
                }

                nextPageKey = result?.NextPageKey;

            } while (!string.IsNullOrEmpty(nextPageKey));

            return problemIds;
        }

        private async Task<List<string>> FetchProblemIdsAsync(
            APIToken token,
            string startTime,
            string endTime,
            CancellationToken stoppingToken
        )
        {
            var problemIds = new List<string>();
            string? nextPageKey = null;
            var baseUrl = $"https://{token.Tenant}.live.dynatrace.com/api/v2/problems";

            do
            {
                var queryParams = string.IsNullOrEmpty(nextPageKey)
                    ? new Dictionary<string, string?>
                    {
                        { "pageSize", "500" },
                        { "from", startTime },
                        { "to", endTime }
                    }
                    : new Dictionary<string, string?>
                    {
                        { "nextPageKey", nextPageKey }
                    };

                var url = QueryHelpers.AddQueryString(baseUrl, queryParams);
                var request = new HttpRequestMessage(HttpMethod.Get, url);
                request.Headers.Add("Authorization", $"Api-Token {token.Token}");

                var response = await _httpClient.SendAsync(request, stoppingToken);
                if (!response.IsSuccessStatusCode) break;

                var json = await response.Content.ReadAsStringAsync(stoppingToken);
                var result = JsonSerializer.Deserialize<DynatraceProblemResponse>(json);

                if (result?.Problems != null)
                {
                    problemIds.AddRange(result.Problems.Select(p => p.ProblemId));
                }

                nextPageKey = result?.NextPageKey;

            } while (!string.IsNullOrEmpty(nextPageKey));

            return problemIds;
        }

        private async Task<List<DBProblem>> FetchProblemByIdsAsync(
            List<string> ids,
            APIToken token,
            CancellationToken stoppingToken
        )
        {
            var problems = new List<DynatraceProblem>();
            var baseUrl = $"https://{token.Tenant}.live.dynatrace.com/api/v2/problems";

            foreach (var id in ids)
            {
                var request = new HttpRequestMessage(HttpMethod.Get, $"{baseUrl}/{id}");
                request.Headers.Add("Authorization", $"Api-Token {token.Token}");

                var response = await _httpClient.SendAsync(request, stoppingToken);
                if (!response.IsSuccessStatusCode) continue;

                var json = await response.Content.ReadAsStringAsync(stoppingToken);
                var problem = JsonSerializer.Deserialize<DynatraceProblem>(json);

                if (problem != null)
                {
                    problems.Add(problem);
                }
            }

            return await MapToDBProblems(problems, token);
        }

        private async Task<List<DBProblem>> MapToDBProblems(List<DynatraceProblem> problems, APIToken token)
        {
            var dbProblems = new List<DBProblem>();

            foreach (var problem in problems)
            {
                var affectedCI = await _serverMatcher.FindAffectedServersAsync(
                    problem.ImpactedEntities ?? new(),
                    problem.EvidenceDetails ?? new()
                );

                var shortDescription = problem.Title ?? string.Empty;
                string jurisdiction = "Unknown";

                if (PredictionCache.TryGetPrediction(shortDescription, out bool isTcs, out _))
                {
                    jurisdiction = isTcs ? "TCS" : "NO TCS";
                }

                dbProblems.Add(new DBProblem(
                    problem,
                    token.Environment,
                    token.Tenant,
                    shortDescription,
                    affectedCI,
                    jurisdiction
                ));
            }

            return dbProblems;
        }

        // üîÑ CAMBIO REAL AQU√ç
        private async Task UpdateProblemDatabase(
            List<DBProblem> newProblems,
            List<DBProblem> closedProblems,
            List<DBProblem> refreshedOpenProblems
        )
        {
            try
            {
                if (newProblems.Count > 0)
                {
                    _logger.LogInformation("üü¢ Insertando {Count} nuevos problemas en la BD...", newProblems.Count);
                    await _problemRepository.InsertProblemsBatchAsync(newProblems);
                }

                if (closedProblems.Count > 0)
                {
                    _logger.LogInformation("üü° Actualizando {Count} problemas cerrados en la BD...", closedProblems.Count);
                    await _problemRepository.UpdateProblemsBatchAsync(closedProblems);
                }

                if (refreshedOpenProblems.Count > 0)
                {
                    _logger.LogInformation(
                        "üîÑ Actualizando {Count} alertas abiertas (comentarios / evidencia)",
                        refreshedOpenProblems.Count
                    );
                    await _problemRepository.UpdateProblemsBatchAsync(refreshedOpenProblems);
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "‚ùå Error al procesar los problemas de Dynatrace.");
            }
        }
    }
}