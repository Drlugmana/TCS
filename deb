// --- SLA (sin cambios) ---
export function getSlaMinutes(criticidad) {
  switch (criticidad) {
    case 'S1': return 10;
    case 'S2': return 30;
    case 'S3': return 45;
    default:   return 120; // S4
  }
}

// --- Helpers de color (si ya los tienes, deja los tuyos) ---
export function getColorByPercent(percent) {
  if (percent > 75) return '#ffffff';
  if (percent > 50) return '#fff9c4';
  if (percent > 25) return '#ffe082';
  return '#ef9a9a';
}
export function getButtonColorByPercent(percent) {
  if (percent > 75) return '#1565c0';
  if (percent > 50) return '#fbc02d';
  if (percent > 25) return '#fb8c00';
  return '#d32f2f';
}

// ------------------ CRITICIDAD ------------------

const rank = { S1: 0, S2: 1, S3: 2, S4: 3 };
const peor = (a, b) => (rank[a] < rank[b] ? a : b);

// 1) Mapea letra A–E de cadenas como "C - BIA Crítica" a S1..S4
function letraBIAaSx(str) {
  if (!str) return null;
  const v = String(str).trim().toUpperCase();

  // Busca una letra A-E al inicio o antes de guión/espacio: "A - ...", "B) ...", "C ...", etc.
  const m = v.match(/^\s*([A-E])(?:\s*[-) ]|$)/);
  if (m) {
    const L = m[1];
    if (L === 'A') return 'S1';
    if (L === 'B') return 'S2';
    if (L === 'C') return 'S3';
    // D y E son S4 según tu documento
    return 'S4';
  }
  return null;
}

// 2) Mapea severidades "humanas" SOLO cuando son etiquetas estándar
function textoSeveridadASx(str) {
  if (!str) return null;
  const v = String(str).trim().toUpperCase();

  // Evita confundir "BIA CRÍTICA" con "CRITICAL"
  if (/\bCRITICAL\b/.test(v)) return 'S1';
  if (/\bHIGH\b|\bALTA\b/.test(v)) return 'S2';
  if (/\bMEDIUM\b|\bMEDIA\b/.test(v)) return 'S3';
  if (/\bLOW\b|\bBAJA\b/.test(v)) return 'S4';

  return null;
}

// 3) Normaliza una fuente cualquiera a Sx (usa letra BIA si existe)
export function normalizarCriticidad(valor) {
  if (valor == null) return 'S4';
  // Primero, intenta extraer la letra BIA (A–E) si la cadena la trae
  const viaLetra = letraBIAaSx(valor);
  if (viaLetra) return viaLetra;

  const v = String(valor).trim().toUpperCase();

  // Directo S1..S4
  if (/^S[1-4]$/.test(v)) return v;

  // Una sola letra "A|B|C" aislada
  if (v === 'A') return 'S1';
  if (v === 'B') return 'S2';
  if (v === 'C') return 'S3';

  // Severidades estándar (evita mapear "CRITICA" por BIA)
  const sev = textoSeveridadASx(v);
  if (sev) return sev;

  return 'S4';
}

// Detecta EnP / No Productivo (flexible a variantes)
function esNoProductivo(env) {
  if (!env) return false;
  const e = String(env).toUpperCase();
  return (
    e.includes('ENP') ||
    e.includes('NO PRODUCT') ||
    e.includes('NON PROD') ||
    e.includes('NPRD') ||
    e.includes('NP')
  );
}

/**
 * Devuelve:
 *  - criticidad: 'S1'|'S2'|'S3'|'S4'
 *  - fuente: 'ENP'|'CI'|'SEVERITY/IMPACT'|'DEFAULT'
 *  - detalles: { ... }
 */
export function calcularCriticidadDetallada(problem) {
  // Regla 0: En Entorno no Productivo todo es S4
  const env = problem?.environment || problem?.entorno;
  if (esNoProductivo(env)) {
    return { criticidad: 'S4', fuente: 'ENP', detalles: { environment: env } };
  }

  // Regla 1: de las CIs afectadas, tomar la peor criticidad
  const affected = Array.isArray(problem?.affectedCI) ? problem.affectedCI : [];
  let worstFromCI = 'S4';
  let tuvoCI = false;
  let fuenteCampo = null;
  let ciElegida = null;
  let valorOriginal = null;

  for (const ci of affected) {
    // Contempla nombres comunes de CMDB
    const candRaw =
      ci?.criticidad ??
      ci?.criticality ??
      ci?.businessCriticality ??
      ci?.ciBusinessCriticality ??
      ci?.ci_business_criticality ??
      ci?.severity ??                 // por si alguna CI trae severidad en vez de criticidad
      ci?.tier;

    const cand = normalizarCriticidad(candRaw);

    if (candRaw != null) {
      tuvoCI = true;
      if (rank[cand] < rank[worstFromCI]) {
        worstFromCI = cand;
        fuenteCampo = Object.keys(ci).find(k =>
          ['criticidad','criticality','businessCriticality','ciBusinessCriticality','ci_business_criticality','severity','tier']
            .includes(k)
        ) || 'desconocido';
        ciElegida = ci?.name || ci?.Nombre || ci?.id || '';
        valorOriginal = candRaw;
      }
    }
  }
  if (tuvoCI) {
    return { criticidad: worstFromCI, fuente: 'CI', detalles: { campo: fuenteCampo, ci: ciElegida, valor: valorOriginal } };
  }

  // Regla 2: severidad/impacto del problema (la peor)
  const sev = normalizarCriticidad(problem?.severityLevel);
  const imp = normalizarCriticidad(problem?.impactLevel);
  if (problem?.severityLevel || problem?.impactLevel) {
    return { criticidad: peor(sev, imp), fuente: 'SEVERITY/IMPACT', detalles: { severityLevel: problem?.severityLevel, impactLevel: problem?.impactLevel } };
  }

  // Regla 3: fallback
  return { criticidad: 'S4', fuente: 'DEFAULT', detalles: {} };
}

// Azúcar
export function calcularCriticidad(p) {
  return calcularCriticidadDetallada(p).criticidad;
}