// src/api/problems.js

// 1) URL base desde .env (sin la barra final)
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/$/, "");
if (!BASE) {
  throw new Error("❌ ERROR: Falta definir VITE_API_URL en .env (ej: https://tu-backend)");
}

// Tu endpoint swagger es /api/Problems
const API = `${BASE}/api/Problems`;

// -----------------------------
// 2) Normalizar el shape
// -----------------------------
function toBool(v) {
  if (typeof v === "boolean") return v;
  if (typeof v === "string") return v.toUpperCase() === "TCS";
  return false;
}

function parseDate(v) {
  if (!v) return null;
  const d = new Date(v);
  return isNaN(d) ? null : d;
}

function normalize(list) {
  if (!Array.isArray(list)) list = [];
  return list.map((p) => {
    const isTcsFromObj   = p?.jurisdiction?.isTcs;
    const isTcsFromLabel = typeof p?.juris === "string" ? p.juris : p?.jurisdiction?.label;

    const isTcs = toBool(isTcsFromObj ?? isTcsFromLabel ?? false);
    const label = isTcs ? "TCS" : "NO TCS";

    const startRaw = p.startTime ?? p.startTimeUtc ?? p.startDate ?? p.start;
    const start    = parseDate(startRaw);

    return {
      ...p,
      isTcs,
      label,
      title: p.title || p.shortDescription || "(sin título)",
      severityLevel: p.severityLevel || p.severity || "",
      impactLevel: p.impactLevel || p.impact || "",
      startTime: start,                       // ← Date real
      affectedCI: p.affectedEntities || p.affectedCI || [],
      environment: p.environment || p.environmentName || "",
      problemId: p.problemId || p.displayId || p.id || "",
      status: p.status || p.state || "",
    };
  });
}

// -----------------------------
// 3) Traer UNA página cruda
// -----------------------------
async function fetchPageRaw(page = 1, size = 200) {
  const url = `${API}?pageNumber=${page}&pageSize=${size}`;
  const res = await fetch(url, { headers: { accept: "application/json" } });
  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`❌ HTTP ${res.status} al obtener problemas:\n${txt}`);
  }
  return res.json();
}

// Devuelve array de items cualquiera sea el envoltorio
function extractItems(json) {
  if (Array.isArray(json)) return json;
  return json?.results || json?.items || json?.data || json?.value || [];
}

// -----------------------------
// 4) Traer TODO por rango (paginando hasta cruzar el FROM)
//    – No depende de parámetros de fecha del backend
//    – Corta cuando ya pasamos el límite inferior
// -----------------------------
export async function fetchAllProblemsRange(fromDate, toDate, pageSize = 500) {
  const fromMs = +fromDate;
  const toMs   = +toDate;

  let page = 1;
  const all = [];

  // Seguimos hasta que: (a) no haya datos, (b) la página venga incompleta, o
  // (c) todos los registros de la página ya están antes del fromDate.
  // Dado que el backend no garantiza orden, filtramos al final también.
  while (true) {
    const json = await fetchPageRaw(page, pageSize);
    const batch = normalize(extractItems(json));

    if (batch.length === 0) break;

    all.push(...batch);

    // Heurística de corte: si la mayoría de la página está antes del FROM, paramos.
    const olderCount = batch.filter(x => x.startTime && (+x.startTime < fromMs)).length;
    if (olderCount > batch.length * 0.8) break;

    // Si vino incompleta, es la última
    if (batch.length < pageSize) break;

    page++;
  }

  // Filtro estricto por rango y ordenado descendente
  const inRange = all.filter(x => x.startTime && (+x.startTime >= fromMs) && (+x.startTime <= toMs));
  inRange.sort((a, b) => +b.startTime - +a.startTime);
  return inRange;
}

--------

// src/pages/TCSProblems.jsx
import React, { useEffect, useState } from "react";
import { fetchAllProblemsRange } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

export default function TCSProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading]   = useState(true);
  const [error, setError]       = useState(null);
  const [username, setUsername] = useState("");

  useEffect(() => {
    async function load() {
      try {
        const from = new Date("2025-11-25T00:00:00");
        const to   = new Date();
        const data = await fetchAllProblemsRange(from, to, 500); // página grande
        const onlyTcs = data.filter(p => p.isTcs === true);
        setProblems(onlyTcs);
      } catch (e) {
        setError(e.message);
      } finally {
        setLoading(false);
      }
    }
    load();
  }, []);

  if (loading) return <h2>Cargando problemas TCS…</h2>;
  if (error)   return <h2 style={{ color: "red" }}>{error}</h2>;

  return (
    <>
      <h2>
        Problemas TCS <span className="badge">{problems.length}</span>
      </h2>

      <UsernameInput value={username} onChange={setUsername} />

      {problems.length === 0 ? (
        <h2>No hay problemas TCS entre el 25/11/2025 y hoy.</h2>
      ) : (
        problems.map((p) => (
          <ProblemCard key={p.problemId} problem={p} username={username} />
        ))
      )}
    </>
  );
}

----

// src/pages/TCSProblems.jsx
import React, { useEffect, useState } from "react";
import { fetchAllProblemsRange } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

export default function TCSProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading]   = useState(true);
  const [error, setError]       = useState(null);
  const [username, setUsername] = useState("");

  useEffect(() => {
    async function load() {
      try {
        const from = new Date("2025-11-25T00:00:00");
        const to   = new Date();
        const data = await fetchAllProblemsRange(from, to, 500); // página grande
        const onlyTcs = data.filter(p => p.isTcs === true);
        setProblems(onlyTcs);
      } catch (e) {
        setError(e.message);
      } finally {
        setLoading(false);
      }
    }
    load();
  }, []);

  if (loading) return <h2>Cargando problemas TCS…</h2>;
  if (error)   return <h2 style={{ color: "red" }}>{error}</h2>;

  return (
    <>
      <h2>
        Problemas TCS <span className="badge">{problems.length}</span>
      </h2>

      <UsernameInput value={username} onChange={setUsername} />

      {problems.length === 0 ? (
        <h2>No hay problemas TCS entre el 25/11/2025 y hoy.</h2>
      ) : (
        problems.map((p) => (
          <ProblemCard key={p.problemId} problem={p} username={username} />
        ))
      )}
    </>
  );
}