// src/api/problems.js

// -----------------------------------------------------
// 1) BASE del backend desde .env (Vite)
//    Admite que pongas la raíz (https://host:puerto) o
//    el endpoint completo (https://host:puerto/api/Problems)
// -----------------------------------------------------
const RAW_BASE = (import.meta?.env?.VITE_API_URL || "").trim();

// quita slash final
function stripEndSlash(s) {
  return s.replace(/\/+$/, "");
}

// si el usuario ya puso /api/Problems o /api/problems, úsalo tal cual
// si solo puso la raíz del backend, agregamos /api/Problems
function resolveApi(base) {
  const b = stripEndSlash(base);
  if (!b) {
    throw new Error(
      "❌ ERROR: Falta definir VITE_API_URL en .env (ej.: VITE_API_URL=http://localhost:44334)"
    );
  }
  if (/\/api\/problems?$/i.test(b)) return b; // ya es el endpoint
  return `${b}/api/Problems`; // añadimos endpoint
}
export const API = resolveApi(RAW_BASE);

// -----------------------------------------------------
// 2) Normalización de alertas del backend
//    Soporta distintas formas de 'jurisdicción':
//    - p.jurisdiction: { isTcs: bool, label: "TCS"|"NO TCS" }
//    - p.jurisdiction: "TCS" | "NO TCS" (string)
//    - p.juris: "TCS" | "NO TCS" (legacy)
// -----------------------------------------------------
function toBool(x) {
  if (typeof x === "boolean") return x;
  if (typeof x === "string") {
    const s = x.trim().toUpperCase();
    if (s === "TCS") return true;
    if (s === "NO TCS" || s === "NOTCS" || s === "NO_TCS") return false;
  }
  return undefined;
}

function toLabel(isTcs) {
  if (typeof isTcs === "boolean") return isTcs ? "TCS" : "NO TCS";
  return undefined;
}

function ensureArray(x) {
  if (Array.isArray(x)) return x;
  if (x == null || x === "") return [];
  // algunos backends mandan objetos o strings serializados
  try {
    if (typeof x === "string") {
      const parsed = JSON.parse(x);
      return Array.isArray(parsed) ? parsed : [parsed];
    }
  } catch {
    /* ignore */
  }
  return [x];
}

export function normalize(list) {
  if (!Array.isArray(list)) list = [];

  return list.map((p) => {
    // ------ Jurisdicción ------
    // 1) bool directo
    const isTcsFromObject =
      p?.jurisdiction && typeof p.jurisdiction === "object"
        ? p.jurisdiction.isTcs
        : undefined;

    // 2) string en jurisdiction o juris
    const isTcsFromString =
      toBool(p?.jurisdiction) ??
      toBool(p?.juris) ??
      toBool(p?.jurisdiction?.label);

    const isTcs = (isTcsFromObject ?? isTcsFromString) ?? false;
    const label =
      (p?.jurisdiction && p.jurisdiction.label) || toLabel(isTcs) || "NO TCS";

    // ------ Campos base ------
    const title = p?.title || p?.shortDescription || "(sin título)";
    const severityLevel = p?.severityLevel || p?.severity || "";
    const impactLevel = p?.impactLevel || p?.impact || "";
    const startTime = p?.startTime || p?.startTimeUtc || null;

    // affectedEntities / affectedCI puede venir como array, objeto o string
    const affectedCI =
      ensureArray(p?.affectedEntities).length
        ? ensureArray(p.affectedEntities)
        : ensureArray(p?.affectedCI);

    // id: intenta problemId, displayId o un hash simple
    const problemId = p?.problemId || p?.id || "";
    const displayId = p?.displayId || "";
    const id = problemId || displayId || `${title}-${startTime || ""}`;

    // probabilidad (si tu backend la expone)
    const probability =
      typeof p?.probability === "number"
        ? p.probability
        : typeof p?.Probability === "number"
        ? p.Probability
        : null;

    return {
      // originales (por si necesitas todo)
      ...p,

      // normalizados
      id,
      problemId,
      displayId,
      title,
      shortDescription: p?.shortDescription || p?.title || "",
      severityLevel,
      impactLevel,
      startTime,
      affectedCI,
      environment: p?.environment || p?.env || "",
      tenant: p?.tenant || p?.Tenan || "",

      // jurisdicción normalizada
      jurisdiction: { isTcs, label },

      // opcional
      probability,
      status: p?.status || p?.state || "",
    };
  });
}

// -----------------------------------------------------
// 3) Obtener UNA página del backend
//    El backend devuelve: { totalRecords, totalPages, pageNumber, pageSize, data: [] }
//    o directamente un array. Ambas se soportan.
// -----------------------------------------------------
async function fetchPage(page = 1, size = 50, { signal } = {}) {
  const url = `${API}?pageNumber=${page}&pageSize=${size}`;

  const res = await fetch(url, {
    headers: { accept: "application/json" },
    signal,
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`❌ HTTP ${res.status} al obtener problemas:\n${txt}`);
  }

  const json = await res.json();

  // Puede venir { data: [] } o directamente []
  const items = Array.isArray(json)
    ? json
    : json?.data || json?.items || json?.results || json?.value || [];

  return {
    items,
    pageInfo: {
      totalRecords: json?.totalRecords ?? null,
      totalPages: json?.totalPages ?? null,
      pageNumber: json?.pageNumber ?? page,
      pageSize: json?.pageSize ?? size,
    },
  };
}

// -----------------------------------------------------
// 4) Traer histórico con páginas limitadas
// -----------------------------------------------------
export async function fetchAllProblems(
  size = 50,
  maxPages = 10,
  { signal } = {}
) {
  let page = 1;
  let all = [];

  while (page <= maxPages) {
    const { items, pageInfo } = await fetchPage(page, size, { signal });

    if (!items || items.length === 0) break;

    all = all.concat(items);

    // si el backend avisa totalPages, respetamos eso
    if (pageInfo.totalPages && page >= pageInfo.totalPages) break;

    // si vino incompleta, asumimos fin
    if (items.length < size) break;

    page++;
  }

  return normalize(all);
}

// -----------------------------------------------------
// 5) Helpers para filtrar por jurisdicción
// -----------------------------------------------------
export function onlyTcs(list) {
  return (list || []).filter((p) => p?.jurisdiction?.isTcs === true);
}

export function onlyNoTcs(list) {
  return (list || []).filter((p) => p?.jurisdiction?.isTcs === false);
}

// -----------------------------------------------------
// 6) Helpers de conveniencia (fetch + filtro)
// -----------------------------------------------------
export async function fetchTcsProblems(size = 50, maxPages = 10, opts = {}) {
  const all = await fetchAllProblems(size, maxPages, opts);
  return onlyTcs(all);
}

export async function fetchNoTcsProblems(size = 50, maxPages = 10, opts = {}) {
  const all = await fetchAllProblems(size, maxPages, opts);
  return onlyNoTcs(all);
}

export async function fetchAllGrouped(size = 50, maxPages = 10, opts = {}) {
  const all = await fetchAllProblems(size, maxPages, opts);
  return {
    all,
    tcs: onlyTcs(all),
    otros: onlyNoTcs(all),
  };
}