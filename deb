// src/api/problems.js

// 1) Base del backend desde .env (con o sin /api/Problems)
const RAW_BASE = (import.meta?.env?.VITE_API_URL || "").trim();
if (!RAW_BASE) {
  throw new Error("❌ ERROR: Define VITE_API_URL en tu archivo .env");
}
const BASE = RAW_BASE.replace(/\/+$/, "");
const API = /\/api\/problems$/i.test(BASE)
  ? BASE
  : `${BASE}/api/Problems`;

// ---------- Utilidades de fecha ----------

/** Devuelve 'YYYY-MM-DD' en UTC para comparar días */
function toYmdUTC(dt) {
  const d = new Date(dt);
  return isNaN(d) ? "" : d.toISOString().slice(0, 10);
}

/** ¿StartTime pertenece exactamente al día UTC dado (YYYY-MM-DD)? */
function isSameDayUTC(isoString, ymdUTC) {
  return toYmdUTC(isoString) === ymdUTC;
}

// ---------- Normalización del payload ----------

function normalize(list) {
  if (!Array.isArray(list)) list = [];

  return list.map((p) => {
    // Jurisdicción: puede venir como objeto, string, bool…
    const jurisObj = p?.jurisdiction;
    const jurisStr =
      typeof p?.juris === "string"
        ? p.juris
        : typeof p?.Jurisdiction === "string"
        ? p.Jurisdiction
        : typeof jurisObj === "string"
        ? jurisObj
        : undefined;

    const isTcsFromObject =
      typeof jurisObj?.isTcs === "boolean" ? jurisObj.isTcs : undefined;

    const isTcsFromString =
      typeof jurisStr === "string"
        ? jurisStr.trim().toUpperCase() === "TCS"
        : undefined;

    const isTcs = isTcsFromObject ?? isTcsFromString ?? false;

    // Construimos un URL directo al problema si tenemos tenant & problemId
    const tenant =
      p?.tenant ||
      p?.environment ||
      p?.Environment ||
      p?.env ||
      p?.Tenant ||
      "";

    const problemId =
      p?.problemId || p?.displayId || p?.id || p?.ProblemId || p?.PID || "";

    let directUrl = p?.url || p?.problemUrl || p?.link || "";
    if (!directUrl && tenant && problemId) {
      // Ajusta si tu tenant es *.live.dynatrace.com u otro dominio
      directUrl = `https://${tenant}.live.dynatrace.com/#problems/problemdetails;pid=${problemId}`;
    }

    return {
      // Campos “estándar” que consumen tus páginas/cards
      ...p,
      isTcs,
      label: isTcs ? "TCS" : "NO TCS",

      title: p?.title || p?.shortDescription || "(sin título)",
      severityLevel: p?.severityLevel || p?.severity || "",
      impactLevel: p?.impactLevel || p?.impact || "",
      startTime: p?.startTime || p?.startTimeUtc || p?.StartTime || null,
      affectedCI: p?.affectedEntities || p?.affectedCI || [],
      environment: p?.environment || p?.environmentName || "",

      problemId,
      status: p?.status || p?.state || "",

      // Para que tu <ProblemCard/> abra el vínculo sin tocar esa UI:
      url: directUrl,
      link: directUrl,
      problemUrl: directUrl,
    };
  });
}

// ---------- Fetchers ----------

/** Trae una página tal como la expone el backend (paginado API). */
async function fetchPage(page = 1, size = 50) {
  const url = `${API}?pageNumber=${page}&pageSize=${size}`;
  const res = await fetch(url, { headers: { accept: "application/json" } });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`❌ HTTP ${res.status} al obtener problemas:\n${txt}`);
  }

  const json = await res.json();

  // Soportar varios formatos: array directo o {data|items|results|value}
  const data = Array.isArray(json)
    ? json
    : json?.data || json?.items || json?.results || json?.value || [];

  return normalize(data);
}

/** Trae hasta maxPages páginas (cliente) y concatena todo. */
export async function fetchAllProblems(size = 50, maxPages = 200) {
  let page = 1;
  const all = [];

  while (page <= maxPages) {
    const batch = await fetchPage(page, size);
    if (!batch || batch.length === 0) break;

    all.push(...batch);

    // Si la página llegó “incompleta”, asumimos que fue la última
    if (batch.length < size) break;
    page++;
  }

  return all;
}

/**
 * Trae todas las páginas y filtra por un día exacto (UTC)
 * @param {string} ymdUTC - "YYYY-MM-DD" (ej: "2025-11-25")
 */
export async function fetchProblemsByDayUTC(ymdUTC, size = 50, maxPages = 200) {
  const all = await fetchAllProblems(size, maxPages);
  return all.filter((p) => isSameDayUTC(p.startTime, ymdUTC));
}

------

// src/pages/TCSProblems.jsx
import React, { useEffect, useState } from "react";
import { fetchProblemsByDayUTC } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

// Día fijo de pruebas (25/11/2025 en UTC)
const TEST_DAY_UTC = "2025-11-25";

export default function TCSProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [username, setUsername] = useState("");

  useEffect(() => {
    async function load() {
      try {
        const data = await fetchProblemsByDayUTC(TEST_DAY_UTC);

        const onlyTcs = data
          .filter((p) => p.isTcs === true)
          .sort(
            (a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime()
          );

        setProblems(onlyTcs);
      } catch (e) {
        setError(e.message);
      } finally {
        setLoading(false);
      }
    }
    load();
  }, []);

  if (loading) return <h2>Cargando problemas TCS…</h2>;
  if (error) return <h2 style={{ color: "red" }}>Error: {error}</h2>;
  if (problems.length === 0)
    return <h2>No hay problemas TCS el {TEST_DAY_UTC}.</h2>;

  return (
    <>
      <h2>
        Problemas TCS <span style={{ opacity: 0.6 }}>({problems.length})</span>
      </h2>

      <UsernameInput value={username} onChange={setUsername} />

      {problems.map((p) => (
        <ProblemCard key={p.problemId || p.id} problem={p} username={username} />
      ))}
    </>
  );
}

----

// src/pages/OtherProblems.jsx
import React, { useEffect, useState } from "react";
import { fetchProblemsByDayUTC } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

// Día fijo de pruebas (25/11/2025 en UTC)
const TEST_DAY_UTC = "2025-11-25";

export default function OtherProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [username, setUsername] = useState("");

  useEffect(() => {
    async function load() {
      try {
        const data = await fetchProblemsByDayUTC(TEST_DAY_UTC);

        const others = data
          .filter((p) => p.isTcs === false)
          .sort(
            (a, b) => new Date(b.startTime).getTime() - new Date(a.startTime).getTime()
          );

        setProblems(others);
      } catch (e) {
        setError(e.message);
      } finally {
        setLoading(false);
      }
    }
    load();
  }, []);

  if (loading) return <h2>Cargando problemas de terceros…</h2>;
  if (error) return <h2 style={{ color: "red" }}>Error: {error}</h2>;
  if (problems.length === 0)
    return <h2>No hay problemas de terceros el {TEST_DAY_UTC}.</h2>;

  return (
    <>
      <h2>
        Problemas Otros{" "}
        <span style={{ opacity: 0.6 }}>({problems.length})</span>
      </h2>

      <UsernameInput value={username} onChange={setUsername} />

      {problems.map((p) => (
        <ProblemCard key={p.problemId || p.id} problem={p} username={username} />
      ))}
    </>
  );
}



