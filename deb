using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Timers;
using DynatraceProblemUpdater.Data.Sources.ML;

namespace DynatraceProblemUpdater.Data.Sources.ML
{
    /// <summary>
    /// Cache de predicciones por título. Guarda: etiqueta (bool), probabilidad y expiración.
    /// </summary>
    public static class PredictionCache
    {
        private record CacheItem(bool Prediction, float Probability, DateTime ExpireAt);

        private static readonly ConcurrentDictionary<string, CacheItem> _cache = new(StringComparer.OrdinalIgnoreCase);
        private static readonly Timer _cleanupTimer;

        // Config: cuánto dura una predicción en cache
        private const int CacheMinutes = 30;

        static PredictionCache()
        {
            _cleanupTimer = new Timer(TimeSpan.FromMinutes(CacheMinutes).TotalMilliseconds);
            _cleanupTimer.Elapsed += (_, __) => CleanupExpired();
            _cleanupTimer.AutoReset = true;
            _cleanupTimer.Start();
        }

        /// <summary> Limpia entradas expiradas. </summary>
        private static void CleanupExpired()
        {
            var now = DateTime.UtcNow;
            foreach (var kvp in _cache.ToArray())
            {
                if (kvp.Value.ExpireAt <= now)
                    _cache.TryRemove(kvp.Key, out _);
            }
        }

        /// <summary>
        /// Carga/actualiza predicciones en cache para una lista de títulos.
        /// Renueva la expiración de los que ya existen y agrega los que faltan.
        /// </summary>
        public static async System.Threading.Tasks.Task UpdateOrStorePredictionsAsync(
            List<string> titles,
            MLPredictor predictor)
        {
            if (titles == null || titles.Count == 0 || predictor == null) return;

            CleanupExpired();

            foreach (var raw in titles)
            {
                var title = raw?.Trim();
                if (string.IsNullOrWhiteSpace(title)) continue;

                // Si ya existe y no está vencida, solo renuevo expiración
                if (_cache.TryGetValue(title, out var existing))
                {
                    _cache[title] = existing with { ExpireAt = DateTime.UtcNow.AddMinutes(CacheMinutes) };
                    continue;
                }

                // Intento predecir ligero por título (no bloqueante)
                try
                {
                    if (predictor.TryPredictByTitle(title, out bool isTcs, out float probability))
                    {
                        var item = new CacheItem(isTcs, probability, DateTime.UtcNow.AddMinutes(CacheMinutes));
                        _cache[title] = item;
                    }
                }
                catch
                {
                    // No tirar la app por un fallo puntual de predicción.
                }

                // Pequeño respiro en bucles muy grandes
                await System.Threading.Tasks.Task.Yield();
            }
        }

        /// <summary> Obtiene etiqueta booleana del cache si existe. </summary>
        public static bool TryGetPrediction(string title, out bool isTcs)
        {
            isTcs = false;
            if (string.IsNullOrWhiteSpace(title)) return false;

            if (_cache.TryGetValue(title, out var item))
            {
                if (item.ExpireAt > DateTime.UtcNow)
                {
                    isTcs = item.Prediction;
                    return true;
                }
                _cache.TryRemove(title, out _);
            }
            return false;
        }

        /// <summary> Obtiene etiqueta y probabilidad del cache si existe. </summary>
        public static bool TryGetPrediction(string title, out bool isTcs, out float probability)
        {
            isTcs = false;
            probability = 0f;
            if (string.IsNullOrWhiteSpace(title)) return false;

            if (_cache.TryGetValue(title, out var item))
            {
                if (item.ExpireAt > DateTime.UtcNow)
                {
                    isTcs = item.Prediction;
                    probability = item.Probability;
                    return true;
                }
                _cache.TryRemove(title, out _);
            }
            return false;
        }

        /// <summary> Vacía la cache (opcional, por mantenimiento). </summary>
        public static void Clear() => _cache.Clear();
    }
}