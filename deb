private async Task<List<DBProblem>> MapToDBProblems(List<DynatraceProblem> problems, APIToken token)
{
    // 1) Calcular títulos únicos y precargar predicciones en caché (usar Title)
    var uniqueDescriptions = problems
        .Select(p => p?.Title)
        .Where(s => !string.IsNullOrWhiteSpace(s))
        .Distinct()
        .ToList();

    await PredictionCache.UpdateOrStorePredictionsAsync(uniqueDescriptions, _predictor);

    // 2) Mapear a DBProblem
    var dbProblems = new List<DBProblem>();

    foreach (var problem in problems)
    {
        if (problem == null) continue;

        var impacted = problem.ImpactedEntities ?? new List<ProblemEntity>();
        var evidence = problem.EvidenceDetails ?? new EvidenceDetails();
        var affectedCI = await _serverMatcher.FindAffectedServersAsync(impacted, evidence);

        // ShortDescription = Title
        var shortDescription = problem.Title ?? string.Empty;

        string jurisdiction = "Unknown";
        float probability = 0f;

        if (!string.IsNullOrWhiteSpace(shortDescription) &&
            PredictionCache.TryGetPrediction(shortDescription, out bool isTcs, out probability))
        {
            jurisdiction = isTcs ? "TCS" : "NO TCS";
        }

        // Construcción del registro para la BD (ajusta si tu constructor acepta probabilidad)
        dbProblems.Add(new DBProblem(
            problem,
            token.Environment,
            token.Tenant,
            shortDescription,
            affectedCI,
            jurisdiction
            // , probability  // <-- descomenta si tu DBProblem tiene este campo
        ));
    }

    return dbProblems;
}