// src/api/problems.js
// Trae problemas paginando y normaliza campos para el UI

const API_BASE = (import.meta.env.VITE_API_URL || "").replace(/\/$/, "");
const DYN_TENANT = (import.meta.env.VITE_DYNATRACE_TENANT || "").replace(/\/$/, "");

// ---------- Normalizador robusto ----------
function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    // Fechas (acepta múltiples variantes)
    const startRaw =
      p.startTime ??
      p.startTimeUtc ??
      p.StartTime ??
      p.StartTimeUtc ??
      p.start_date ??
      null;

    const endRaw =
      p.endTime ??
      p.endTimeUtc ??
      p.EndTime ??
      p.EndTimeUtc ??
      p.end_date ??
      null;

    // Jurisdicción / etiqueta
    const jurisRaw =
      p.jurisdiction?.label ??
      p.jurisdiction?.name ??
      p.jurisdiction2?.Jurisdiction ??
      p.Jurisdiction ??
      p.jurisdiction ??
      p.label ??
      p.Label ??
      "";

    const juris = typeof jurisRaw === "string" ? jurisRaw.trim().toUpperCase() : "";
    const isTcs = p.jurisdiction?.isTcs ??
                  (typeof juris === "string" ? juris === "TCS" : false);

    // Ids y título
    const problemId = p.problemId ?? p.displayId ?? p.id ?? "";
    const title = p.title ?? p.shortDescription ?? "(sin título)";

    // Otros campos usados por el card
    const severityLevel = p.severityLevel ?? p.severity ?? "";
    const impactLevel   = p.impactLevel   ?? p.impact   ?? "";
    const environment   = p.environment   ?? p.environmentName ?? ""; // "Productivo"/"No productivo"
    const affectedCI    = p.affectedCI    ?? p.affectedEntitiesList ?? [];

    const status = p.status ?? p.state ?? "";

    // URL de Dynatrace (si tenemos tenant e id)
    const dynatraceUrl =
      DYN_TENANT && problemId
        ? `${DYN_TENANT}/#problems/problemdetails;pid=${encodeURIComponent(problemId)}`
        : null;

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment,
      affectedCI,
      status,
      label: isTcs ? "TCS" : "NO TCS",
      isTcs,
      startTime: startRaw ? new Date(startRaw).toISOString() : null,
      endTime: endRaw ? new Date(endRaw).toISOString() : null,
      dynatraceUrl,
    };
  });
}

// ---------- Paginación ----------
async function fetchPage({ pageNumber = 1, pageSize = 500 }) {
  const url = `${API_BASE}/api/Problems?pageNumber=${pageNumber}&pageSize=${pageSize}`;
  const res = await fetch(url);
  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} en ${url} :: ${txt || res.statusText}`);
  }
  return res.json();
}

export async function fetchAllProblems({ pageSize = 500 } = {}) {
  if (!API_BASE) throw new Error("VITE_API_URL no está configurado");
  const all = [];
  let page = 1;

  while (true) {
    const data = await fetchPage({ pageNumber: page, pageSize });
    const items = Array.isArray(data) ? data : (data?.items ?? []);
    all.push(...items);
    if (!Array.isArray(items) || items.length < pageSize) break; // última página
    page += 1;
    // pequeño respiro para no saturar el túnel/servidor
    await new Promise(r => setTimeout(r, 80));
  }

  return normalize(all);
}

// Helpers específicos
export async function fetchTcsProblems() {
  const all = await fetchAllProblems();
  return all.filter(p => p.isTcs);
}

export async function fetchOtherProblems() {
  const all = await fetchAllProblems();
  return all.filter(p => !p.isTcs);
}

---

// src/pages/TCSProblems.jsx
import React, { useEffect, useState } from "react";
import { fetchTcsProblems } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

export default function TCSProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading]   = useState(true);
  const [error, setError]       = useState(null);
  const [username, setUsername] = useState("");

  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const data = await fetchTcsProblems();
        if (!mounted) return;
        // Orden descendente por fecha de inicio
        data.sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
        setProblems(data);
      } catch (err) {
        if (!mounted) return;
        setError(err.message || String(err));
      } finally {
        if (mounted) setLoading(false);
      }
    })();
    return () => { mounted = false; };
  }, []);

  if (loading) return <p style={{ textAlign: "center" }}>Cargando problemas TCS…</p>;
  if (error)   return <p style={{ color: "crimson" }}>Error: {error}</p>;

  return (
    <div style={{ maxWidth: 980, margin: "0 auto", padding: "1rem" }}>
      <h2>Problemas TCS ({problems.length})</h2>
      <div style={{ marginBottom: "0.75rem" }}>
        <label style={{ marginRight: 8 }}>Usuario: </label>
        <UsernameInput value={username} onChange={setUsername} />
      </div>

      {problems.length === 0 && <p>No hay problemas TCS en el rango.</p>}

      {problems.map((p) => (
        <ProblemCard key={p.problemId || p.id} problem={p} username={username} />
      ))}
    </div>
  );
}

---

// src/pages/OtherProblems.jsx
import React, { useEffect, useState } from "react";
import { fetchOtherProblems } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

export default function OtherProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading]   = useState(true);
  const [error, setError]       = useState(null);
  const [username, setUsername] = useState("");

  useEffect(() => {
    let mounted = true;
    (async () => {
      try {
        const data = await fetchOtherProblems();
        if (!mounted) return;
        data.sort((a, b) => new Date(b.startTime) - new Date(a.startTime));
        setProblems(data);
      } catch (err) {
        if (!mounted) return;
        setError(err.message || String(err));
      } finally {
        if (mounted) setLoading(false);
      }
    })();
    return () => { mounted = false; };
  }, []);

  if (loading) return <p style={{ textAlign: "center" }}>Cargando problemas de terceros…</p>;
  if (error)   return <p style={{ color: "crimson" }}>Error: {error}</p>;

  return (
    <div style={{ maxWidth: 980, margin: "0 auto", padding: "1rem" }}>
      <h2>Problemas Otros ({problems.length})</h2>
      <div style={{ marginBottom: "0.75rem" }}>
        <label style={{ marginRight: 8 }}>Usuario: </label>
        <UsernameInput value={username} onChange={setUsername} />
      </div>

      {problems.length === 0 && <p>No hay problemas de terceros en el rango.</p>}

      {problems.map((p) => (
        <ProblemCard key={p.problemId || p.id} problem={p} username={username} />
      ))}
    </div>
  );
}