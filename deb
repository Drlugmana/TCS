// src/api/problems.js

// 1) BASE URL desde .env (sin /api/Problems al final)
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/$/, "");
if (!BASE) {
  throw new Error("❌ ERROR: Falta definir VITE_API_URL en .env (ej: VITE_API_URL=https://tu-backend)");
}

// Construye ruta de Problems del Swagger
const API = `${BASE}/api/Problems`;

// ------------------------------------------------------
// 2) NORMALIZAR ALERTAS DEL BACKEND
//    - Convierte jurisdiction en { isTcs:boolean, label:string }
//    - Asegura campos comunes que usa la UI
// ------------------------------------------------------
function normalize(list) {
  if (!Array.isArray(list)) list = [];

  return list.map((p) => {
    // 2.1 Resolver label de jurisdicción (preferimos string plano del backend)
    const rawJuris =
      p.jurisdiction ??               // "TCS" | "NO TCS"
      p.juris ??                      // por si en algún momento vino como 'juris'
      p?.jurisdiction?.label ??       // por si vino anidado
      p?.label ??                     // fallback muy defensivo
      "";

    // 2.2 Booleano isTcs robusto (acepta "TCS", "SI TCS", etc.)
    let isTcs = false;
    if (typeof rawJuris === "string") {
      isTcs = /(^|\s)TCS(\s|$)/i.test(rawJuris);
    } else if (rawJuris && typeof rawJuris === "object") {
      // Por si algún día te llega como objeto { isTcs: true }
      isTcs = !!rawJuris.isTcs;
    }

    // 2.3 Etiqueta final visible
    const label =
      typeof rawJuris === "string"
        ? rawJuris.toUpperCase()
        : isTcs
        ? "TCS"
        : "NO TCS";

    // 2.4 Campos que la UI usa
    return {
      ...p,
      isTcs,
      label,
      title: p.title || p.shortDescription || "(sin título)",
      severityLevel: p.severityLevel || p.severity || "",
      impactLevel: p.impactLevel || p.impact || "",
      startTime: p.startTime || p.startTimeUtc || null,
      affectedCI: p.affectedEntities || p.affectedCI || [],
      environment: p.environment || p.environmentName || "",
      problemId: p.problemId || p.displayId || p.id || "",
      status: p.status || p.state || "",
    };
  });
}

// ------------------------------------------------------
// Utilidad: parsear fecha segura (acepta string/Date/null)
// ------------------------------------------------------
function toDate(d) {
  if (!d) return null;
  const dt = d instanceof Date ? d : new Date(d);
  return Number.isNaN(dt.getTime()) ? null : dt;
}

// ------------------------------------------------------
// 3) OBTENER UNA ÚNICA PÁGINA DEL BACKEND (pagina/size)
// ------------------------------------------------------
async function fetchPage(page, size = 50) {
  const url = `${API}?pageNumber=${page}&pageSize=${size}`;

  const res = await fetch(url, {
    headers: { accept: "application/json" },
  });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`❌ HTTP ${res.status} al obtener problemas:\n${txt}`);
  }

  const json = await res.json();
  // puede venir como array directo o dentro de { data | results | items | value }
  const data = Array.isArray(json)
    ? json
    : json?.results || json?.items || json?.data || json?.value || [];

  return normalize(data);
}

// ------------------------------------------------------
// 4) TRAER HISTÓRICO CON PÁGINAS LIMITADAS
//    - Devuelve TODO normalizado
// ------------------------------------------------------
export async function fetchAllProblems(size = 50, maxPages = 10) {
  let page = 1;
  let all = [];

  while (page <= maxPages) {
    const batch = await fetchPage(page, size);
    if (!batch || batch.length === 0) break;

    all = [...all, ...batch];
    if (batch.length < size) break; // última
    page++;
  }

  return all;
}

// ------------------------------------------------------
// 5) HELPERS DE FECHA + FILTROS POR RANGO
// ------------------------------------------------------
export function isWithinRange(p, fromDate, toDate) {
  const st = toDate == null && fromDate == null ? toDate : undefined; // no warning
  const dt = toDate(p.startTime);
  if (!dt) return false;
  const a = toDate(fromDate);
  const b = toDate(toDate);
  if (a && dt < a) return false;
  if (b && dt > b) return false;
  return true;
}

// Atajo para filtrar rápidamente por rango e isTcs
export function filterByRangeAndTcs(list, fromDate, toDate, wantTcs = true) {
  return list.filter(
    (p) => p.isTcs === wantTcs && isWithinRange(p, fromDate, toDate)
  );
}

// Utilidad para ordenar descendente por fecha
export function sortByStartTimeDesc(list) {
  return [...list].sort(
    (a, b) => (toDate(b.startTime)?.getTime() || 0) - (toDate(a.startTime)?.getTime() || 0)
  );
}

-------

import React, { useEffect, useState } from "react";
import { fetchAllProblems, filterByRangeAndTcs, sortByStartTimeDesc } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

export default function TCSProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [username, setUsername] = useState("");

  // Fechas de prueba: 25/11/2025 -> hoy
  const FROM = new Date("2025-11-25T00:00:00");
  const TO = new Date();

  useEffect(() => {
    async function load() {
      try {
        const data = await fetchAllProblems();
        const onlyTcsInRange = filterByRangeAndTcs(data, FROM, TO, true);
        setProblems(sortByStartTimeDesc(onlyTcsInRange));
      } catch (e) {
        setError(e.message);
      } finally {
        setLoading(false);
      }
    }
    load();
  }, []);

  if (loading) return <h2>Cargando problemas TCS…</h2>;
  if (error)   return <h2 style={{ color: "red" }}>{error}</h2>;
  if (problems.length === 0)
    return <h2>No hay problemas TCS entre el 25/11/2025 y hoy.</h2>;

  return (
    <>
      <h2>Problemas TCS</h2>
      <UsernameInput value={username} onChange={setUsername} />
      {problems.map((p) => (
        <ProblemCard key={p.problemId} problem={p} username={username} />
      ))}
    </>
  );
}

------

import React, { useEffect, useState } from "react";
import { fetchAllProblems, filterByRangeAndTcs, sortByStartTimeDesc } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

export default function OtherProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [username, setUsername] = useState("");

  // Fechas de prueba: 25/11/2025 -> hoy
  const FROM = new Date("2025-11-25T00:00:00");
  const TO = new Date();

  useEffect(() => {
    async function load() {
      try {
        const data = await fetchAllProblems();
        const onlyNoTcsInRange = filterByRangeAndTcs(data, FROM, TO, false);
        setProblems(sortByStartTimeDesc(onlyNoTcsInRange));
      } catch (e) {
        setError(e.message);
      } finally {
        setLoading(false);
      }
    }
    load();
  }, []);

  if (loading) return <h2>Cargando problemas de terceros…</h2>;
  if (error)   return <h2 style={{ color: "red" }}>{error}</h2>;
  if (problems.length === 0)
    return <h2>No hay problemas de terceros entre el 25/11/2025 y hoy.</h2>;

  return (
    <>
      <h2>Problemas Otros</h2>
      <UsernameInput value={username} onChange={setUsername} />
      {problems.map((p) => (
        <ProblemCard key={p.problemId} problem={p} username={username} />
      ))}
    </>
  );
}
