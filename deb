// src/api/problems.js

// ==============================
// 0) CONFIG OPCIONAL DE FECHA
// - ONLY_DATE: si pones "YYYY-MM-DD" filtra SOLO ese día local
// - Déjalo en null para NO limitar por fecha (trae histórico)
// ==============================
export const ONLY_DATE = null;

// ==============================
// 1) BASE DE LA API (de .env)
// ==============================
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, "");
if (!BASE) throw new Error("Falta VITE_API_URL en .env (ej: https://xxxxx.brs.devtunnels.ms)");

const API = `${BASE}/api/Problems`;

// ==============================
// 2) Normalizador robusto
// ==============================
function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    // start/end (acepta diferentes nombres que puede mandar tu API)
    const startRaw =
      p.startTime ??
      p.startTimeUtc ??
      p.StartTime ??
      p.StartTimeUtc ??
      p.start_date ??
      null;

    const endRaw =
      p.endTime ??
      p.endTimeUtc ??
      p.EndTime ??
      p.EndTimeUtc ??
      p.end_date ??
      null;

    // jurisdicción
    const jurisRaw =
      p.jurisdiction?.label ??
      p.jurisdiction?.name ??
      p.jurisdiction?.Jurisdiction ??
      p.Jurisdiction ??
      p.jurisdiction ??
      p.label ??
      p.Label ??
      "";

    const juris = typeof jurisRaw === "string" ? jurisRaw.trim().toUpperCase() : "";
    const isTcs =
      p.jurisdiction?.isTcs ??
      (typeof juris === "string" ? (juris === "TCS" ? true : false) : false) ??
      false;

    // ids/títulos
    const problemId = p.problemId ?? p.displayId ?? p.id ?? "";
    const title = p.title ?? p.shortDescription ?? "(sin título)";

    // campos que usa el ProblemCard
    const severityLevel = p.severityLevel ?? p.severity ?? "";
    const impactLevel = p.impactLevel ?? p.impact ?? "";
    const environment = p.environment ?? p.environmentName ?? p.Environment ?? "";
    const affectedCI =
      p.affectedCI ??
      p.affectedEntities ??
      p.affectedEntitiesList ??
      [];

    // status / tenant
    const status = p.status ?? p.state ?? ""; // "OPEN" | "CLOSED"
    const tenant = p.tenant ?? p.domain ?? "";

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment,
      affectedCI,
      status,
      tenant,
      label: isTcs ? "TCS" : "NO TCS",
      isTcs,
      startTime: startRaw ? new Date(startRaw).toISOString() : null,
      endTime: endRaw ? new Date(endRaw).toISOString() : null,
    };
  });
}

// ==============================
// 3) Fetch de UNA página con query-params
// ==============================
async function fetchPage({ pageNumber, pageSize, startIso, endIso }) {
  const params = new URLSearchParams();
  params.set("pageNumber", String(pageNumber));
  params.set("pageSize", String(pageSize));
  if (startIso) params.set("start", startIso);
  if (endIso) params.set("end", endIso);

  const url = `${API}?${params.toString()}`;
  const res = await fetch(url, { headers: { accept: "application/json" } });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} en ${url}\n${txt}`);
  }

  // Puede venir array directo o envuelto
  const json = await res.json();
  const items = Array.isArray(json)
    ? json
    : json?.results || json?.items || json?.data || json?.value || [];

  return normalize(items);
}

// ==============================
// 4) Rango para un solo día local (opcional)
// ==============================
function getDayRange(dateStr /* YYYY-MM-DD */) {
  const start = new Date(`${dateStr}T00:00:00`);
  const end = new Date(`${dateStr}T23:59:59`);
  return { startIso: start.toISOString(), endIso: end.toISOString() };
}

// ==============================
// 5) Fetch histórico con paginado + onBatch (streaming)
//    NUEVO: filtros opcionales statusFilter y environmentFilter
//    - recentDays: si lo pasas (ej: 7) ignora ONLY_DATE y trae sólo lo reciente
// ==============================
export async function fetchAllProblems({
  onlyDate = ONLY_DATE,
  pageSize = 500,
  maxPages = 40,
  onBatch,                 // (items) => {}  (opcional)
  tcsFilter,               // true -> solo TCS, false -> solo NO TCS, undefined -> todos
  startIso,
  endIso,
  recentDays,              // número de días recientes (p.ej. 7)
  statusFilter,            // "OPEN" | "CLOSED" (ignora mayúsculas/minúsculas)
  environmentFilter,       // "Productivo" | "NoProductivo" (ignora espacios y mayúsculas)
} = {}) {
  // Si piden recentDays, override de rango:
  let range = { startIso, endIso };
  if (typeof recentDays === "number" && recentDays > 0) {
    const end = new Date();
    const start = new Date();
    start.setDate(end.getDate() - recentDays);
    range = { startIso: start.toISOString(), endIso: end.toISOString() };
  }

  // Si no pasan recentDays y sí pasan onlyDate, usar ese día puntual:
  if (!range.startIso && !range.endIso && typeof onlyDate === "string") {
    range = getDayRange(onlyDate);
  }

  // Nota: si range sigue vacío => NO ponemos start/end => el API devuelve TODO el historial
  let all = [];
  for (let page = 1; page <= maxPages; page++) {
    const batch = await fetchPage({
      pageNumber: page,
      pageSize,
      startIso: range.startIso,
      endIso: range.endIso,
    });
    if (!batch.length) break;

    // === Filtros ===
    let filtered = batch;

    if (typeof tcsFilter === "boolean") {
      filtered = filtered.filter((x) => x.isTcs === tcsFilter);
    }

    if (statusFilter) {
      const v = String(statusFilter).toUpperCase();
      filtered = filtered.filter(
        (x) => String(x.status || "").toUpperCase() === v
      );
    }

    if (environmentFilter) {
      const wanted = String(environmentFilter).replace(/\s+/g, "").toUpperCase();
      filtered = filtered.filter((x) =>
        String(x.environment || "").replace(/\s+/g, "").toUpperCase() === wanted
      );
    }

    if (onBatch) onBatch(filtered);
    all = all.concat(filtered);

    if (batch.length < pageSize) break; // última página
  }

  // Ordenar: más recientes primero (por startTime)
  all.sort((a, b) => {
    const da = a.startTime ? new Date(a.startTime).getTime() : 0;
    const db = b.startTime ? new Date(b.startTime).getTime() : 0;
    return db - da;
  });

  return all;
}

// ==============================
// 6) Conveniencias
// ==============================

// Día puntual de TCS (si no pasas dateStr y ONLY_DATE es null, igual trae TODO)
export const fetchTcsProblemsDay = (dateStr = ONLY_DATE, opts = {}) =>
  fetchAllProblems({ onlyDate: dateStr, tcsFilter: true, ...opts });

// Día puntual de NO TCS
export const fetchNoTcsProblemsDay = (dateStr = ONLY_DATE, opts = {}) =>
  fetchAllProblems({ onlyDate: dateStr, tcsFilter: false, ...opts });

// Todo el histórico TCS (sin fecha)
export const fetchTcsAllHistory = (opts = {}) =>
  fetchAllProblems({ onlyDate: null, tcsFilter: true, ...opts });

// Todo el histórico NO TCS (sin fecha)
export const fetchNoTcsAllHistory = (opts = {}) =>
  fetchAllProblems({ onlyDate: null, tcsFilter: false, ...opts });

// Solo lo reciente (ej: últimos N días) — TCS/NO TCS o todos
export const fetchRecentProblems = (recentDays = 7, opts = {}) =>
  fetchAllProblems({ onlyDate: null, recentDays, ...opts });

// Helpers específicos que necesitas:
// - TCS, OPEN, recientes
export const fetchRecentOpenTcs = (recentDays = 7, environment) =>
  fetchAllProblems({
    recentDays,
    tcsFilter: true,
    statusFilter: "OPEN",
    environmentFilter: environment, // "Productivo" | "NoProductivo" (opcional)
  });

// - NO TCS, OPEN, recientes
export const fetchRecentOpenNoTcs = (recentDays = 7, environment) =>
  fetchAllProblems({
    recentDays,
    tcsFilter: false,
    statusFilter: "OPEN",
    environmentFilter: environment,
  });