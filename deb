// Worker.cs
private async Task<List<DBProblem>> MapToDBProblems(List<DynatraceProblem> problems, APIToken token)
{
    // 1) Calcular títulos únicos y precargar/renovar predicciones en caché
    var uniqueTitles = problems
        .Select(p => p?.Title)
        .Where(t => !string.IsNullOrWhiteSpace(t))
        .Distinct()
        .ToList();

    // Precarga/refresh del caché con el MLPredictor (usa TryPredictByTitle internamente)
    await PredictionCache.UpdateOrStorePredictionsAsync(uniqueTitles, _predictor);

    // 2) Mapear a DBProblem
    var dbProblems = new List<DBProblem>();

    foreach (var problem in problems)
    {
        if (problem == null)
            continue;

        // Asegurar entradas no nulas para el matcher
        var impacted = problem.ImpactedEntities ?? new List<ProblemEntity>();
        var evidence = problem.EvidenceDetails ?? new EvidenceDetails();

        // Resolver CI afectados (tu lógica existente)
        var affectedCI = await _serverMatcher.FindAffectedServersAsync(impacted, evidence);

        // ShortDescription: en tu caso usas el Title
        var shortDescription = problem?.Title ?? string.Empty;

        // ---- NUEVA LÓGICA: convertir predicción del caché a etiqueta string ----
        string jurisdiction = "Unknown";
        bool isTcs;
        float probability;

        if (!string.IsNullOrWhiteSpace(problem.Title) &&
            PredictionCache.TryGetPrediction(problem.Title, out isTcs, out probability))
        {
            jurisdiction = isTcs ? "TCS" : "NO TCS";
        }

        // Si luego quieres guardar la probabilidad en BD, amplía el constructor de DBProblem.
        // dbProblems.Add(new DBProblem(problem, token.Environment, token.Tenant, shortDescription, affectedCI, jurisdiction, probability));

        dbProblems.Add(new DBProblem(problem, token.Environment, token.Tenant, shortDescription, affectedCI, jurisdiction));
    }

    return dbProblems;
}