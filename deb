// src/api/problems.js

// ==============================
// CONFIG OPCIONAL FECHA
// ==============================
export const ONLY_DATE = null;

// ==============================
// BASE DE LA API (de .env)
// ==============================
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, "");
if (!BASE) throw new Error("Falta VITE_API_URL en .env (ej: https://xxxxx.brs.devtunnels.ms)");

const API = `${BASE}/api/Problems`;

// ==============================
// Normalizador robusto
// ==============================
function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    const startRaw =
      p.startTime ??
      p.startTimeUtc ??
      p.StartTime ??
      p.StartTimeUtc ??
      p.start_date ??
      null;

    const endRaw =
      p.endTime ??
      p.endTimeUtc ??
      p.EndTime ??
      p.EndTimeUtc ??
      p.end_date ??
      null;

    const jurisRaw =
      p.jurisdiction?.label ??
      p.jurisdiction?.name ??
      p.jurisdiction?.Jurisdiccion ??
      p.Jurisdiccion ??
      p.jurisdiction ??
      p.label ??
      p.Label ??
      "";

    const juris = typeof jurisRaw === "string" ? jurisRaw.trim().toUpperCase() : "";
    const isTcs = juris === "TCS";

    const problemId = p.problemId ?? p.displayId ?? p.id ?? "";
    const title = p.title ?? p.shortDescription ?? "(sin título)";
    const severityLevel = p.severityLevel ?? p.severity ?? "";
    const impactLevel = p.impactLevel ?? p.impact ?? "";
    const environment = p.environment ?? p.environmentName ?? "";
    const affectedCI =
      p.affectedCI ?? p.affectedEntities ?? p.affectedEntitiesList ?? [];

    const status = p.status ?? p.state ?? "";
    const tenant = p.tenant ?? p.domain ?? "";

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment,
      affectedCI,
      status,
      tenant,
      label: isTcs ? "TCS" : "NO TCS",
      isTcs,
      startTime: startRaw ? new Date(startRaw).toISOString() : null,
      endTime: endRaw ? new Date(endRaw).toISOString() : null,
    };
  });
}

// ==============================
// Fetch de una página
// ==============================
async function fetchPage({ pageNumber, pageSize, startIso, endIso }) {
  const params = new URLSearchParams();
  params.set("pageNumber", String(pageNumber));
  params.set("pageSize", String(pageSize));
  if (startIso) params.set("start", startIso);
  if (endIso) params.set("end", endIso);

  const url = `${API}?${params.toString()}`;
  const res = await fetch(url, { headers: { accept: "application/json" } });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} en ${url}\n${txt}`);
  }

  const json = await res.json();
  const items = Array.isArray(json)
    ? json
    : json?.results || json?.items || json?.data || json?.value || [];

  return normalize(items);
}

// ==============================
// Función base con paginado
// ==============================
export async function fetchAllProblems({
  pageSize = 500,
  maxPages = 40,
  recentDays = 7,
  tcsFilter,
} = {}) {
  const end = new Date();
  const start = new Date();
  start.setDate(end.getDate() - recentDays);

  const range = { startIso: start.toISOString(), endIso: end.toISOString() };

  let all = [];
  for (let page = 1; page <= maxPages; page++) {
    const batch = await fetchPage({
      pageNumber: page,
      pageSize,
      startIso: range.startIso,
      endIso: range.endIso,
    });

    if (!batch.length) break;

    const filtered =
      typeof tcsFilter === "boolean" ? batch.filter((x) => x.isTcs === tcsFilter) : batch;

    all = all.concat(filtered);
    if (batch.length < pageSize) break;
  }

  all.sort((a, b) => {
    const da = a.startTime ? new Date(a.startTime).getTime() : 0;
    const db = b.startTime ? new Date(b.startTime).getTime() : 0;
    return db - da;
  });

  return all;
}

// ==============================
// Helpers
// ==============================
export const fetchOpenRecentProblems = async ({
  recentDays = 7,
  tcsFilter,
  limit = 500,
} = {}) => {
  const all = await fetchAllProblems({ recentDays, tcsFilter });
  const abiertas = all.filter((x) => (x.status || "").toUpperCase() === "OPEN");
  return abiertas.slice(0, limit);
};

export const fetchOpenRecentTcsProblems = (opts = {}) =>
  fetchOpenRecentProblems({ ...opts, tcsFilter: true });

export const fetchOpenRecentNoTcsProblems = (opts = {}) =>
  fetchOpenRecentProblems({ ...opts, tcsFilter: false });

-----

import { useEffect, useState } from "react";
import { fetchOpenRecentTcsProblems } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

export default function TCSProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [username, setUsername] = useState("");

  useEffect(() => {
    let mounted = true;
    async function load() {
      try {
        setLoading(true);
        const items = await fetchOpenRecentTcsProblems({ recentDays: 7 });
        if (mounted) setProblems(items);
      } catch (err) {
        if (mounted) setError(err.message);
      } finally {
        if (mounted) setLoading(false);
      }
    }
    load();
    return () => (mounted = false);
  }, []);

  if (error) return <p style={{ color: "red" }}>Error: {error}</p>;

  return (
    <div style={{ maxWidth: "900px", margin: "0 auto", padding: "1rem" }}>
      <h2>Problemas TCS Abiertos Recientes</h2>
      <UsernameInput value={username} onChange={setUsername} />
      {loading && <p>Cargando...</p>}
      {!loading && problems.length === 0 && <p>No hay problemas abiertos.</p>}
      {problems.map((p) => (
        <ProblemCard key={p.problemId} problem={p} username={username} />
      ))}
    </div>
  );
}

------
import { useEffect, useState } from "react";
import { fetchOpenRecentNoTcsProblems } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

export default function NoTCSProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [username, setUsername] = useState("");

  useEffect(() => {
    let mounted = true;
    async function load() {
      try {
        setLoading(true);
        const items = await fetchOpenRecentNoTcsProblems({ recentDays: 7 });
        if (mounted) setProblems(items);
      } catch (err) {
        if (mounted) setError(err.message);
      } finally {
        if (mounted) setLoading(false);
      }
    }
    load();
    return () => (mounted = false);
  }, []);

  if (error) return <p style={{ color: "red" }}>Error: {error}</p>;

  return (
    <div style={{ maxWidth: "900px", margin: "0 auto", padding: "1rem" }}>
      <h2>Problemas NO TCS Abiertos Recientes</h2>
      <UsernameInput value={username} onChange={setUsername} />
      {loading && <p>Cargando...</p>}
      {!loading && problems.length === 0 && <p>No hay problemas abiertos.</p>}
      {problems.map((p) => (
        <ProblemCard key={p.problemId} problem={p} username={username} />
      ))}
    </div>
  );
}