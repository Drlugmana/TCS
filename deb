using System.Data;
using System.Text;
using Microsoft.ML;
using Microsoft.ML.Data;
using DynatraceJurisdictionModelTraining.Models;
using ExcelDataReader;

namespace DynatraceJurisdictionModelTraining
{
    internal class Program
    {
        // Rutas
        private static readonly string _base = AppContext.BaseDirectory;
        private static readonly string _dataPath = Path.Combine(_base, "Data", "Catalog_Eventos_Nov2025.xlsx"); // <-- tu archivo
        private static readonly string _modelPath = Path.Combine(_base, "ML", "jurisdiction_model.zip");

        // ML
        private static MLContext _ml = new MLContext(seed: 42);

        static void Main(string[] args)
        {
            // 1) Carga y split
            var split = LoadCatalogFromExcel(_dataPath, sheetName: "DataTrain_TCS", positiveText: "SI TCS");
            var train = split.TrainSet;
            var test  = split.TestSet;

            // 2) Pipeline (solo texto del título)
            var pipeline = BuildPipeline();

            // 3) Entrenamiento
            var model = pipeline.Fit(train);

            // 4) Evaluación
            Evaluate(model, test);

            // 5) Guardar modelo
            Directory.CreateDirectory(Path.GetDirectoryName(_modelPath)!);
            _ml.Model.Save(model, train.Schema, _modelPath);
            Console.WriteLine($"> Modelo guardado en: {_modelPath}");

            // 6) Probar rápido
            var engine = _ml.Model.CreatePredictionEngine<IncidentData, IncidentPrediction>(model);
            var sample = new IncidentData { ProblemTitle = "[URGENTE] : Extractor Movimientos Producción Retrasado - EXPMOV05" };
            var pred = engine.Predict(sample);
            Console.WriteLine($"> Sample: {sample.ProblemTitle}");
            Console.WriteLine($"> PredictedEsTCS={pred.PredictedEsTCS}  Prob={pred.Probability:P2}");
        }

        // =======================
        //  PIPELINE
        // =======================
        private static IEstimator<ITransformer> BuildPipeline()
        {
            // Featuriza solo el título; puedes añadir más pasos si luego agregas más columnas
            var pipeline =
                _ml.Transforms.Text.FeaturizeText(outputColumnName: "ProblemTitleFeaturized", inputColumnName: nameof(IncidentData.ProblemTitle))
                  .Append(_ml.Transforms.Concatenate("Features", "ProblemTitleFeaturized"))
                  .Append(_ml.Transforms.ReplaceMissingValues("Features"))
                  .Append(_ml.BinaryClassification.Trainers.SdcaLogisticRegression(
                      labelColumnName: nameof(IncidentData.EsTCS),
                      featureColumnName: "Features"));

            return pipeline;
        }

        // =======================
        //  EVALUACIÓN
        // =======================
        private static void Evaluate(ITransformer model, IDataView test)
        {
            var predictions = model.Transform(test);
            var metrics = _ml.BinaryClassification.Evaluate(predictions, labelColumnName: nameof(IncidentData.EsTCS));

            Console.WriteLine("==== Métricas ====");
            Console.WriteLine($"Accuracy:      {metrics.Accuracy:P2}");
            Console.WriteLine($"AUC:           {metrics.AreaUnderRocCurve:P2}");
            Console.WriteLine($"F1Score:       {metrics.F1Score:P2}");
            Console.WriteLine($"Pos. Precision {metrics.PositivePrecision:P2} | Recall {metrics.PositiveRecall:P2}");
            Console.WriteLine($"Neg. Precision {metrics.NegativePrecision:P2} | Recall {metrics.NegativeRecall:P2}");
        }

        // =======================
        //  LECTURA EXCEL → IncidentData
        // =======================
        private static DataOperationsCatalog.TrainTestData LoadCatalogFromExcel(
            string excelPath,
            string sheetName = "",
            string positiveText = "SI TCS",
            double testFraction = 0.2)
        {
            Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);

            using var stream = File.Open(excelPath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            using var reader = ExcelReaderFactory.CreateReader(stream);

            var conf = new ExcelDataSetConfiguration
            {
                ConfigureDataTable = _ => new ExcelDataTableConfiguration
                {
                    UseHeaderRow = true,
                    FilterTable = t => string.IsNullOrWhiteSpace(sheetName) || t.TableName.Equals(sheetName, StringComparison.OrdinalIgnoreCase)
                }
            };

            var dataSet = reader.AsDataSet(conf);
            var table = dataSet.Tables[0]; // la hoja filtrada

            var rows = table.AsEnumerable()
                            .Where(r => !r.IsNull("ProblemTitle") || !r.IsNull("ShortDescription")); // por si tu columna se llama ShortDescription

            // Detecta automáticamente si tu columna de texto se llama "ProblemTitle" o "ShortDescription"
            string textCol = table.Columns.Contains("ProblemTitle") ? "ProblemTitle" : "ShortDescription";
            string labelCol = table.Columns.Contains("ALCANCE") ? "ALCANCE" : "EsTCS"; // soporta ambos casos

            var list = rows.Select(r => new IncidentData
            {
                ProblemTitle = r[textCol]?.ToString() ?? string.Empty,
                // convierte "SI TCS" / "NO TCS" o 1/0 / true/false
                EsTCS = ToBool(r[labelCol], positiveText)
            }).Where(x => !string.IsNullOrWhiteSpace(x.ProblemTitle)).ToList();

            var dv = _ml.Data.LoadFromEnumerable(list);
            return _ml.Data.TrainTestSplit(dv, testFraction: testFraction);
        }

        private static bool ToBool(object? value, string positiveText)
        {
            if (value == null) return false;
            var s = value.ToString()!.Trim();

            if (bool.TryParse(s, out var b)) return b;
            if (int.TryParse(s, out var i)) return i != 0;

            // “SI TCS” vs “NO TCS”
            if (s.Equals(positiveText, StringComparison.OrdinalIgnoreCase)) return true;
            if (s.Equals("NO TCS", StringComparison.OrdinalIgnoreCase)) return false;

            // Fallback: cualquier “SI” -> true
            if (s.Equals("SI", StringComparison.OrdinalIgnoreCase)) return true;
            return false;
        }
    }
}