// src/api/problems.js
const API_BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, ""); // sin slash final
const PROBLEMS_PATH = "/api/Problems";
const PAGE_SIZE = 500;              // ajusta si tu API permite más/menos
const MAX_PAGES = 200;              // tope de seguridad

// ===== 1) URL builder =====
function buildQueryUrl({ pageNumber, pageSize, start, end }) {
  const u = new URL(API_BASE + PROBLEMS_PATH);
  u.searchParams.set("pageNumber", String(pageNumber));
  u.searchParams.set("pageSize", String(pageSize));
  if (start) u.searchParams.set("start", new Date(start).toISOString());
  if (end)   u.searchParams.set("end",   new Date(end).toISOString());
  return u.toString();
}

// ===== 2) Normalizador robusto =====
function buildDynatraceUrl({ problemId, tenant, href }) {
  // Si backend ya entrega un link directo
  if (typeof href === "string" && href.startsWith("http")) return href;

  // Si tenemos tenant + pid, construimos
  if (!problemId || !tenant) return "";
  const clean = String(tenant).trim().replace(/\/+$/, "");
  const base = clean.startsWith("http") ? clean : `https://${clean}`;
  return `${base}/#problems/problemdetails;pid=${problemId}`;
}

function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    // Fechas (varias variantes)
    const startRaw =
      p.startTime ?? p.startTimeUtc ?? p.StartTime ?? p.StartTimeUtc ?? p.start_date ?? null;

    const endRaw =
      p.endTime ?? p.endTimeUtc ?? p.EndTime ?? p.EndTimeUtc ?? p.end_date ?? null;

    // Jurisdicción -> TCS/NO TCS
    const jurisRaw =
      p.jurisdiction?.label ??
      p.jurisdiction?.name ??
      p.jurisdiction2?.Jurisdiction ??
      p.Jurisdiction ??
      p.jurisdiction ??
      p.label ??
      p.Label ??
      "";

    const juris = typeof jurisRaw === "string" ? jurisRaw.trim().toUpperCase() : "";
    const isTcs = p.jurisdiction?.isTcs ?? (juris === "TCS");

    // Campos clave que usa la tarjeta
    const problemId     = p.problemId ?? p.displayId ?? p.id ?? "";
    const title         = p.title ?? p.shortDescription ?? "(sin título)";
    const severityLevel = p.severityLevel ?? p.severity ?? "";
    const impactLevel   = p.impactLevel ?? p.impact ?? "";
    const environment   = p.environment ?? p.environmentName ?? "";
    const affectedCI    = p.affectedCI ?? p.affectedEntities ?? p.affectedEntitiesList ?? [];
    const status        = p.status ?? p.state ?? "";
    const tenant        = p.tenant ?? p.environmentTenant ?? p.dynatraceTenant ?? "";

    // Posibles links directos del backend
    const href =
      p.problemUrl ?? p.url ?? p.link ?? (Array.isArray(p.links) ? p.links[0]?.href : "");

    const dynatraceUrl = buildDynatraceUrl({ problemId, tenant, href });

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment,
      affectedCI,
      status,
      tenant,
      label: isTcs ? "TCS" : "NO TCS",
      isTcs,
      startTime: startRaw ? new Date(startRaw).toISOString() : null,
      endTime:   endRaw   ? new Date(endRaw).toISOString()   : null,
      dynatraceUrl,
    };
  });
}

// ===== 3) Fetch con paginación =====
async function fetchPage({ pageNumber, pageSize, start, end }) {
  const url = buildQueryUrl({ pageNumber, pageSize, start, end });
  const res = await fetch(url);
  if (!res.ok) throw new Error(`HTTP ${res.status} en ${url}`);
  const data = await res.json();
  return Array.isArray(data) ? data : (data?.items ?? []); // soporta formato { items: [] }
}

async function fetchAllPages({ start, end }) {
  let page = 1;
  const out = [];
  for (; page <= MAX_PAGES; page++) {
    const items = await fetchPage({ pageNumber: page, pageSize: PAGE_SIZE, start, end });
    if (!items.length) break;
    out.push(...items);
  }
  return normalize(out);
}

// ===== 4) Helpers por pestaña =====
export async function fetchTcsProblems({ start, end } = {}) {
  const all = await fetchAllPages({ start, end });
  return all.filter((p) => p.isTcs);
}

export async function fetchOtherProblems({ start, end } = {}) {
  const all = await fetchAllPages({ start, end });
  return all.filter((p) => !p.isTcs);
}

export async function fetchAllProblems({ start, end } = {}) {
  return fetchAllPages({ start, end });
}