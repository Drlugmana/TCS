// src/utils/slaUtils.js

/** ========================= SLA ========================= **/
export function getSlaMinutes(criticidad) {
  switch (criticidad) {
    case 'S1': return 10;
    case 'S2': return 30;
    case 'S3': return 45;
    default:   return 120; // S4
  }
}

export function getColorByPercent(percent) {
  if (percent > 75) return '#ffffff';
  if (percent > 50) return '#fff9c4';
  if (percent > 25) return '#ffe082';
  return '#ef9a9a';
}

export function getButtonColorByPercent(percent) {
  if (percent > 75) return '#1565c0';
  if (percent > 50) return '#fbc02d';
  if (percent > 25) return '#fb8c00';
  return '#d32f2f';
}

/** ===================== CRITICIDAD (BIA) ===================== **/

const rank = { S1: 0, S2: 1, S3: 2, S4: 3 };
const peor = (a, b) => (rank[a] < rank[b] ? a : b);

/** Lee letra BIA A–E de cadenas como "C - BIA Crítica" ⇒ S1..S4 */
function letraBIAaSx(str) {
  if (!str) return null;
  const v = String(str).trim().toUpperCase();
  // Al inicio: "A - ...", "B) ...", "C ..." etc.
  const m = v.match(/^\s*([A-E])(?:\s*[-) ]|$)/);
  if (!m) return null;
  const L = m[1];
  if (L === 'A') return 'S1';
  if (L === 'B') return 'S2';
  if (L === 'C') return 'S3';
  // D y E son S4 según tu documento
  return 'S4';
}

/** Mapea severidades estándar (evita confundir "BIA CRÍTICA" con CRITICAL) */
function textoSeveridadASx(str) {
  if (!str) return null;
  const v = String(str).trim().toUpperCase();
  if (/\bCRITICAL\b/.test(v)) return 'S1';
  if (/\bHIGH\b|\bALTA\b/.test(v)) return 'S2';
  if (/\bMEDIUM\b|\bMEDIA\b/.test(v)) return 'S3';
  if (/\bLOW\b|\bBAJA\b/.test(v)) return 'S4';
  return null;
}

/** Normaliza cualquier valor (S1..S4, A/B/C, "C - BIA Crítica", texto EN/ES) a Sx */
export function normalizarCriticidad(valor) {
  if (valor == null) return 'S4';

  // 1) Si trae la letra BIA al inicio, úsala
  const viaLetra = letraBIAaSx(valor);
  if (viaLetra) return viaLetra;

  const v = String(valor).trim().toUpperCase();

  // 2) Directo S1..S4
  if (/^S[1-4]$/.test(v)) return v;

  // 3) Letras aisladas A/B/C
  if (v === 'A') return 'S1';
  if (v === 'B') return 'S2';
  if (v === 'C') return 'S3';

  // 4) Texto estándar
  const sev = textoSeveridadASx(v);
  if (sev) return sev;

  // 5) Fallback
  return 'S4';
}

/** Detecta EnP / No Productivo (tolerante a variantes) */
function esNoProductivo(env) {
  if (!env) return false;
  const e = String(env).toUpperCase();
  return (
    e.includes('ENP') ||
    e.includes('NO PRODUCT') ||
    e.includes('NON PROD') ||
    e.includes('NON-PROD') ||
    e.includes('NPRD') ||
    (e.includes('NP') && !e.includes('PROD')) // "NP" sin "PROD"
  );
}

/**
 * Calcula criticidad con trazabilidad.
 * Reglas:
 *  0) Si es EnP/No Productivo ⇒ S4.
 *  1) Si alguna CI trae criticidad/criticality/businessCriticality ⇒ peor (S1 peor).
 *  2) Si no, toma la peor entre severityLevel e impactLevel del problema.
 *  3) Si nada, S4.
 *
 * Devuelve: { criticidad: 'S1'|'S2'|'S3'|'S4', fuente: 'ENP'|'CI'|'SEVERITY/IMPACT'|'DEFAULT', detalles: {...} }
 */
export function calcularCriticidadDetallada(problem) {
  // Regla 0: EnP ⇒ S4
  const env = problem?.environment || problem?.entorno;
  if (esNoProductivo(env)) {
    return { criticidad: 'S4', fuente: 'ENP', detalles: { environment: env } };
  }

  // Regla 1: buscar en CIs afectadas (incluye todas las variantes de campo CMDB conocidas)
  const affected = Array.isArray(problem?.affectedCI) ? problem.affectedCI : [];
  let worstFromCI = 'S4';
  let tuvoCI = false;
  let fuenteCampo = null;
  let ciElegida = null;
  let valorOriginal = null;

  for (const ci of affected) {
    const candRaw =
      ci?.criticidad ??
      ci?.criticality ??
      ci?.businessCriticality ??
      ci?.businesscriticality ??
      ci?.ciBusinessCriticality ??
      ci?.ciBusinesscriticality ??
      ci?.cibusinessCriticality ??
      ci?.cibusinesscriticality ??
      ci?.ci_business_criticality ??
      ci?.ci_businessCriticality ??
      ci?.ci_businesscriticality ??
      ci?.severity ??  // por si alguna CI usa "severity"
      ci?.tier;

    if (candRaw == null) continue;

    const cand = normalizarCriticidad(candRaw);
    tuvoCI = true;

    if (rank[cand] < rank[worstFromCI]) {
      worstFromCI = cand;
      // Guarda qué campo coincidió y con qué CI/valor
      const posiblesCampos = [
        'criticidad','criticality','businessCriticality','businesscriticality',
        'ciBusinessCriticality','ciBusinesscriticality','cibusinessCriticality','cibusinesscriticality',
        'ci_business_criticality','ci_businessCriticality','ci_businesscriticality',
        'severity','tier'
      ];
      fuenteCampo = posiblesCampos.find(k => k in ci) || 'desconocido';
      ciElegida = ci?.name || ci?.Nombre || ci?.id || '';
      valorOriginal = candRaw;
    }
  }

  if (tuvoCI) {
    return {
      criticidad: worstFromCI,
      fuente: 'CI',
      detalles: { campo: fuenteCampo, ci: ciElegida, valor: valorOriginal }
    };
  }

  // Regla 2: peor entre severidad/impacto del problema
  const sev = normalizarCriticidad(problem?.severityLevel);
  const imp = normalizarCriticidad(problem?.impactLevel);
  if (problem?.severityLevel || problem?.impactLevel) {
    return {
      criticidad: peor(sev, imp),
      fuente: 'SEVERITY/IMPACT',
      detalles: { severityLevel: problem?.severityLevel, impactLevel: problem?.impactLevel }
    };
  }

  // Regla 3: fallback
  return { criticidad: 'S4', fuente: 'DEFAULT', detalles: {} };
}

/** Azúcar: si solo necesitas el string 'Sx' */
export function calcularCriticidad(problemOrAffected) {
  if (Array.isArray(problemOrAffected)) {
    return calcularCriticidadDetallada({ affectedCI: problemOrAffected }).criticidad;
  }
  return calcularCriticidadDetallada(problemOrAffected).criticidad;
}