// ===============================
// src/api/problems.js
// ===============================

// 0) CONFIG OPCIONAL FECHA
// Si pones una fecha "YYYY-MM-DD" fuerza modo día puntual.
// Si lo dejas en null => SIN límite por fecha (histórico completo).
export const ONLY_DATE = null;

// 1) BASE DE LA API (desde .env)
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, "");
if (!BASE) throw new Error("Falta VITE_API_URL en .env (ej: https://xxxxx.brs.devtunnels.ms)");
const API = `${BASE}/api/Problems`;

// ===================================
// 2) Normalizador robusto
// ===================================
function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    // Start / End (acepta nombres diversos)
    const startRaw =
      p.startTime ??
      p.startTimeUtc ??
      p.StartTime ??
      p.StartTimeUtc ??
      p.start_date ??
      null;

    const endRaw =
      p.endTime ??
      p.endTimeUtc ??
      p.EndTime ??
      p.EndTimeUtc ??
      p.end_date ??
      null;

    // Jurisdicción (TCS / NO TCS)
    const jurisRaw =
      p.jurisdiction?.label ??
      p.jurisdiction?.name ??
      p.jurisdiction?.Jurisdiction ??
      p.Jurisdiction ??
      p.jurisdiction ??
      p.label ??
      p.Label ??
      "";

    const juris = typeof jurisRaw === "string" ? jurisRaw.trim().toUpperCase() : "";
    const isTcs =
      p.jurisdiction?.isTcs ??
      (typeof juris === "string" ? (juris === "TCS" ? true : false) : false) ??
      false;

    // ids/títulos
    const problemId = p.problemId ?? p.displayId ?? p.id ?? p.ProblemId ?? p.DisplayId ?? "";
    const title = p.title ?? p.shortDescription ?? p.Title ?? p.ShortDescription ?? "(sin título)";

    // otros campos usados por la UI
    const severityLevel = p.severityLevel ?? p.severity ?? p.SeverityLevel ?? "";
    const impactLevel = p.impactLevel ?? p.impact ?? p.ImpactLevel ?? "";
    const environment = p.environment ?? p.environmentName ?? p.Environment ?? p.EnvironmentName ?? "";
    const affectedCI =
      p.affectedCI ??
      p.affectedEntities ??
      p.affectedEntitiesList ??
      p.AffectedCI ??
      p.AffectedEntities ??
      p.AffectedEntitiesList ??
      [];

    // status: puede venir como status/state/problemStatus
    const rawStatus = (p.status ?? p.state ?? p.problemStatus ?? p.Status ?? p.State ?? "").toString().trim();
    const up = rawStatus.toUpperCase();

    // Si NO viene status, inferimos por endTime (si tiene endTime => CLOSED)
    let status;
    if (!up) status = endRaw ? "CLOSED" : "OPEN";
    else if (up.includes("CLOSED") || up.includes("RESOLVED")) status = "CLOSED";
    else if (up.includes("OPEN")) status = "OPEN";
    else status = endRaw ? "CLOSED" : "OPEN";

    const tenant = p.tenant ?? p.domain ?? p.Tenant ?? p.Domain ?? "";

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment,
      affectedCI,
      status,
      tenant,
      label: isTcs ? "TCS" : "NO TCS",
      isTcs,
      startTime: startRaw ? new Date(startRaw).toISOString() : null,
      endTime: endRaw ? new Date(endRaw).toISOString() : null,
    };
  });
}

// ===================================
// 3) Fetch de UNA página con query-params
// ===================================
async function fetchPage({ pageNumber, pageSize, startIso, endIso }) {
  const params = new URLSearchParams();
  params.set("pageNumber", String(pageNumber));
  params.set("pageSize", String(pageSize));
  if (startIso) params.set("start", startIso);
  if (endIso) params.set("end", endIso);

  const url = `${API}?${params.toString()}`;
  const res = await fetch(url, { headers: { accept: "application/json" } });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} en ${url}\n${txt}`);
  }

  // Puede venir array directo o envuelto
  const json = await res.json();
  const items = Array.isArray(json)
    ? json
    : json?.results || json?.items || json?.data || json?.value || [];

  return normalize(items);
}

// ===================================
// 4) Utilidad: rango para un solo día local (YYYY-MM-DD)
// ===================================
function getDayRange(dateStr /* YYYY-MM-DD */) {
  const start = new Date(`${dateStr}T00:00:00`);
  const end = new Date(`${dateStr}T23:59:59`);
  return { startIso: start.toISOString(), endIso: end.toISOString() };
}

// 4.b) Utilidad: convierte YYYY-MM-DD a límites de día en ISO
export function toLocalDayIsoRange(dateStr) {
  return getDayRange(dateStr);
}

// ===================================
// 4.c) NUEVO: Ayer 00:00 -> Ahora (para igualar GETDATE())
// ===================================
export function getYesterdayToNowRange() {
  const now = new Date();
  const y = new Date();
  y.setDate(now.getDate() - 1);
  y.setHours(0, 0, 0, 0);
  return { startIso: y.toISOString(), endIso: now.toISOString() };
}

// ===================================
// 5) Fetch histórico con paginado + filtros opcionales
// ===================================
export async function fetchAllProblems({
  onlyDate = ONLY_DATE, // si viene string => fuerza ese día; si null => sin límite
  pageSize = 500,
  maxPages = 40,
  onBatch, // (items) => void
  tcsFilter, // true | false | undefined
  statusFilter, // "OPEN" | "CLOSED" | undefined
  environmentFilter, // "Productivo" | "NoProductivo" | undefined (o parte del texto)
  startIso, // forzar ISO inicio
  endIso, // forzar ISO fin
  recentDays, // si quieres SOLO lo reciente (ej: 2) => últimos 2 días hasta ahora
} = {}) {
  // 1) Definir rango
  let range = { startIso, endIso };

  // recentDays manda (últimos N días hasta ahora)
  if (typeof recentDays === "number" && recentDays > 0) {
    const end = new Date();
    const start = new Date();
    start.setDate(end.getDate() - recentDays);
    range = { startIso: start.toISOString(), endIso: end.toISOString() };
  }

  // onlyDate fuerza rango de ese día (si NO pasaste start/end)
  if (!range.startIso && !range.endIso && typeof onlyDate === "string") {
    range = getDayRange(onlyDate);
  }

  // Si range sigue vacío => NO ponemos start/end => el API devuelve TODO
  let all = [];

  for (let page = 1; page <= maxPages; page++) {
    const batch = await fetchPage({
      pageNumber: page,
      pageSize,
      startIso: range.startIso,
      endIso: range.endIso,
    });

    if (!batch.length) break;

    // 2) Filtros opcionales en cliente
    let filtered = batch;

    if (typeof tcsFilter === "boolean") {
      filtered = filtered.filter((x) => x.isTcs === tcsFilter);
    }

    if (statusFilter) {
      const want = String(statusFilter).toUpperCase();
      filtered = filtered.filter((x) => (x.status || "").toUpperCase() === want);
    }

    if (environmentFilter) {
      const want = String(environmentFilter).toUpperCase();
      filtered = filtered.filter((x) => (x.environment || "").toUpperCase().includes(want));
    }

    if (onBatch) onBatch(filtered);
    all = all.concat(filtered);

    if (batch.length < pageSize) break; // última página
  }

  // Ordenar: más recientes primero (por startTime)
  all.sort((a, b) => {
    const da = a.startTime ? new Date(a.startTime).getTime() : 0;
    const db = b.startTime ? new Date(b.startTime).getTime() : 0;
    return db - da;
  });

  return all;
}

// ===================================
// 6) Fetch por rango de fechas (YYYY-MM-DD)
// ===================================
export async function fetchByDateRange({
  fromDate, // "YYYY-MM-DD"
  toDate, // "YYYY-MM-DD"
  tcsFilter, // true|false|undefined
  statusFilter, // "OPEN"|"CLOSED"|undefined
  environmentFilter, // "Productivo"|"NoProductivo"|undefined
} = {}) {
  let startIso, endIso;

  if (fromDate && toDate) {
    const a = toLocalDayIsoRange(fromDate);
    const b = toLocalDayIsoRange(toDate);
    startIso = a.startIso;
    endIso = b.endIso;
  } else if (fromDate) {
    startIso = toLocalDayIsoRange(fromDate).startIso;
  } else if (toDate) {
    endIso = toLocalDayIsoRange(toDate).endIso;
  }

  return fetchAllProblems({
    onlyDate: null,
    startIso,
    endIso,
    tcsFilter,
    statusFilter,
    environmentFilter,
  });
}

// ===================================
// 7) Conveniencias (como las tenías)
// ===================================
export const fetchTcsProblemsDay = (dateStr = ONLY_DATE, opts = {}) =>
  fetchAllProblems({ onlyDate: dateStr, tcsFilter: true, ...opts });

export const fetchNoTcsProblemsDay = (dateStr = ONLY_DATE, opts = {}) =>
  fetchAllProblems({ onlyDate: dateStr, tcsFilter: false, ...opts });

export const fetchTcsAllHistory = (opts = {}) =>
  fetchAllProblems({ onlyDate: null, tcsFilter: true, ...opts });

export const fetchNoTcsAllHistory = (opts = {}) =>
  fetchAllProblems({ onlyDate: null, tcsFilter: false, ...opts });

export const fetchRecentProblems = (recentDays = 7, opts = {}) =>
  fetchAllProblems({ onlyDate: null, recentDays, ...opts });

// ===================================
// 8) NUEVO (lo que necesitas para “GETDATE()”)
// TCS + OPEN desde AYER 00:00 hasta AHORA
// ===================================
export async function fetchTcsOpenYesterdayToNow(opts = {}) {
  const { startIso, endIso } = getYesterdayToNowRange();
  return fetchAllProblems({
    onlyDate: null,
    startIso,
    endIso,
    tcsFilter: true,
    statusFilter: "OPEN",
    ...opts,
  });
}

---


import React, { useEffect, useState } from "react";
import {
  fetchTcsOpenYesterdayToNow,
  fetchTcsAllHistory,
} from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

/* ===== Detección de ambiente (idéntico) ===== */
function detectEnvironmentRaw(problem) {
  const raw =
    problem?.environmentIcon ||
    problem?.environmentText ||
    problem?.environment ||
    problem?.entorno ||
    problem?.env ||
    "";

  return String(raw).toLowerCase().trim();
}

function isProd(problem) {
  const env = detectEnvironmentRaw(problem);

  // si viene por íconos/texto directo
  if (
    env.includes("icon-noproductivo") ||
    env.includes("no-productivo") ||
    env.includes("noproductivo")
  ) {
    return false;
  }
  if (env.includes("icon-productivo")) return true;

  // heurística por palabras típicas
  const nonProdRegex =
    /\b(enp|np|qa|q\/a|dev|desa|desarrollo|test|testing|stg|stage|staging|uat|preprod|pre-prod|pre\s*prod|pre)\b/i;

  if (nonProdRegex.test(env)) return false;

  // productivo / prod / production
  if (/\b(productivo|producci[oó]n|production)\b/i.test(env)) return true;
  if (/\bprod\b/i.test(env) || /^prod[\w-]*/i.test(env)) return true;

  // default: asume prod si no encuentra nada claro
  return true;
}

/* ===== Normalización de estado OPEN/CLOSED ===== */
function normalizeStatus(p) {
  const raw = p?.status ?? p?.Status ?? p?.problemStatus ?? "";
  let s = String(raw).trim().toUpperCase();

  // si no viene estado, inferimos por endTime (si tiene endTime => CLOSED)
  if (!s) return p?.endTime ? "CLOSED" : "OPEN";

  if (s.includes("CLOSED") || s.includes("RESOLVED")) return "CLOSED";
  if (s.includes("OPEN")) return "OPEN";

  // fallback
  return p?.endTime ? "CLOSED" : "OPEN";
}

export default function TCSProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  const [username, setUsername] = useState("");

  // tabs
  const [envTab, setEnvTab] = useState("prod"); // 'prod' | 'nonprod'
  const [statusTab, setStatusTab] = useState("open"); // 'open' | 'closed'

  useEffect(() => {
    let mounted = true;

    async function load() {
      try {
        setLoading(true);
        setError(null);
        setProblems([]);

        // 1) Abiertas: AYER 00:00 -> AHORA (sincroniza con GETDATE())
        const openRecent = await fetchTcsOpenYesterdayToNow({
          pageSize: 500,
          maxPages: 40,
        });

        // 2) Cerradas: histórico completo (como antes)
        const closedHistory = await fetchTcsAllHistory({
          pageSize: 500,
          maxPages: 80, // si tienes mucho histórico, sube esto
          statusFilter: "CLOSED",
        });

        // 3) Unir (sin duplicar por problemId/displayId/id)
        const map = new Map();
        for (const p of openRecent) {
          const key = p.problemId || p.displayId || p.id;
          if (!key) continue;
          map.set(key, p);
        }
        for (const p of closedHistory) {
          const key = p.problemId || p.displayId || p.id;
          if (!key) continue;
          if (!map.has(key)) map.set(key, p);
        }

        const merged = Array.from(map.values()).sort((a, b) => {
          const da = a.startTime ? new Date(a.startTime).getTime() : 0;
          const db = b.startTime ? new Date(b.startTime).getTime() : 0;
          return db - da;
        });

        if (!mounted) return;
        setProblems(merged);
      } catch (e) {
        if (!mounted) return;
        setError(e?.message || String(e));
      } finally {
        if (mounted) setLoading(false);
      }
    }

    load();
    return () => {
      mounted = false;
    };
  }, []);

  if (error) return <h2 style={{ color: "red" }}>Error: {error}</h2>;

  // 1) por ambiente
  const prodList = problems.filter(isProd);
  const nonProdList = problems.filter((p) => !isProd(p));
  const envList = envTab === "prod" ? prodList : nonProdList;

  // 2) por estado
  const openList = envList.filter((p) => normalizeStatus(p) === "OPEN");
  const closedList = envList.filter((p) => normalizeStatus(p) === "CLOSED");
  const selectedList = statusTab === "open" ? openList : closedList;

  return (
    <div style={{ maxWidth: "900px", margin: "0 auto", padding: "1rem" }}>
      <h2>
        Problemas TCS <span>({problems.length})</span>
      </h2>

      <UsernameInput value={username} onChange={setUsername} />

      {loading && problems.length === 0 && <p>Cargando problemas TCS...</p>}
      {!loading && problems.length === 0 && (
        <p>No hay problemas TCS para mostrar.</p>
      )}

      {/* Tabs de ambiente */}
      <div style={{ display: "flex", gap: ".5rem", margin: "1rem 0 .5rem" }}>
        <button
          onClick={() => setEnvTab("prod")}
          disabled={envTab === "prod"}
          style={{
            padding: ".5rem 1rem",
            borderRadius: "999px",
            border: "1px solid #cbd5e1",
            background: envTab === "prod" ? "#dbeafe" : "#f8fafc",
            fontWeight: envTab === "prod" ? "bold" : "normal",
            cursor: envTab === "prod" ? "default" : "pointer",
          }}
        >
          Productivo ({prodList.length})
        </button>

        <button
          onClick={() => setEnvTab("nonprod")}
          disabled={envTab === "nonprod"}
          style={{
            padding: ".5rem 1rem",
            borderRadius: "999px",
            border: "1px solid #cbd5e1",
            background: envTab === "nonprod" ? "#fef3c7" : "#f8fafc",
            fontWeight: envTab === "nonprod" ? "bold" : "normal",
            cursor: envTab === "nonprod" ? "default" : "pointer",
          }}
        >
          No Productivo ({nonProdList.length})
        </button>
      </div>

      {/* Subtabs de estado */}
      <div style={{ display: "flex", gap: ".5rem", margin: ".25rem 0 1rem" }}>
        <button
          onClick={() => setStatusTab("open")}
          disabled={statusTab === "open"}
          style={{
            padding: ".35rem .9rem",
            borderRadius: "999px",
            border: "1px solid #e5e7eb",
            background: statusTab === "open" ? "#fde68a" : "#ffffff",
            fontWeight: statusTab === "open" ? "bold" : "normal",
            cursor: statusTab === "open" ? "default" : "pointer",
          }}
        >
          Abiertas ({openList.length})
        </button>

        <button
          onClick={() => setStatusTab("closed")}
          disabled={statusTab === "closed"}
          style={{
            padding: ".35rem .9rem",
            borderRadius: "999px",
            border: "1px solid #e5e7eb",
            background: statusTab === "closed" ? "#bbf7d0" : "#ffffff",
            fontWeight: statusTab === "closed" ? "bold" : "normal",
            cursor: statusTab === "closed" ? "default" : "pointer",
          }}
        >
          Cerradas ({closedList.length})
        </button>
      </div>

      {selectedList.map((p) => (
        <ProblemCard
          key={p.problemId || p.displayId || p.id}
          problem={p}
          username={username}
        />
      ))}
    </div>
  );
}