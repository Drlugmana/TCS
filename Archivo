// ===============================
// src/api/problems.js
// ===============================

// 0) CONFIG OPCIONAL FECHA
// Si pones una fecha "YYYY-MM-DD" fuerza modo día puntual.
// Si lo dejas en null => SIN límite por fecha (histórico completo).
export const ONLY_DATE = null;

// 1) BASE DE LA API (desde .env)
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, "");
if (!BASE) throw new Error('Falta VITE_API_URL en .env (ej: https://xxxxx.brs.devtunnels.ms)');
const API = `${BASE}/api/Problems`;

// -------------------------------
// Helpers
// -------------------------------
const toUpperTrim = (v) => (v == null ? "" : String(v).trim().toUpperCase());

function safeIso(d) {
  try {
    const dt = d instanceof Date ? d : new Date(d);
    if (Number.isNaN(dt.getTime())) return null;
    return dt.toISOString();
  } catch {
    return null;
  }
}

// Rango local completo de un día (00:00:00 a 23:59:59)
function getDayRange(dateStr /* YYYY-MM-DD */) {
  const start = new Date(`${dateStr}T00:00:00`);
  const end = new Date(`${dateStr}T23:59:59`);
  return { startIso: start.toISOString(), endIso: end.toISOString() };
}

// Convierte YYYY-MM-DD a límites de día en ISO (local)
export function toLocalDayIsoRange(dateStr) {
  return getDayRange(dateStr);
}

// Rango “diario”: desde AYER 00:00 hasta AHORA (tiempo real)
export function getYesterdayToNowRange() {
  const now = new Date();
  const start = new Date(now);
  start.setDate(now.getDate() - 1);
  start.setHours(0, 0, 0, 0);
  return { startIso: start.toISOString(), endIso: now.toISOString() };
}

// -------------------------------
// 2) Normalizador robusto
// -------------------------------
function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    // start / end (acepta nombres diversos)
    const startRaw =
      p.startTime ??
      p.startTimeUtc ??
      p.StartTime ??
      p.StartTimeUtc ??
      p.start_date ??
      p.start ??
      p.Start ??
      null;

    const endRaw =
      p.endTime ??
      p.endTimeUtc ??
      p.EndTime ??
      p.EndTimeUtc ??
      p.end_date ??
      p.end ??
      p.End ??
      null;

    // Jurisdicción
    const jurisRaw =
      p.jurisdiction?.label ??
      p.jurisdiction?.name ??
      p.jurisdiction?.Jurisdiction ??
      p.Jurisdiction ??
      p.jurisdiction ??
      p.label ??
      p.Label ??
      "";

    const juris = typeof jurisRaw === "string" ? jurisRaw.trim().toUpperCase() : "";
    const isTcs =
      p.jurisdiction?.isTcs ??
      p.isTcs ??
      (juris === "TCS" ? true : false) ??
      false;

    // ids/títulos
    const problemId = p.problemId ?? p.ProblemId ?? p.displayId ?? p.DisplayId ?? p.id ?? p.Id ?? "";
    const title = p.title ?? p.Title ?? p.shortDescription ?? p.ShortDescription ?? "(sin título)";

    // otros campos usados por la UI
    const severityLevel = p.severityLevel ?? p.SeverityLevel ?? p.severity ?? p.Severity ?? "";
    const impactLevel = p.impactLevel ?? p.ImpactLevel ?? p.impact ?? p.Impact ?? "";
    const environment = p.environment ?? p.Environment ?? p.environmentName ?? p.EnvironmentName ?? "";

    const affectedCI =
      p.affectedCI ??
      p.AffectedCI ??
      p.affectedEntities ??
      p.AffectedEntities ??
      p.affectedEntitiesList ??
      p.AffectedEntitiesList ??
      [];

    // ✅ STATUS: aquí estaba el problema típico (OPEN no aparecía)
    // Acepta status/Status/state/State y normaliza a OPEN/CLOSED
    const statusRaw = p.status ?? p.Status ?? p.state ?? p.State ?? "";
    const status = toUpperTrim(statusRaw); // "OPEN" | "CLOSED"

    const tenant = p.tenant ?? p.Tenant ?? p.domain ?? p.Domain ?? "";

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment,
      affectedCI,
      status,
      tenant,
      label: isTcs ? "TCS" : "NO TCS",
      isTcs,
      startTime: safeIso(startRaw),
      endTime: safeIso(endRaw),
    };
  });
}

// -------------------------------
// 3) Fetch de UNA página con query-params
// -------------------------------
async function fetchPage({ pageNumber, pageSize, startIso, endIso }) {
  const params = new URLSearchParams();
  params.set("pageNumber", String(pageNumber));
  params.set("pageSize", String(pageSize));
  if (startIso) params.set("start", startIso);
  if (endIso) params.set("end", endIso);

  const url = `${API}?${params.toString()}`;
  const res = await fetch(url, { headers: { accept: "application/json" } });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} en ${url}\n${txt}`);
  }

  // Puede venir array directo o envuelto
  const json = await res.json();
  const items = Array.isArray(json)
    ? json
    : json?.results || json?.items || json?.data || json?.value || [];

  return normalize(items);
}

// -------------------------------
// 4) Fetch histórico con paginado + filtros opcionales
// -------------------------------
export async function fetchAllProblems({
  onlyDate = ONLY_DATE, // string "YYYY-MM-DD" o null
  pageSize = 500,
  maxPages = 40,
  onBatch, // (items) => void
  tcsFilter, // true | false | undefined
  statusFilter, // "OPEN" | "CLOSED" | undefined
  environmentFilter, // "Productivo" | "NoProductivo" | undefined (o parte del texto)
  startIso,
  endIso,
  recentDays, // si quieres SOLO lo reciente (ej: 1 => desde ayer 00:00 hasta ahora)
} = {}) {
  // 1) Definir rango
  let range = { startIso, endIso };

  // ✅ Modo "reciente" diario: desde (hoy - recentDays) 00:00 hasta ahora
  if (typeof recentDays === "number" && recentDays > 0) {
    const now = new Date();
    const start = new Date(now);
    start.setDate(now.getDate() - recentDays);
    start.setHours(0, 0, 0, 0);
    range = { startIso: start.toISOString(), endIso: now.toISOString() };
  }

  // Si no hay start/end y hay onlyDate => rango de ese día
  if ((!range.startIso || !range.endIso) && typeof onlyDate === "string") {
    range = getDayRange(onlyDate);
  }

  // 2) Paginación
  let all = [];

  for (let page = 1; page <= maxPages; page++) {
    const batch = await fetchPage({
      pageNumber: page,
      pageSize,
      startIso: range.startIso,
      endIso: range.endIso,
    });

    if (!batch.length) break;

    // 3) Filtros opcionales en cliente
    let filtered = batch;

    if (typeof tcsFilter === "boolean") {
      filtered = filtered.filter((x) => x.isTcs === tcsFilter);
    }

    if (statusFilter) {
      const want = toUpperTrim(statusFilter);
      filtered = filtered.filter((x) => toUpperTrim(x.status) === want);
    }

    if (environmentFilter) {
      const want = toUpperTrim(environmentFilter);
      filtered = filtered.filter((x) => toUpperTrim(x.environment).includes(want));
    }

    if (onBatch) onBatch(filtered);
    all = all.concat(filtered);

    if (batch.length < pageSize) break; // última página
  }

  // 4) Ordenar: más recientes primero (por startTime)
  all.sort((a, b) => {
    const da = a.startTime ? new Date(a.startTime).getTime() : 0;
    const db = b.startTime ? new Date(b.startTime).getTime() : 0;
    return db - da;
  });

  return all;
}

// -------------------------------
// 5) Fetch por rango de fechas (YYYY-MM-DD)
// -------------------------------
export async function fetchByDateRange({
  fromDate, // "YYYY-MM-DD"
  toDate, // "YYYY-MM-DD"
  tcsFilter, // true | false | undefined
  statusFilter, // "OPEN" | "CLOSED" | undefined
  environmentFilter, // "Productivo" | "NoProductivo" | undefined
} = {}) {
  let startIso, endIso;

  if (fromDate && toDate) {
    const a = toLocalDayIsoRange(fromDate);
    const b = toLocalDayIsoRange(toDate);
    startIso = a.startIso;
    endIso = b.endIso;
  } else if (fromDate) {
    startIso = toLocalDayIsoRange(fromDate).startIso;
  } else if (toDate) {
    endIso = toLocalDayIsoRange(toDate).endIso;
  }

  return fetchAllProblems({
    onlyDate: null,
    startIso,
    endIso,
    tcsFilter,
    statusFilter,
    environmentFilter,
  });
}

// -------------------------------
// 6) ✅ NUEVO: “DIARIO EN TIEMPO REAL”
// Trae: desde AYER 00:00 hasta AHORA (ayer + hoy)
// Ideal para ver OPEN del día anterior + hoy, y también CLOSED de ese rango.
// -------------------------------
export async function fetchDailyProblems({
  tcsFilter, // true | false | undefined
  statusFilter, // "OPEN" | "CLOSED" | undefined  (si lo dejas undefined => trae ambos)
  environmentFilter,
  pageSize = 500,
  maxPages = 40,
} = {}) {
  const { startIso, endIso } = getYesterdayToNowRange();

  return fetchAllProblems({
    onlyDate: null,
    startIso,
    endIso,
    tcsFilter,
    statusFilter,
    environmentFilter,
    pageSize,
    maxPages,
  });
}

// -------------------------------
// 7) Conveniencias (como las tenías) + diario
// -------------------------------
export const fetchTcsProblemsDay = (dateStr = ONLY_DATE, opts = {}) =>
  fetchAllProblems({ onlyDate: dateStr, tcsFilter: true, ...opts });

export const fetchNoTcsProblemsDay = (dateStr = ONLY_DATE, opts = {}) =>
  fetchAllProblems({ onlyDate: dateStr, tcsFilter: false, ...opts });

export const fetchTcsAllHistory = (opts = {}) =>
  fetchAllProblems({ onlyDate: null, tcsFilter: true, ...opts });

export const fetchNoTcsAllHistory = (opts = {}) =>
  fetchAllProblems({ onlyDate: null, tcsFilter: false, ...opts });

// ✅ “Reciente” ahora por defecto es DIARIO (ayer 00:00 -> ahora)
export const fetchRecentProblems = ({ recentDays = 1, opts = {} } = {}) =>
  fetchAllProblems({ onlyDate: null, recentDays, ...opts });

// ✅ Atajos diarios para tu caso:
export const fetchTcsDaily = (opts = {}) => fetchDailyProblems({ tcsFilter: true, ...opts });
export const fetchNoTcsDaily = (opts = {}) => fetchDailyProblems({ tcsFilter: false, ...opts });

// Si quieres SOLO OPEN diario (ayer+hoy):
export const fetchTcsDailyOpen = (opts = {}) =>
  fetchDailyProblems({ tcsFilter: true, statusFilter: "OPEN", ...opts });

// Si quieres SOLO CLOSED diario (ayer+hoy):
export const fetchTcsDailyClosed = (opts = {}) =>
  fetchDailyProblems({ tcsFilter: true, statusFilter: "CLOSED", ...opts });