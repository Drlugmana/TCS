

// lleva registro de los EntityId que sí hicieron match
var matchedEntityIds = new ConcurrentBag<string>();

// este acumulador local luego lo pasamos a _serversWithEntities
var localMatches = new ConcurrentBag<ServerWithEntities>();

// -------- NUEVO: umbral de "reciente" --------
var now = DateTime.UtcNow;
var maxAgeDays = 30; // cámbialo si quieres 7, 14, etc.
var freshnessLimit = now.AddDays(-maxAgeDays);

// === Buscar primero por FQDN, luego por shortname ===
Parallel.ForEach(serverList, server =>
{
    if (!string.IsNullOrEmpty(server.Name))
    {
        var original = (server.Name ?? "").Trim();
        var fullKey = original.ToUpperInvariant();
        var shortKey = fullKey.Split('.')[0];

        List<EntitySchema>? matchedEntities = null;

        // 1. FQDN exacto
        if (normalizedEntities.TryGetValue(fullKey, out var listFull))
        {
            matchedEntities = listFull;
        }

        // 2. Si no hubo FQDN exacto, intento shortname exacto
        if (matchedEntities == null && normalizedEntities.TryGetValue(shortKey, out var listShort))
        {
            matchedEntities = listShort;
        }

        // 3. Si tampoco hubo match exacto, hacemos fallback Contains
        //    (esto es lo que ya tenías antes)
        if (matchedEntities == null)
        {
            matchedEntities = allEntities
                .Where(e =>
                    e.DisplayName != null &&
                    e.DisplayName.ToUpperInvariant().Contains(original.ToUpperInvariant()))
                .ToList();

            if (matchedEntities.Count == 0)
                matchedEntities = null;
        }

        // ======== AQUÍ VIENE LA VALIDACIÓN DE "RECIENTE" ========
        if (matchedEntities != null)
        {
            // ¿Alguna entidad fue vista recientemente?
            var freshEntities = matchedEntities
                .Where(e => e.LastSeen >= freshnessLimit)
                .ToList();

            if (freshEntities.Count > 0)
            {
                // ✅ Sí hay monitoreo ACTUAL → usamos solo las recientes
                localMatches.Add(new ServerWithEntities
                {
                    Server = server,
                    Entities = freshEntities
                });

                // guardamos los EntityId "buenos"
                foreach (var e in freshEntities)
                {
                    matchedEntityIds.Add(e.EntityId);
                }

                // quitamos los nombres usados para que no se re-utilicen:
                normalizedEntities.TryRemove(fullKey, out _);
                normalizedEntities.TryRemove(shortKey, out _);
            }
            else
            {
                // ❌ Solo hay coincidencias viejas -> NO lo consideramos monitoreado
                _serversNoMatch.Add(server);
            }
        }
        else
        {
            // ❌ No encontramos nada -> No Monitoreado CMDB
            _serversNoMatch.Add(server);
        }
    }

    Console.WriteLine("Procesando servidores: {0}/{1}",
        serverList.IndexOf(server) + 1, serverList.Count);
});

// Consolidamos lo que recolectó el paralelo
_serversWithEntities = localMatches.ToList();

// Construimos el set para saber qué EntityId ya están emparejados
var matchedSet = new HashSet<string>(matchedEntityIds);

// No Monitoreados Dynatrace = lo que sobró en allEntities que no tiene match
_serversNoMatchDyn = allEntities
    .GroupBy(e => e.EntityId)
    .Select(g => g.First())
    .Where(e => !matchedSet.Contains(e.EntityId))
    .ToList();

// Eliminamos ruidos tipo "Premise" como ya hacías
_serversNoMatchDyn = _serversNoMatchDyn
    .Where(entity =>
        entity.ManagementZones != null &&
        entity.ManagementZones.Any(zone =>
            zone.Name != null &&
            zone.Name.IndexOf("Premise", StringComparison.OrdinalIgnoreCase) >= 0) == false)
    .ToList();

Console.WriteLine();
Console.WriteLine($"Entidades match {_serversWithEntities.Count}");
Console.WriteLine($"Sin match en CMDB {_serversNoMatch.Count}");
Console.WriteLine($"Sin match en Dynatrace {_serversNoMatchDyn.Count}");

   
De la pestaña Monitoreados quiero que me saques los que estan Estado Operativo (Catálogo) = "Operativos" y Inventario Torres = "Si", pero la condicon es que no me traigas los que me das en la pestaña de "Reglas  SI"
quiero que me traigas primero los Reglas si de la pestaña Momonitoreados que son 1833 y luego otra crea otra pestaña con los que sobran y no esten en la pestaña Reglas  SI con estas condiciones Estado Operativo (Catálogo) = "Operativos" y Inventario Torres = "Si"
