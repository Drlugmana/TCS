


// matchedEntityIds: para saber qué entidades sí quedaron monitoreadas
var matchedEntityIds = new ConcurrentBag<string>();
var localMatches = new ConcurrentBag<ServerWithEntities>();
var localNoMatch = new ConcurrentBag<Server>(); // vamos a llenar aquí los que NO quedaron monitoreados reales

Parallel.ForEach(serverList, server =>
{
    if (string.IsNullOrWhiteSpace(server.Name))
    {
        localNoMatch.Add(server);
        return;
    }

    // Normalizaciones de nombre
    var original = server.Name.Trim();
    var fullKey  = original.ToUpperInvariant();         // con dominio si trae
    var shortKey = fullKey.Split('.')[0];               // sin dominio
    var baseNoEnv = StripEnvSuffix(original);           // sin _Desarrollo/_QA/etc, ya en mayúsculas

    // 1. intentar FQDN, shortname, sin sufijo
    List<EntitySchema>? matchedEntities = null;

    if (normalizedEntities.TryGetValue(fullKey, out var listFull))
        matchedEntities = listFull;
    else if (normalizedEntities.TryGetValue(shortKey, out var listShort))
        matchedEntities = listShort;
    else if (normalizedEntities.TryGetValue(baseNoEnv, out var listNoEnv))
        matchedEntities = listNoEnv;

    // 2. fallback parcial: busca DisplayName que contenga el hostname base (para ProbeEnabled_HOSTNAME)
    if (matchedEntities == null)
    {
        var partialKey = baseNoEnv; // mayúsculas sin sufijo
        matchedEntities = allEntities
            .Where(e =>
                !string.IsNullOrWhiteSpace(e.DisplayName) &&
                StripEnvSuffix(e.DisplayName!).Contains(partialKey))
            .ToList();

        if (matchedEntities.Count == 0)
            matchedEntities = null;
    }

    // en este punto matchedEntities puede ser null o tener varias entidades Dynatrace candidatas

    if (matchedEntities != null && matchedEntities.Count > 0)
    {
        // 2.1 Nos quedamos solo con entidades que realmente cuentan como "monitoreadas"
        //     - Deben ser HOST
        //     - Deben tener MonitoringMode
        //     - (Opcional) Deben tener MonitoringMode != vacío y LastSeen reciente

        DateTime limiteReciente = DateTime.UtcNow.AddDays(-30); // <- si quieres exigir "visto en últimos 30 días"
                                                                // si NO quieres esa validación, puedes no usarlo abajo

        var monitoreadasReales = matchedEntities
            .Where(e =>
                string.Equals(e.Type, "HOST", StringComparison.OrdinalIgnoreCase) &&
                !string.IsNullOrWhiteSpace(e.Properties?.MonitoringMode)
                // && e.LastSeen >= limiteReciente   // <- descomenta si quieres exigir reciente
            )
            .ToList();

        if (monitoreadasReales.Count > 0)
        {
            // Elegimos la "mejor" HOST monitoreada real:
            int ModeRank(string? mm) => (mm ?? "").ToUpperInvariant() switch
            {
                "FULL_STACK"      => 3,
                "INFRASTRUCTURE"  => 2,
                "DISCOVERY"       => 1,
                _                 => 0
            };

            var chosen = monitoreadasReales
                .GroupBy(e => e.EntityId)
                .Select(g => g.First())
                .OrderByDescending(e => ModeRank(e.Properties?.MonitoringMode))
                .ThenByDescending(e => e.LastSeen)
                .First();

            // Lo agregamos a Monitoreados
            localMatches.Add(new ServerWithEntities
            {
                Server = server,
                Entities = new List<EntitySchema> { chosen }
            });

            // Registramos todos los entityId de las que consideramos monitoreadas reales
            foreach (var e in monitoreadasReales)
                matchedEntityIds.Add(e.EntityId);

            return; // <- OJO: ya lo marcamos como monitoreado, no lo mandamos a NoMatch
        }

        // Si llegó aquí: había entidades, pero ninguna califica como "monitoreada real".
        // Eso significa que este server NO debe ir a Monitoreados.
        localNoMatch.Add(server);
    }
    else
    {
        // No hay ninguna entidad asociada
        localNoMatch.Add(server);
    }
});

----

// Consolidar listas paralelas
_serversWithEntities = localMatches.ToList();
_serversNoMatch      = localNoMatch.ToList();

// Construir No Monitoreados Dynatrace (entidades sueltas que nadie matcheó)
var matchedSet = new HashSet<string>(matchedEntityIds);
_serversNoMatchDyn = allEntities
    .GroupBy(e => e.EntityId)
    .Select(g => g.First())
    .Where(e => !matchedSet.Contains(e.EntityId))
    .ToList();

Console.WriteLine();
Console.WriteLine($"Entidades match {_serversWithEntities.Count}");
Console.WriteLine($"Entidades que no hicieron match en cmdb {_serversNoMatch.Count}");
Console.WriteLine($"Entidades que no hicieron match en dynatrace {_serversNoMatchDyn.Count}");
Primero que me ayudas a validar la pestaña de Monitoreados que si de verdad hacen match con entidades se quedue en la pestaña de monitoreados porque veo 6 servidores que comprobe manualmente, no tienes monitoreo y deberia quedarse en NO Monitoreados Cmdb.

De la pestaña Monitoreados quiero que me saques los que estan Estado Operativo (Catálogo) = "Operativos" y Inventario Torres = "Si", pero la condicon es que no me traigas los que me das en la pestaña de "Reglas  SI"
quiero que me traigas primero los Reglas si de la pestaña Momonitoreados que son 1833 y luego otra crea otra pestaña con los que sobran y no esten en la pestaña Reglas  SI con estas condiciones Estado Operativo (Catálogo) = "Operativos" y Inventario Torres = "Si"
