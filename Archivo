// src/api/problems.js
// =====================================================
// Capa API – SOLO fetch + normalización
// =====================================================

// Fecha actual (YYYY-MM-DD)
export const TODAY = new Date().toISOString().slice(0, 10);

// Backend base (desde .env)
// VITE_API_URL=http://servidor:puerto
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, "");

// Soporta proxy o URL absoluta
const API = BASE ? `${BASE}/api/Problems` : `/api/Problems`;

/* ================= Helpers ================= */

function clean(v) {
  if (v === undefined || v === null) return null;
  if (typeof v === "string") {
    const t = v.trim();
    if (!t || t.toLowerCase() === "null") return null;
    return t;
  }
  return v;
}

function toISO(v) {
  v = clean(v);
  if (!v) return null;

  if (v instanceof Date) return v.toISOString();
  if (typeof v === "number") return new Date(v).toISOString();

  if (typeof v === "string") {
    let s = v;
    // SQL -> ISO
    if (/^\d{4}-\d{2}-\d{2}\s+\d/.test(s)) s = s.replace(" ", "T");
    const d = new Date(s);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }
  return null;
}

function normalizeStatus(raw, endTime) {
  const s = clean(raw);
  const up = s ? s.toUpperCase() : "";
  if (up.includes("CLOSED") || up.includes("RESOLVED")) return "CLOSED";
  if (up.includes("OPEN")) return "OPEN";
  return endTime ? "CLOSED" : "OPEN";
}

/* ================= Normalizador ================= */

function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    const startTime = toISO(
      p.startTime ?? p.StartTime ?? p.start_date ?? null
    );
    const endTime = toISO(
      p.endTime ?? p.EndTime ?? p.end_date ?? null
    );

    const juris =
      p.jurisdiction?.label ??
      p.jurisdiction ??
      p.label ??
      "";

    const isTcs = String(juris).toUpperCase() === "TCS";

    return {
      ...p,
      problemId: p.problemId ?? p.displayId ?? p.id ?? "",
      title: p.title ?? p.shortDescription ?? "(sin título)",
      environment:
        p.environment ??
        p.Environment ??
        p.entorno ??
        "",
      startTime,
      endTime,
      status: normalizeStatus(
        p.status ?? p.Status ?? p.problemStatus,
        endTime
      ),
      isTcs,
      label: isTcs ? "TCS" : "NO TCS",
    };
  });
}

/* ================= Core fetch ================= */

async function fetchPage({ page, size }) {
  const params = new URLSearchParams();
  params.set("pageNumber", page);
  params.set("pageSize", size);

  const res = await fetch(`${API}?${params.toString()}`, {
    headers: { Accept: "application/json" },
  });

  if (!res.ok) {
    const t = await res.text();
    throw new Error(`API ${res.status}: ${t}`);
  }

  const json = await res.json();
  const items = Array.isArray(json)
    ? json
    : json.items ?? json.data ?? [];

  return normalize(items);
}

/* ================= Fetch general ================= */

export async function fetchAllProblems({
  tcsFilter,
  statusFilter,
  recentDays, // number | undefined
  pageSize = 500,
  maxPages = 40,
} = {}) {
  let all = [];
  const now = Date.now();
  const minTime =
    typeof recentDays === "number"
      ? now - recentDays * 24 * 60 * 60 * 1000
      : null;

  for (let p = 1; p <= maxPages; p++) {
    const batch = await fetchPage({ page: p, size: pageSize });
    if (!batch.length) break;

    let filtered = batch;

    if (typeof tcsFilter === "boolean") {
      filtered = filtered.filter((x) => x.isTcs === tcsFilter);
    }

    if (statusFilter) {
      filtered = filtered.filter((x) => x.status === statusFilter);
    }

    if (minTime) {
      filtered = filtered.filter(
        (x) =>
          x.startTime &&
          new Date(x.startTime).getTime() >= minTime
      );
    }

    all = all.concat(filtered);

    if (batch.length < pageSize) break;
  }

  // orden descendente
  all.sort(
    (a, b) =>
      new Date(b.startTime || 0) -
      new Date(a.startTime || 0)
  );

  return all;
}

/* ================= Exports usados por UI ================= */

// TCS
export const fetchTcsAll = (opts = {}) =>
  fetchAllProblems({ tcsFilter: true, ...opts });

// NO TCS
export const fetchNoTcsAll = (opts = {}) =>
  fetchAllProblems({ tcsFilter: false, ...opts });

// Aliases (IMPORTANTE para no romper imports viejos)
export const fetchNoTcsProblemsDay = fetchNoTcsAll;
export const fetchTcsProblemsDay = fetchTcsAll;

-------


import React, { useEffect, useMemo, useState } from "react";
import { fetchTcsAll } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

/* ===== Ambiente ===== */
function isProd(p) {
  const e = (p.environment || "").toLowerCase();
  if (e.includes("no") || e.includes("dev") || e.includes("qa")) return false;
  return true;
}

export default function TCSProblems() {
  const [all, setAll] = useState([]);
  const [envTab, setEnvTab] = useState("prod");
  const [statusTab, setStatusTab] = useState("open");
  const [username, setUsername] = useState("");

  useEffect(() => {
    async function load() {
      // CLOSED histórico + OPEN recientes (ayer + hoy)
      const closed = await fetchTcsAll({ statusFilter: "CLOSED" });
      const open = await fetchTcsAll({
        statusFilter: "OPEN",
        recentDays: 2,
      });
      setAll([...open, ...closed]);
    }
    load();
  }, []);

  const envList = useMemo(() => {
    return envTab === "prod"
      ? all.filter(isProd)
      : all.filter((p) => !isProd(p));
  }, [all, envTab]);

  const list =
    statusTab === "open"
      ? envList.filter((p) => p.status === "OPEN")
      : envList.filter((p) => p.status === "CLOSED");

  return (
    <div>
      <h2>Problemas TCS ({list.length})</h2>

      <UsernameInput value={username} onChange={setUsername} />

      <button onClick={() => setEnvTab("prod")}>Productivo</button>
      <button onClick={() => setEnvTab("nonprod")}>No Productivo</button>

      <button onClick={() => setStatusTab("open")}>Abiertas</button>
      <button onClick={() => setStatusTab("closed")}>Cerradas</button>

      {list.map((p) => (
        <ProblemCard
          key={p.problemId}
          problem={p}
          username={username}
        />
      ))}
    </div>
  );
}

-------


import React, { useEffect, useMemo, useState } from "react";
import { fetchNoTcsAll } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

function isProd(p) {
  const e = (p.environment || "").toLowerCase();
  if (e.includes("no") || e.includes("dev") || e.includes("qa")) return false;
  return true;
}

export default function OtherProblems() {
  const [all, setAll] = useState([]);
  const [envTab, setEnvTab] = useState("prod");
  const [statusTab, setStatusTab] = useState("open");
  const [username, setUsername] = useState("");

  useEffect(() => {
    async function load() {
      const closed = await fetchNoTcsAll({ statusFilter: "CLOSED" });
      const open = await fetchNoTcsAll({
        statusFilter: "OPEN",
        recentDays: 2,
      });
      setAll([...open, ...closed]);
    }
    load();
  }, []);

  const envList = useMemo(() => {
    return envTab === "prod"
      ? all.filter(isProd)
      : all.filter((p) => !isProd(p));
  }, [all, envTab]);

  const list =
    statusTab === "open"
      ? envList.filter((p) => p.status === "OPEN")
      : envList.filter((p) => p.status === "CLOSED");

  return (
    <div>
      <h2>Problemas NO TCS ({list.length})</h2>

      <UsernameInput value={username} onChange={setUsername} />

      <button onClick={() => setEnvTab("prod")}>Productivo</button>
      <button onClick={() => setEnvTab("nonprod")}>No Productivo</button>

      <button onClick={() => setStatusTab("open")}>Abiertas</button>
      <button onClick={() => setStatusTab("closed")}>Cerradas</button>

      {list.map((p) => (
        <ProblemCard
          key={p.problemId}
          problem={p}
          username={username}
        />
      ))}
    </div>
  );
}