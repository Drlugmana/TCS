// src/api/problems.js
const BASE_URL = import.meta.env.VITE_API_URL;
if (!BASE_URL) {
  throw new Error("VITE_API_URL no está definida. Crea .env en la raíz y reinicia `npm run dev`");
}

const JSON_HEADERS = { "Accept": "application/json" };

// Normaliza un problema del backend al shape que usa el front
function mapProblem(p) {
  // Campos que se ven en tus pantallas y que existen en el backend
  const startTime =
    p.startTime || p.startDate || p.start || p.inicio || null; // por si vienen con otros nombres

  const impact =
    p.impactLevel || p.impact || p.Impact || p.impacto || ""; // tolerante may/min

  const severity =
    p.severityLevel || p.severity || p.Severity || p.severidad || "";

  // El nuevo campo de clasificación del modelo:
  // en tu backend es `juris`: "TCS" | "NO TCS" (puede venir null)
  const juris = (p.juris || p.jurisdiction || "").toString().toUpperCase();

  return {
    // ids / claves
    problemId: p.problemId || p.id || p.displayId || "",
    displayId: p.displayId || p.problemId || "",

    // textos
    title: p.title || p.Titulo || p.shortDescription || p.ShortDescription || "",
    shortDescription:
      p.shortDescription || p.ShortDescription || p.description || "",

    // metadatos usados en las cards
    environment: p.environment || p.entorno || "",
    impactLevel: impact,
    severityLevel: severity,
    startTime: startTime ? new Date(startTime).toISOString() : null,

    // listas opcionales que pintas como chips
    affectedEntities: p.affectedEntities || p.affectedCI || [],
    clusterName: p.clusterName || [],
    clusterUid: p.clusterUid || [],
    namespaceName: p.namespaceName || [],

    // === CLAVE PARA TCS/NO TCS ===
    juris,                // "TCS" | "NO TCS" | ""
    isTcs: juris === "TCS"
  };
}

// GET /api/Problems ?pageNumber=&pageSize=
// o GET /api/Problems (si tu backend no usa paginado)
export async function fetchProblemsPage(pageNumber = 1, pageSize = 50) {
  // Primero intentamos con los params de paginación…
  let url = `${BASE_URL}/api/Problems?pageNumber=${pageNumber}&pageSize=${pageSize}`;

  let res = await fetch(url, { headers: JSON_HEADERS });
  // Si la URL con paginado no existe, probamos sin querystring
  if (!res.ok && res.status === 404) {
    url = `${BASE_URL}/api/Problems`;
    res = await fetch(url, { headers: JSON_HEADERS });
  }

  if (!res.ok) {
    const text = await res.text().catch(() => "");
    throw new Error(`Error HTTP ${res.status} al obtener problemas. ${text}`);
  }

  const data = await res.json();

  // Soporta dos formas de respuesta:
  // 1) { items: [...], total: N }  (paginado)
  // 2) [ ... ]  (lista directa)
  const rawItems = Array.isArray(data) ? data
                  : Array.isArray(data.items) ? data.items
                  : [];

  const items = rawItems.map(mapProblem);
  const total  = Array.isArray(data) ? items.length : (data.total ?? items.length);

  return { items, total };
}

// Ayudas listas para las páginas
export async function fetchAllOpenProblems(pageSize = 50) {
  // si tu backend limita páginas, puedes agregar un bucle aquí;
  // por ahora sólo 1 página para simplificar
  const { items } = await fetchProblemsPage(1, pageSize);
  // devolvemos sólo los abiertos si tu backend los marca:
  return items.filter(p => (p.status || "").toUpperCase() !== "CLOSED");
}


----
// src/hooks/useOpenProblems.js
import { useEffect, useState } from "react";
import { fetchAllOpenProblems } from "../api/problems";

export default function useOpenProblems(pageSize = 50) {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState("");

  useEffect(() => {
    let cancelled = false;

    async function load() {
      setLoading(true);
      setError("");
      try {
        const items = await fetchAllOpenProblems(pageSize);
        if (!cancelled) setProblems(items);
      } catch (e) {
        console.error(e);
        if (!cancelled) setError(e?.message || "Error desconocido");
      } finally {
        if (!cancelled) setLoading(false);
      }
    }

    load();
    return () => { cancelled = true; };
  }, [pageSize]);

  return { problems, loading, error };
}
--------
// src/utils/jurisdiction.js
export const esTCS   = (p) => (p?.isTcs === true) || (p?.juris === "TCS");
export const esNoTCS = (p) => (p?.isTcs === false) || (p?.juris === "NO TCS");

------1

// src/pages/TCSProblems.jsx
import React from "react";
import useOpenProblems from "../hooks/useOpenProblems";
import { esTCS } from "../utils/jurisdiction";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

export default function TCSProblems() {
  const { problems, loading, error } = useOpenProblems(50);
  const tcs = problems.filter(esTCS);

  if (loading) return <h2>Cargando problemas TCS…</h2>;
  if (error)   return <h2 style={{ color: "crimson" }}>Error: {error}</h2>;
  if (tcs.length === 0) return <h2>No hay problemas TCS actualmente.</h2>;

  // ordena de más reciente a más antiguo (si hay fecha)
  const sorted = [...tcs].sort((a,b) => {
    const ta = a.startTime ? new Date(a.startTime).getTime() : 0;
    const tb = b.startTime ? new Date(b.startTime).getTime() : 0;
    return tb - ta;
  });

  return (
    <>
      <h2>Problemas TCS</h2>
      <UsernameInput />
      {sorted.map(p => <ProblemCard key={p.problemId || p.displayId} problem={p} />)}
    </>
  );
}


------

// src/pages/OtherProblems.jsx
import React from "react";
import useOpenProblems from "../hooks/useOpenProblems";
import { esNoTCS } from "../utils/jurisdiction";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

export default function OtherProblems() {
  const { problems, loading, error } = useOpenProblems(50);
  const otros = problems.filter(esNoTCS);

  if (loading) return <h2>Cargando problemas de terceros…</h2>;
  if (error)   return <h2 style={{ color: "crimson" }}>Error: {error}</h2>;
  if (otros.length === 0) return <h2>No hay problemas de terceros actualmente.</h2>;

  const sorted = [...otros].sort((a,b) => {
    const ta = a.startTime ? new Date(a.startTime).getTime() : 0;
    const tb = b.startTime ? new Date(b.startTime).getTime() : 0;
    return tb - ta;
  });

  return (
    <>
      <h2>Problemas Otros</h2>
      <UsernameInput />
      {sorted.map(p => <ProblemCard key={p.problemId || p.displayId} problem={p} />)}
    </>
  );
}





