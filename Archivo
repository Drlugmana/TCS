// src/api/problems.js
// ============================================================
// Trae problemas desde el backend con rango dinámico (ayer -> ahora)
// y normaliza campos para que el Front filtre OPEN/CLOSED bien.
// ============================================================

// Si quieres forzar un día exacto: "YYYY-MM-DD"
// Si lo dejas null => usamos "desde ayer hasta ahora"
export const ONLY_DATE = null;

// Por defecto: desde ayer hasta ahora (1 día)
export const DEFAULT_RECENT_DAYS = 1;

// ============================================================
// BASE DE LA API (desde .env)
const BASE = (import.meta.env.VITE_API_URL || "").replace(/\/+$/, "");
if (!BASE) {
  throw new Error("Falta VITE_API_URL en .env (ej: https://xxxxx.brs.devtunnels.ms)");
}

// Ajusta aquí si tu backend usa otra ruta
const API = `${BASE}/api/Problems`;

// ============================================================
// Helpers
function cleanNull(v) {
  if (v === undefined || v === null) return null;
  if (typeof v === "string") {
    const t = v.trim();
    if (!t) return null;
    const low = t.toLowerCase();
    if (low === "null" || low === "undefined") return null;
    return t;
  }
  return v;
}

function parseDateToISO(v) {
  v = cleanNull(v);
  if (!v) return null;

  if (v instanceof Date) {
    const ms = v.getTime();
    return Number.isFinite(ms) ? v.toISOString() : null;
  }

  if (typeof v === "number") {
    const d = new Date(v);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  if (typeof v === "string") {
    let s = v.trim();

    // SQL: "YYYY-MM-DD HH:mm:ss.fffffff" => ISO-friendly
    if (/^\d{4}-\d{2}-\d{2}\s+\d/.test(s)) s = s.replace(" ", "T");

    const d = new Date(s);
    return Number.isFinite(d.getTime()) ? d.toISOString() : null;
  }

  return null;
}

function normalizeStatusValue(rawStatus, endTimeISO) {
  const s = cleanNull(rawStatus);
  const up = typeof s === "string" ? s.trim().toUpperCase() : "";

  if (up.includes("CLOSED") || up.includes("RESOLVED")) return "CLOSED";
  if (up.includes("OPEN")) return "OPEN";

  // si no vino status, deduce por endTime
  return endTimeISO ? "CLOSED" : "OPEN";
}

// ============================================================
// Normalizador robusto: deja llaves consistentes para el Front
function normalize(list) {
  if (!Array.isArray(list)) return [];

  return list.map((p) => {
    // Start / End (soporta nombres distintos)
    const startRaw =
      p?.startTime ??
      p?.startTimeUtc ??
      p?.StartTime ??
      p?.StartTimeUtc ??
      p?.start_date ??
      p?.Start ??
      null;

    const endRaw =
      p?.endTime ??
      p?.endTimeUtc ??
      p?.EndTime ??
      p?.EndTimeUtc ??
      p?.end_date ??
      p?.End ??
      null;

    const startTime = parseDateToISO(startRaw);
    const endTime = parseDateToISO(endRaw);

    // Jurisdiction
    const jurisRaw =
      p?.jurisdiction?.label ??
      p?.jurisdiction?.name ??
      p?.jurisdiction?.Jurisdiction ??
      p?.Jurisdiction ??
      p?.jurisdiction ??
      p?.label ??
      "";

    const juris = typeof jurisRaw === "string" ? jurisRaw.trim().toUpperCase() : "";
    const isTcs =
      p?.jurisdiction?.isTcs ??
      (juris === "TCS" ? true : false);

    // IDs / title
    const problemId = p?.problemId ?? p?.displayId ?? p?.id ?? p?.pid ?? "";
    const title = p?.title ?? p?.Title ?? p?.shortDescription ?? "(sin título)";

    // Campos usados por UI
    const severityLevel = p?.severityLevel ?? p?.SeverityLevel ?? p?.severity ?? "";
    const impactLevel = p?.impactLevel ?? p?.ImpactLevel ?? p?.impact ?? "";
    const environment = p?.environment ?? p?.Environment ?? p?.environmentName ?? "";

    // Afectados
    const affectedCI =
      p?.affectedCI ??
      p?.AffectedCI ??
      p?.affectedEntities ??
      p?.affectedEntitiesList ??
      [];

    // Status final: "OPEN" | "CLOSED"
    const status = normalizeStatusValue(
      p?.status ?? p?.Status ?? p?.state ?? p?.problemStatus,
      endTime
    );

    return {
      ...p,
      problemId,
      title,
      severityLevel,
      impactLevel,
      environment,
      affectedCI,
      status, // "OPEN" | "CLOSED"
      tenant: p?.tenant ?? p?.Tenant ?? p?.domain ?? "",
      label: isTcs ? "TCS" : "NO TCS",
      isTcs,
      startTime,
      endTime,
    };
  });
}

// ============================================================
// Rango: "desde ayer hasta ahora"
function getLastDaysRange(days = 1) {
  const end = new Date();
  const start = new Date(end);
  start.setDate(end.getDate() - days);
  return { startIso: start.toISOString(), endIso: end.toISOString() };
}

// Rango: día puntual local "YYYY-MM-DD"
function getDayRange(dateStr /* YYYY-MM-DD */) {
  const start = new Date(`${dateStr}T00:00:00`);
  const end = new Date(`${dateStr}T23:59:59.999`);
  return { startIso: start.toISOString(), endIso: end.toISOString() };
}

// ============================================================
// Fetch de UNA página con query-params
async function fetchPage({ pageNumber, pageSize, startIso, endIso }) {
  const params = new URLSearchParams();
  params.set("pageNumber", String(pageNumber));
  params.set("pageSize", String(pageSize));

  // Si tu backend lo soporta, los aplica. Si no, simplemente los ignora.
  if (startIso) params.set("start", startIso);
  if (endIso) params.set("end", endIso);

  const url = `${API}?${params.toString()}`;
  const res = await fetch(url, { headers: { accept: "application/json" } });

  if (!res.ok) {
    const txt = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} en ${url}\n${txt}`);
  }

  const json = await res.json();

  // Puede venir array directo o envuelto
  const items = Array.isArray(json)
    ? json
    : json?.results || json?.items || json?.data || json?.value || [];

  return normalize(items);
}

// ============================================================
// Fetch paginado + filtros cliente
export async function fetchAllProblems({
  // rango
  onlyDate = ONLY_DATE,          // "YYYY-MM-DD" o null
  recentDays = DEFAULT_RECENT_DAYS, // si onlyDate es null => usa ayer->ahora por defecto
  startIso,
  endIso,

  // paginado
  pageSize = 500,
  maxPages = 40,
  onBatch,

  // filtros
  tcsFilter,          // true | false | undefined
  statusFilter,       // "OPEN" | "CLOSED" | undefined
  environmentFilter,  // "Productivo" | "NoProductivo" | undefined (o parte del texto)
} = {}) {
  // 1) Definir rango final
  let range = { startIso, endIso };

  if (!range.startIso || !range.endIso) {
    if (typeof onlyDate === "string") {
      range = getDayRange(onlyDate);
    } else {
      range = getLastDaysRange(recentDays || 1); // ayer->ahora
    }
  }

  // 2) paginar
  let all = [];

  for (let page = 1; page <= maxPages; page++) {
    const batch = await fetchPage({
      pageNumber: page,
      pageSize,
      startIso: range.startIso,
      endIso: range.endIso,
    });

    if (!batch.length) break;

    // 3) filtros cliente
    let filtered = batch;

    if (typeof tcsFilter === "boolean") {
      filtered = filtered.filter((x) => x.isTcs === tcsFilter);
    }

    if (statusFilter) {
      const want = String(statusFilter).toUpperCase();
      filtered = filtered.filter((x) => String(x.status || "").toUpperCase() === want);
    }

    if (environmentFilter) {
      const want = String(environmentFilter).toUpperCase();
      filtered = filtered.filter((x) =>
        String(x.environment || "").toUpperCase().includes(want)
      );
    }

    if (onBatch) onBatch(filtered);
    all = all.concat(filtered);

    if (batch.length < pageSize) break;
  }

  // 4) Orden: más recientes primero por startTime
  all.sort((a, b) => {
    const da = a.startTime ? new Date(a.startTime).getTime() : 0;
    const db = b.startTime ? new Date(b.startTime).getTime() : 0;
    return db - da;
  });

  return all;
}

// ============================================================
// Conveniencias (exporta LOS NOMBRES que usa tu Front)

// TCS
export const fetchTcsProblemsDay = (dateStr = ONLY_DATE, opts = {}) =>
  fetchAllProblems({ onlyDate: dateStr, tcsFilter: true, ...opts });

// NO TCS (nombre correcto)
export const fetchNotTcsProblemsDay = (dateStr = ONLY_DATE, opts = {}) =>
  fetchAllProblems({ onlyDate: dateStr, tcsFilter: false, ...opts });

// Alias para evitar tu error actual (tu OtherProblems importaba fetchNoTcsProblemsDay)
export const fetchNoTcsProblemsDay = (dateStr = ONLY_DATE, opts = {}) =>
  fetchNotTcsProblemsDay(dateStr, opts);

// “Ayer -> ahora” (sin pasar fecha)
export const fetchTcsRecent = (opts = {}) =>
  fetchAllProblems({ onlyDate: null, recentDays: 1, tcsFilter: true, ...opts });

export const fetchNotTcsRecent = (opts = {}) =>
  fetchAllProblems({ onlyDate: null, recentDays: 1, tcsFilter: false, ...opts });

// “Ayer -> ahora” SOLO OPEN (para refrescar en tiempo real)
export const fetchTcsRecentOpen = (opts = {}) =>
  fetchAllProblems({
    onlyDate: null,
    recentDays: 1,
    tcsFilter: true,
    statusFilter: "OPEN",
    ...opts,
  });

export const fetchNotTcsRecentOpen = (opts = {}) =>
  fetchAllProblems({
    onlyDate: null,
    recentDays: 1,
    tcsFilter: false,
    statusFilter: "OPEN",
    ...opts,
  });

-----13


// src/pages/TCSProblems.jsx
import React, { useEffect, useMemo, useState } from "react";
import { fetchTcsRecent, fetchTcsRecentOpen } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

// ===== Detección de ambiente (igual a lo que venías usando) =====
function detectEnvironmentRaw(problem) {
  const raw =
    problem?.environmentIcon ||
    problem?.environmentText ||
    problem?.environment ||
    problem?.entorno ||
    problem?.env ||
    "";
  return String(raw).toLowerCase().trim();
}

function isProd(problem) {
  const env = detectEnvironmentRaw(problem);

  // íconos primero (evita falso positivo "productivo" dentro de "noproductivo")
  if (
    env.includes("icon-noproductivo") ||
    env.includes("no-productivo") ||
    env.includes("noproductivo")
  ) {
    return false;
  }
  if (env.includes("icon-productivo")) return true;

  const nonProdRegex =
    /\b(enp|np|qa|q\/a|dev|desa|desarrollo|test|testing|stg|stage|staging|uat|preprod|pre-prod|pre\s*prod|preprodu)\b/i;
  if (nonProdRegex.test(env)) return false;

  if (/\b(productivo|producci[oó]n|production)\b/i.test(env)) return true;
  if (/\bprod\b/i.test(env) || /^prod[\w-]*/i.test(env)) return true;

  return false; // desconocido => no productivo
}

// ===== Normalización OPEN/CLOSED =====
function normalizeStatus(p) {
  const raw = p?.status ?? p?.Status ?? p?.problemStatus ?? "";
  let s = String(raw).trim().toUpperCase();

  // si ya viene bien
  if (s.includes("CLOSED") || s.includes("RESOLVED")) return "CLOSED";
  if (s.includes("OPEN")) return "OPEN";

  // si viene vacío, deduce por endTime
  return p?.endTime ? "CLOSED" : "OPEN";
}

export default function TCSProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [username, setUsername] = useState("");

  // tabs (mantengo tu estilo)
  const [envTab, setEnvTab] = useState("prod"); // 'prod' | 'nonprod'
  const [statusTab, setStatusTab] = useState("open"); // 'open' | 'closed'

  // Carga base: ayer -> ahora (OPEN + CLOSED)
  useEffect(() => {
    let mounted = true;

    async function loadAll() {
      try {
        setLoading(true);
        setError(null);
        setProblems([]);

        await fetchTcsRecent({
          onBatch: (batch) => {
            if (!mounted || !batch?.length) return;
            setProblems((prev) =>
              [...prev, ...batch].sort(
                (a, b) => new Date(b.startTime) - new Date(a.startTime)
              )
            );
          },
        });
      } catch (e) {
        if (mounted) setError(e?.message || String(e));
      } finally {
        if (mounted) setLoading(false);
      }
    }

    loadAll();
    return () => {
      mounted = false;
    };
  }, []);

  // Refresh “tiempo real” SOLO OPEN (cada 60s) para que Abiertas se sincronice
  useEffect(() => {
    let mounted = true;
    const id = setInterval(async () => {
      try {
        // Traemos SOLO las OPEN desde ayer->ahora
        const openNow = await fetchTcsRecentOpen();

        if (!mounted) return;

        // Mezclamos: mantenemos CLOSED existentes, reemplazamos OPEN por las actuales
        setProblems((prev) => {
          const closed = prev.filter((p) => normalizeStatus(p) === "CLOSED");

          // Evitar duplicados por problemId/pid
          const byId = new Map();
          for (const p of [...openNow, ...closed]) {
            const key = p?.problemId || p?.pid || p?.id || Math.random();
            if (!byId.has(key)) byId.set(key, p);
          }

          return Array.from(byId.values()).sort(
            (a, b) => new Date(b.startTime) - new Date(a.startTime)
          );
        });
      } catch {
        // no rompas la UI si falla un refresh
      }
    }, 60000);

    return () => {
      mounted = false;
      clearInterval(id);
    };
  }, []);

  if (error) return <h2 style={{ color: "red" }}>Error: {error}</h2>;

  // 1) por ambiente
  const prodList = useMemo(() => problems.filter(isProd), [problems]);
  const nonProdList = useMemo(() => problems.filter((p) => !isProd(p)), [problems]);
  const envList = envTab === "prod" ? prodList : nonProdList;

  // 2) dentro del ambiente, separar por estado
  const openList = useMemo(
    () => envList.filter((p) => normalizeStatus(p) === "OPEN"),
    [envList]
  );
  const closedList = useMemo(
    () => envList.filter((p) => normalizeStatus(p) === "CLOSED"),
    [envList]
  );
  const selectedList = statusTab === "open" ? openList : closedList;

  return (
    <div style={{ maxWidth: "900px", margin: "0 auto", padding: "1rem" }}>
      <h2>
        Problemas TCS <span>({problems.length})</span>
      </h2>

      <UsernameInput value={username} onChange={setUsername} />

      {loading && problems.length === 0 && <p>Cargando problemas TCS…</p>}
      {!loading && problems.length === 0 && <p>No hay problemas TCS desde ayer hasta ahora.</p>}

      {/* Tabs de ambiente */}
      <div style={{ display: "flex", gap: ".5rem", margin: "1rem 0 .5rem" }}>
        <button
          onClick={() => setEnvTab("prod")}
          disabled={envTab === "prod"}
          style={{
            padding: ".5rem 1rem",
            borderRadius: "999px",
            border: "1px solid #cbd5e1",
            background: envTab === "prod" ? "#dbeafe" : "#f8fafc",
            fontWeight: envTab === "prod" ? "bold" : "normal",
            cursor: envTab === "prod" ? "default" : "pointer",
          }}
        >
          Productivo ({prodList.length})
        </button>

        <button
          onClick={() => setEnvTab("nonprod")}
          disabled={envTab === "nonprod"}
          style={{
            padding: ".5rem 1rem",
            borderRadius: "999px",
            border: "1px solid #cbd5e1",
            background: envTab === "nonprod" ? "#fef3c7" : "#f8fafc",
            fontWeight: envTab === "nonprod" ? "bold" : "normal",
            cursor: envTab === "nonprod" ? "default" : "pointer",
          }}
        >
          No Productivo ({nonProdList.length})
        </button>
      </div>

      {/* Subtabs de estado */}
      <div style={{ display: "flex", gap: ".5rem", margin: ".25rem 0 1rem" }}>
        <button
          onClick={() => setStatusTab("open")}
          disabled={statusTab === "open"}
          style={{
            padding: ".35rem .9rem",
            borderRadius: "999px",
            border: "1px solid #e5e7eb",
            background: statusTab === "open" ? "#fde68a" : "#ffffff",
            fontWeight: statusTab === "open" ? "bold" : "normal",
            cursor: statusTab === "open" ? "default" : "pointer",
          }}
        >
          Abiertas ({openList.length})
        </button>

        <button
          onClick={() => setStatusTab("closed")}
          disabled={statusTab === "closed"}
          style={{
            padding: ".35rem .9rem",
            borderRadius: "999px",
            border: "1px solid #e5e7eb",
            background: statusTab === "closed" ? "#bbf7d0" : "#ffffff",
            fontWeight: statusTab === "closed" ? "bold" : "normal",
            cursor: statusTab === "closed" ? "default" : "pointer",
          }}
        >
          Cerradas ({closedList.length})
        </button>
      </div>

      {selectedList.map((p) => (
        <ProblemCard
          key={p.problemId || p.pid || p.id}
          problem={p}
          username={username}
        />
      ))}
    </div>
  );
}

----2132


// src/pages/OtherProblems.jsx
import React, { useEffect, useMemo, useState } from "react";
import { fetchNotTcsRecent, fetchNotTcsRecentOpen } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

// ===== Detección de ambiente (igual que TCS) =====
function detectEnvironmentRaw(problem) {
  const raw =
    problem?.environmentIcon ||
    problem?.environmentText ||
    problem?.environment ||
    problem?.entorno ||
    problem?.env ||
    "";
  return String(raw).toLowerCase().trim();
}

function isProd(problem) {
  const env = detectEnvironmentRaw(problem);

  if (
    env.includes("icon-noproductivo") ||
    env.includes("no-productivo") ||
    env.includes("noproductivo")
  ) {
    return false;
  }
  if (env.includes("icon-productivo")) return true;

  const nonProdRegex =
    /\b(enp|np|qa|q\/a|dev|desa|desarrollo|test|testing|stg|stage|staging|uat|preprod|pre-prod|pre\s*prod|preprodu)\b/i;
  if (nonProdRegex.test(env)) return false;

  if (/\b(productivo|producci[oó]n|production)\b/i.test(env)) return true;
  if (/\bprod\b/i.test(env) || /^prod[\w-]*/i.test(env)) return true;

  return false;
}

// ===== Normalización OPEN/CLOSED =====
function normalizeStatus(p) {
  const raw = p?.status ?? p?.Status ?? p?.problemStatus ?? "";
  let s = String(raw).trim().toUpperCase();

  if (s.includes("CLOSED") || s.includes("RESOLVED")) return "CLOSED";
  if (s.includes("OPEN")) return "OPEN";

  return p?.endTime ? "CLOSED" : "OPEN";
}

export default function OtherProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [username, setUsername] = useState("");

  const [envTab, setEnvTab] = useState("prod"); // 'prod' | 'nonprod'
  const [statusTab, setStatusTab] = useState("open"); // 'open' | 'closed'

  // Carga base: ayer -> ahora (OPEN + CLOSED)
  useEffect(() => {
    let mounted = true;

    async function loadAll() {
      try {
        setLoading(true);
        setError(null);
        setProblems([]);

        await fetchNotTcsRecent({
          onBatch: (batch) => {
            if (!mounted || !batch?.length) return;
            setProblems((prev) =>
              [...prev, ...batch].sort(
                (a, b) => new Date(b.startTime) - new Date(a.startTime)
              )
            );
          },
        });
      } catch (e) {
        if (mounted) setError(e?.message || String(e));
      } finally {
        if (mounted) setLoading(false);
      }
    }

    loadAll();
    return () => {
      mounted = false;
    };
  }, []);

  // Refresh “tiempo real” SOLO OPEN (cada 60s)
  useEffect(() => {
    let mounted = true;
    const id = setInterval(async () => {
      try {
        const openNow = await fetchNotTcsRecentOpen();
        if (!mounted) return;

        setProblems((prev) => {
          const closed = prev.filter((p) => normalizeStatus(p) === "CLOSED");

          const byId = new Map();
          for (const p of [...openNow, ...closed]) {
            const key = p?.problemId || p?.pid || p?.id || Math.random();
            if (!byId.has(key)) byId.set(key, p);
          }

          return Array.from(byId.values()).sort(
            (a, b) => new Date(b.startTime) - new Date(a.startTime)
          );
        });
      } catch {
        // ignora fallas de refresh
      }
    }, 60000);

    return () => {
      mounted = false;
      clearInterval(id);
    };
  }, []);

  if (error) return <h2 style={{ color: "red" }}>Error: {error}</h2>;

  const prodList = useMemo(() => problems.filter(isProd), [problems]);
  const nonProdList = useMemo(() => problems.filter((p) => !isProd(p)), [problems]);
  const envList = envTab === "prod" ? prodList : nonProdList;

  const openList = useMemo(
    () => envList.filter((p) => normalizeStatus(p) === "OPEN"),
    [envList]
  );
  const closedList = useMemo(
    () => envList.filter((p) => normalizeStatus(p) === "CLOSED"),
    [envList]
  );
  const selectedList = statusTab === "open" ? openList : closedList;

  return (
    <div style={{ maxWidth: "900px", margin: "0 auto", padding: "1rem" }}>
      <h2>
        Problemas Otros <span>({problems.length})</span>
      </h2>

      <UsernameInput value={username} onChange={setUsername} />

      {loading && problems.length === 0 && <p>Cargando problemas…</p>}
      {!loading && problems.length === 0 && <p>No hay problemas de terceros desde ayer hasta ahora.</p>}

      {/* Tabs de ambiente */}
      <div style={{ display: "flex", gap: ".5rem", margin: "1rem 0 .5rem" }}>
        <button
          onClick={() => setEnvTab("prod")}
          disabled={envTab === "prod"}
          style={{
            padding: ".5rem 1rem",
            borderRadius: "999px",
            border: "1px solid #cbd5e1",
            background: envTab === "prod" ? "#dbeafe" : "#f8fafc",
            fontWeight: envTab === "prod" ? "bold" : "normal",
            cursor: envTab === "prod" ? "default" : "pointer",
          }}
        >
          Productivo ({prodList.length})
        </button>

        <button
          onClick={() => setEnvTab("nonprod")}
          disabled={envTab === "nonprod"}
          style={{
            padding: ".5rem 1rem",
            borderRadius: "999px",
            border: "1px solid #cbd5e1",
            background: envTab === "nonprod" ? "#fef3c7" : "#f8fafc",
            fontWeight: envTab === "nonprod" ? "bold" : "normal",
            cursor: envTab === "nonprod" ? "default" : "pointer",
          }}
        >
          No Productivo ({nonProdList.length})
        </button>
      </div>

      {/* Subtabs de estado */}
      <div style={{ display: "flex", gap: ".5rem", margin: ".25rem 0 1rem" }}>
        <button
          onClick={() => setStatusTab("open")}
          disabled={statusTab === "open"}
          style={{
            padding: ".35rem .9rem",
            borderRadius: "999px",
            border: "1px solid #e5e7eb",
            background: statusTab === "open" ? "#fde68a" : "#ffffff",
            fontWeight: statusTab === "open" ? "bold" : "normal",
            cursor: statusTab === "open" ? "default" : "pointer",
          }}
        >
          Abiertas ({openList.length})
        </button>

        <button
          onClick={() => setStatusTab("closed")}
          disabled={statusTab === "closed"}
          style={{
            padding: ".35rem .9rem",
            borderRadius: "999px",
            border: "1px solid #e5e7eb",
            background: statusTab === "closed" ? "#bbf7d0" : "#ffffff",
            fontWeight: statusTab === "closed" ? "bold" : "normal",
            cursor: statusTab === "closed" ? "default" : "pointer",
          }}
        >
          Cerradas ({closedList.length})
        </button>
      </div>

      {selectedList.map((p) => (
        <ProblemCard
          key={p.problemId || p.pid || p.id}
          problem={p}
          username={username}
        />
      ))}
    </div>
  );
}
