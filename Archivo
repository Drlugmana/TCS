import React, { useEffect, useMemo, useRef, useState } from "react";
import { fetchTcsAllHistory, fetchTcsOpenRecent } from "../api/problems";
import ProblemCard from "../components/ProblemCard";
import UsernameInput from "../components/UsernameInput";

/* ===== Detección de ambiente (idéntico) ===== */
function detectEnvironmentRaw(problem) {
  const raw =
    problem?.environmentIcon ||
    problem?.environmentText ||
    problem?.environment ||
    problem?.Environment ||
    problem?.entorno ||
    problem?.env ||
    "";
  return String(raw).toLowerCase().trim();
}

function isProd(problem) {
  const env = detectEnvironmentRaw(problem);

  // casos explícitos
  if (
    env.includes("icon-noproductivo") ||
    env.includes("no-productivo") ||
    env.includes("noproductivo")
  ) {
    return false;
  }
  if (env.includes("icon-productivo")) return true;

  // heurística por texto
  const nonProdRegex =
    /\b(enp|np|qa|q\/a|dev|desa|desarrollo|test|testing|stg|stage|staging|uat|preprod|pre-prod|pre\s*prod)\b/i;
  if (nonProdRegex.test(env)) return false;

  if (/\b(productivo|producci[oó]n|production)\b/i.test(env)) return true;
  if (/\bprod\b/i.test(env) || /prod[\w-]*/i.test(env)) return true;

  return false;
}

/* ===== Normalización de estado OPEN/CLOSED ===== */
function normalizeStatus(p) {
  const raw = p?.status ?? p?.Status ?? p?.problemStatus ?? p?.ProblemStatus ?? "";
  const s = String(raw).trim().toUpperCase();

  // Si no viene status, inferimos por endTime
  if (!s) return p?.endTime ? "CLOSED" : "OPEN";

  if (s.includes("CLOSED") || s.includes("RESOLVED")) return "CLOSED";
  if (s.includes("OPEN")) return "OPEN";

  // fallback
  return p?.endTime ? "CLOSED" : "OPEN";
}

/* ===== Merge por ID para no “perder” OPEN ===== */
function keyOf(p) {
  return p?.problemId || p?.displayId || p?.id || "";
}

function mergeUnique(oldList, newList) {
  const map = new Map();
  for (const p of oldList) map.set(keyOf(p), p);
  for (const p of newList) map.set(keyOf(p), p);
  return Array.from(map.values());
}

export default function TCSProblems() {
  const [problems, setProblems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [username, setUsername] = useState("");

  const [envTab, setEnvTab] = useState("prod"); // 'prod' | 'nonprod'
  const [statusTab, setStatusTab] = useState("open"); // 'open' | 'closed'

  const refreshTimer = useRef(null);

  // ===== Carga inicial: histórico + OPEN recientes =====
  useEffect(() => {
    let mounted = true;

    async function loadInitial() {
      try {
        setLoading(true);
        setError(null);
        setProblems([]);

        // 1) Traer histórico completo (para ver cerradas como antes)
        //    (va llenando en batches)
        const historyPromise = fetchTcsAllHistory({
          pageSize: 500,
          maxPages: 40,
          onBatch: (batch) => {
            if (!mounted) return;
            setProblems((prev) => {
              const merged = mergeUnique(prev, batch);
              // Ordenar por startTime desc
              merged.sort((a, b) => (new Date(b.startTime || 0) - new Date(a.startTime || 0)));
              return merged;
            });
          },
        });

        // 2) Traer OPEN recientes (ayer + hoy = 2 días)
        const recentOpen = await fetchTcsOpenRecent(2);

        if (!mounted) return;

        // Garantizar que las OPEN recientes estén sí o sí
        setProblems((prev) => {
          const merged = mergeUnique(prev, recentOpen);
          merged.sort((a, b) => (new Date(b.startTime || 0) - new Date(a.startTime || 0)));
          return merged;
        });

        // esperar a que termine histórico (por si quieres “loading” correcto)
        await historyPromise;
      } catch (e) {
        if (!mounted) return;
        setError(e?.message || String(e));
      } finally {
        if (mounted) setLoading(false);
      }
    }

    loadInitial();

    return () => {
      mounted = false;
      if (refreshTimer.current) clearInterval(refreshTimer.current);
    };
  }, []);

  // ===== Refresco automático SOLO de OPEN recientes (cada 60s) =====
  useEffect(() => {
    // evita duplicar intervalos
    if (refreshTimer.current) clearInterval(refreshTimer.current);

    refreshTimer.current = setInterval(async () => {
      try {
        const recentOpen = await fetchTcsOpenRecent(2);

        setProblems((prev) => {
          // Reemplazamos/inyectamos las OPEN recientes sin tocar el resto del histórico
          const merged = mergeUnique(prev, recentOpen);
          merged.sort((a, b) => (new Date(b.startTime || 0) - new Date(a.startTime || 0)));
          return merged;
        });
      } catch {
        // si falla el refresh no rompas la UI
      }
    }, 60000);

    return () => {
      if (refreshTimer.current) clearInterval(refreshTimer.current);
    };
  }, []);

  // ===== Listas por tabs =====
  const prodList = useMemo(() => problems.filter(isProd), [problems]);

  // ✅ IMPORTANTE: aquí era tu bug en screenshot: estabas usando isProd en vez de !isProd
  const nonProdList = useMemo(() => problems.filter((p) => !isProd(p)), [problems]);

  const envList = envTab === "prod" ? prodList : nonProdList;

  const openList = useMemo(() => envList.filter((p) => normalizeStatus(p) === "OPEN"), [envList]);
  const closedList = useMemo(() => envList.filter((p) => normalizeStatus(p) === "CLOSED"), [envList]);

  const selectedList = statusTab === "open" ? openList : closedList;

  if (error) return <h2 style={{ color: "red" }}>Error: {error}</h2>;

  return (
    <div style={{ maxWidth: "900px", margin: "0 auto", padding: "1rem" }}>
      <h2>
        Problemas TCS <span>({problems.length})</span>
      </h2>

      <UsernameInput value={username} onChange={setUsername} />

      {loading && problems.length === 0 && <p>Cargando problemas TCS...</p>}
      {!loading && problems.length === 0 && <p>No hay problemas TCS.</p>}

      {/* Tabs de ambiente */}
      <div style={{ display: "flex", gap: ".5rem", margin: "1rem 0 .5rem" }}>
        <button
          onClick={() => setEnvTab("prod")}
          disabled={envTab === "prod"}
          style={{
            padding: ".5rem 1rem",
            borderRadius: "999px",
            border: "1px solid #cbd5e1",
            background: envTab === "prod" ? "#dbeafe" : "#f8fafc",
            fontWeight: envTab === "prod" ? "bold" : "normal",
            cursor: envTab === "prod" ? "default" : "pointer",
          }}
        >
          Productivo ({prodList.length})
        </button>

        <button
          onClick={() => setEnvTab("nonprod")}
          disabled={envTab === "nonprod"}
          style={{
            padding: ".5rem 1rem",
            borderRadius: "999px",
            border: "1px solid #cbd5e1",
            background: envTab === "nonprod" ? "#fef3c7" : "#f8fafc",
            fontWeight: envTab === "nonprod" ? "bold" : "normal",
            cursor: envTab === "nonprod" ? "default" : "pointer",
          }}
        >
          No Productivo ({nonProdList.length})
        </button>
      </div>

      {/* Subtabs de estado */}
      <div style={{ display: "flex", gap: ".5rem", margin: ".25rem 0 1rem" }}>
        <button
          onClick={() => setStatusTab("open")}
          disabled={statusTab === "open"}
          style={{
            padding: ".35rem .9rem",
            borderRadius: "999px",
            border: "1px solid #e5e7eb",
            background: statusTab === "open" ? "#fde68a" : "#ffffff",
            fontWeight: statusTab === "open" ? "bold" : "normal",
            cursor: statusTab === "open" ? "default" : "pointer",
          }}
        >
          Abiertas ({openList.length})
        </button>

        <button
          onClick={() => setStatusTab("closed")}
          disabled={statusTab === "closed"}
          style={{
            padding: ".35rem .9rem",
            borderRadius: "999px",
            border: "1px solid #e5e7eb",
            background: statusTab === "closed" ? "#bbf7d0" : "#ffffff",
            fontWeight: statusTab === "closed" ? "bold" : "normal",
            cursor: statusTab === "closed" ? "default" : "pointer",
          }}
        >
          Cerradas ({closedList.length})
        </button>
      </div>

      {/* Render lista */}
      {selectedList.map((p) => (
        <ProblemCard key={keyOf(p)} problem={p} username={username} />
      ))}
    </div>
  );
}